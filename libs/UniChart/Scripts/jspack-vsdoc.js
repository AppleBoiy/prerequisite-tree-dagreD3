MindFusion = {
	Scheduling: {
		BaseForm: function (calendar, item) {
			/// <summary>The BaseForm class is the base class for all built-in forms.</summary>
			/// <param name="calendar" type="Calendar">Calendar. The calendar parent object of this form.</param>
			/// <param name="item" type="Item">Item. The item instance associated with this form.</param>
			/// <field name="calendar" type="MindFusion.Scheduling.Calendar">Gets the calendar, displaying the form.</field>
			/// <field name="controls" type="MindFusion.Scheduling.Dictionary">Gets the controls collection.</field>
			/// <field name="formatInfo" type="Object">Gets the locale object used to format and display date and time information in the form.</field>
			/// <field name="headerText" type="String">Gets or sets the text which is displayed in the header of the form.</field>
			/// <field name="id" type="String">Gets the id of the form.</field>
			/// <field name="item" type="MindFusion.Scheduling.Item">Gets the item, whose information is displayed in the form.</field>
			/// <field name="localInfo" type="Object">Gets the locale object used to format and display localizable strings in the form.</field>
			/// <field name="type" type="String">Gets the type of the form.</field>
		},
		ButtonEventArgs: function (button) {
			/// <summary>Specifies data for the ButtonClick event.</summary>
			/// <param name="button" type="Number">Number. A value indicating which navigation button is clicked.</param>
			/// <field name="button" type="Number">Gets a value indicating which navigation button is clicked.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		Calendar: function (element) {
			/// <summary>The Calendar control serves as a view in document-viewarchitecture, where the document is implemented by theSchedule class. The Calendar provides several schedulerelated views, such as Month, List, Timetable, thatpresent the scheduled events in different styles and layouts.</summary>
			/// <param name="element" type="DomElement">DomElement. The element this Calendar is associated with.</param>
			/// <field name="allowInplaceEdit" type="Boolean">Gets or sets a value indicating whether calendar's items can be inplace-edited.</field>
			/// <field name="cells" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of cells in the calendar view.</field>
			/// <field name="contactNameFormat" type="String">Gets or sets a value indicating how to format and display contact names in view headers.</field>
			/// <field name="contacts" type="MindFusion.Scheduling.ObservableCollection">Gets the contacts whose schedule to display when the GroupType property is set to GroupByContacts or FilterByContacts.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the calendar.</field>
			/// <field name="currentView" type="MindFusion.Scheduling.CalendarView">Gets or sets the type of the current view of the calendar.</field>
			/// <field name="date" type="MindFusion.Scheduling.DateTime">Gets or sets the date of the calendar.</field>
			/// <field name="element" type="DomElement">Gets a reference to the calendar DOM element.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed in the calendar.</field>
			/// <field name="endDate" type="MindFusion.Scheduling.DateTime">Gets or sets the end date of the calendar.</field>
			/// <field name="endTime" type="MindFusion.Scheduling.DateTime">Gets the end time of the last calendar cell.</field>
			/// <field name="formatInfo" type="Object">Gets the locale object used to format and display date and time information in the calendar.</field>
			/// <field name="groupType" type="MindFusion.Scheduling.GroupType">Gets or sets the grouping or filtering criteria for the calendar.</field>
			/// <field name="header" type="DomElement">Gets a reference to the DOM element of the calendar main header.</field>
			/// <field name="itemSelection" type="MindFusion.Scheduling.ObservableCollection">Gets the list of currently selected items.</field>
			/// <field name="itemsEndTime" type="MindFusion.Scheduling.DateTime">Gets the end time of the last calendar cell, that can contain items.</field>
			/// <field name="itemSettings" type="MindFusion.Scheduling.ItemSettings">Gets the ItemSettings object used to customize the appearance of calendar items.</field>
			/// <field name="itemsStartTime" type="MindFusion.Scheduling.DateTime">Gets the start time of the first calendar cell, that can contain items.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the calendar's license file.</field>
			/// <field name="listSettings" type="MindFusion.Scheduling.ListSettings">Gets the ListSettings object used to customize the appearance of the List view.</field>
			/// <field name="locale" type="Object">Gets or sets the locale object used to format and display localizable information in the calendar.</field>
			/// <field name="localInfo" type="Object">Gets the locale object used to format and display localizable strings in the calendar.</field>
			/// <field name="locations" type="MindFusion.Scheduling.ObservableCollection">Gets the locations whose schedule to display when the GroupType property is set to GroupByLocations or FilterByLocations.</field>
			/// <field name="monthRangeSettings" type="MindFusion.Scheduling.MonthRangeSettings">Gets the MonthRangeSettings object used to customize the appearance of the MonthRange view.</field>
			/// <field name="monthSettings" type="MindFusion.Scheduling.MonthSettings">Gets the MonthSettings object used to customize the appearance of the SingleMonth view.</field>
			/// <field name="resources" type="MindFusion.Scheduling.ObservableCollection">Gets the resources whose schedule to display when the GroupType property is set to GroupByResources or FilterByResources.</field>
			/// <field name="resourceViewSettings" type="MindFusion.Scheduling.ResourceViewSettings">Gets the ResourceViewSettings object used to customize the appearance of the Resource view.</field>
			/// <field name="schedule" type="MindFusion.Scheduling.Schedule">Gets or sets the schedule to be displayed inside the calendar.</field>
			/// <field name="selection" type="MindFusion.Scheduling.Selection">Gets the current calendar selection.</field>
			/// <field name="showTooltips" type="Boolean">Gets or sets a value indicating whether to show tooltips.</field>
			/// <field name="startTime" type="MindFusion.Scheduling.DateTime">Gets the start time of the first calendar cell.</field>
			/// <field name="tasks" type="MindFusion.Scheduling.ObservableCollection">Gets the tasks whose schedule to display when the GroupType property is set to GroupByTasks or FilterByTasks.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the calendar.</field>
			/// <field name="timetableSettings" type="MindFusion.Scheduling.TimetableSettings">Gets the TimetableSettings object used to customize the appearance of the Timetable view.</field>
			/// <field name="useForms" type="Boolean">Gets or sets a value indicating whether the built-in forms for item editing will be used.</field>
			/// <field name="weekRangeSettings" type="MindFusion.Scheduling.WeekRangeSettings">Gets the WeekRangeSettings object used to customize the appearance of the WeekRange view.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a navigation button is clicked Syntax: buttonClick.addEventListener( function(sender, args){} );</field>
			/// <field name="calendarLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: calendarLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="cellClick" type="EventDispatcher">Raised when a calendar time cell is clicked. Syntax: cellClick.addEventListener( function(sender, args){} );</field>
			/// <field name="cellDoubleClick" type="EventDispatcher">Raised when a calendar time cell is double-clicked. Syntax: cellDoubleClick.addEventListener( function(sender, args){} );</field>
			/// <field name="cueClick" type="EventDispatcher">Raised when an item cue is clicked. Syntax: cueClick.addEventListener( function(sender, args){} );</field>
			/// <field name="formClose" type="EventDispatcher">Raised when a popup form is closed. Syntax: formClose.addEventListener( function(sender, args){} );</field>
			/// <field name="formShow" type="EventDispatcher">Raised when a popup form is shown. Syntax: formShow.addEventListener( function(sender, args){} );</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when a calendar header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} );</field>
			/// <field name="headerDoubleClick" type="EventDispatcher">Raised when a calendar header is double-clicked. Syntax: headerDoubleClick.addEventListener( function(sender, args){} );</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} );</field>
			/// <field name="itemCreated" type="EventDispatcher">Raised when an item is created. Syntax: itemCreated.addEventListener( function(sender, args){} );</field>
			/// <field name="itemCreating" type="EventDispatcher">Raised while an item is being created. Syntax: itemCreating.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDeleted" type="EventDispatcher">Raised when an item is deleted. Syntax: itemDeleted.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDeleting" type="EventDispatcher">Raised while an item is being deleted. Syntax: itemDeleting.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} );</field>
			/// <field name="itemModified" type="EventDispatcher">Raised when an item is modified. Syntax: itemModified.addEventListener( function(sender, args){} );</field>
			/// <field name="itemModifying" type="EventDispatcher">Raised while an item is being modified. Syntax: itemModifying.addEventListener( function(sender, args){} );</field>
			/// <field name="itemReminderTriggered" type="EventDispatcher">Raised when an item remider is triggered. Syntax: itemReminderTriggered.addEventListener( function(sender, args){} );</field>
			/// <field name="itemSelectionChanged" type="EventDispatcher">Raised when a selection of items changes. Syntax: itemSelectionChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="recurringItemDeleting" type="EventDispatcher">Raised while a recurring item is being deleted. Syntax: recurringItemDeleting.addEventListener( function(sender, args){} );</field>
			/// <field name="scheduleChanged" type="EventDispatcher">Raised when the calendar's schedule has changed. Syntax: scheduleChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when a selection changes. Syntax: selectionChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="selectionEnd" type="EventDispatcher">Raised when a selection has ended. Syntax: selectionEnd.addEventListener( function(sender, args){} );</field>
			/// <field name="selectionStart" type="EventDispatcher">Raised when a selection is started. Syntax: selectionStart.addEventListener( function(sender, args){} );</field>
			/// <field name="taskReminderTriggered" type="EventDispatcher">Raised when an task remider is triggered. Syntax: taskReminderTriggered.addEventListener( function(sender, args){} );</field>
			/// <field name="visibleDateChanged" type="EventDispatcher">Raised when the calendar date is changed. Syntax: visibleDateChanged.addEventListener( function(sender, args){} );</field>
		},
		CancelEventArgs: function () {
			/// <summary>Provides a value to use with cancellable events.</summary>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation.</field>
		},
		CellEventArgs: function (cell) {
			/// <summary>Specifies data for cell related events.</summary>
			/// <param name="cell" type="ViewCell">ViewCell. The calendar view cell related to the event.</param>
			/// <field name="cell" type="MindFusion.Scheduling.ViewCell">Gets the calendar view cell related to the event.</field>
		},
		Contact: function () {
			/// <summary>Represents an object that holds contact data for a person.</summary>
			/// <field name="address" type="String">Gets or sets the address of the contact.</field>
			/// <field name="email" type="String">Gets or sets the email of the contact.</field>
			/// <field name="firstName" type="String">Gets or sets the first name of the contact.</field>
			/// <field name="lastName" type="String">Gets or sets the last name of the contact.</field>
			/// <field name="middleName" type="String">Gets or sets the middle name of the contact.</field>
			/// <field name="phone" type="String">Gets or sets the phone of the contact.</field>
			/// <field name="id" type="String">Gets or sets the string identifier for this resource. Inherited from Resource.</field>
			/// <field name="name" type="String">Gets or sets the name for this resource. Inherited from Resource.</field>
			/// <field name="tag" type="Object">Gets or sets custom data associated with the resource. Inherited from Resource.</field>
		},
		DateChangedEventArgs: function (newDate, prevDate) {
			/// <summary>Specifies data for the VisibleDateChanged event.</summary>
			/// <param name="newDate" type="DateTime">DateTime. The new visible date.</param>
			/// <param name="prevDate" type="DateTime">DateTime. The previous visible date.</param>
			/// <field name="newDate" type="MindFusion.Scheduling.DateTime">Gets the new visible date.</field>
			/// <field name="prevDate" type="MindFusion.Scheduling.DateTime">Gets the previous visible date.</field>
		},
		DateTime: function (date) {
			/// <summary>A Javascript Date object wrapper that extends the functionality of the JavaScript Date object.</summary>
			/// <param name="date" type="Date">Date. A JavaScript Date object.</param>
			/// <field name="date" type="MindFusion.Scheduling.DateTime">Gets the date component of this DateTime object.</field>
			/// <field name="day" type="Number">Gets the day component of the date represented by this instance.</field>
			/// <field name="dayOfWeek" type="Number">Gets the day of the week represented by this date.</field>
			/// <field name="daysInMonth" type="Number">Gets the number of days in the month represented by this date.</field>
			/// <field name="hour" type="Number">Gets the hour component of the date represented by this instance.</field>
			/// <field name="millisecond" type="Number">Gets the millisecond component of the date represented by this instance.</field>
			/// <field name="minute" type="Number">Gets the minute component of the date represented by this instance.</field>
			/// <field name="month" type="Number">Gets the month component of the date represented by this instance.</field>
			/// <field name="second" type="Number">Gets the second component of the date represented by this instance.</field>
			/// <field name="timeOfDay" type="Number">Gets the time component of this DateTime object, expressed in milliseconds.</field>
			/// <field name="year" type="Number">Gets the year component of the date represented by this instance.</field>
		},
		Dictionary: function () {
			/// <summary>Represents a collection of keys and values.</summary>
		},
		EmptyEventArgs: function () {
			/// <summary>Provides a value to use with events that do not have event data.</summary>
		},
		EventArgs: function () {
			/// <summary>The base type of classes that define arguments passed to event handler functions.</summary>
		},
		EventDispatcher: function () {
			/// <summary>Represents a dispatcher for an event.</summary>
		},
		FormEventArgs: function (form) {
			/// <summary>Specifies data for form related events</summary>
			/// <param name="form" type="BaseForm">BaseForm. The form instance related to the event.</param>
			/// <field name="form" type="MindFusion.Scheduling.BaseForm">Gets the form related to the event.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		HeaderEventArgs: function (type) {
			/// <summary>Specifies data for header related events.</summary>
			/// <param name="type" type="HeaderType">HeaderType. The type of the header related to the event.</param>
			/// <field name="type" type="MindFusion.Scheduling.HeaderType">Gets the type of the header related to the event.</field>
		},
		IEnumerable: function (items) {
			/// <summary>Represents an array of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
		},
		Item: function () {
			/// <summary>Represents appointments within a schedule.</summary>
			/// <field name="allDayEvent" type="Boolean">Gets or sets a value indicating whether the item represents an all day event.</field>
			/// <field name="allowChangeEnd" type="Boolean">Gets or sets a value indicating whether users are allowed to change the item's end time.</field>
			/// <field name="allowChangeStart" type="Boolean">Gets or sets a value indicating whether users are allowed to change the item's start time.</field>
			/// <field name="allowMove" type="Boolean">Gets or sets a value indicating whether users are allowed to move the item.</field>
			/// <field name="contacts" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of contacts associated with this item.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the item.</field>
			/// <field name="details" type="String">Gets or sets the description rendered for this item by the scheduling control.</field>
			/// <field name="endTime" type="MindFusion.Scheduling.DateTime">Gets or sets item's scheduled end time.</field>
			/// <field name="id" type="String">Gets or sets the string identifier for this item.</field>
			/// <field name="location" type="MindFusion.Scheduling.Location">Gets or sets the location associated with this item.</field>
			/// <field name="locked" type="Boolean">Gets or sets a value indicating whether users are forbidden to modify this item.</field>
			/// <field name="occurrenceIndex" type="Number">Gets the index of a repeating occurrence of a recurring item.</field>
			/// <field name="priority" type="Number">Gets or sets the priority of the item.</field>
			/// <field name="recurrence" type="MindFusion.Scheduling.Recurrence">Gets or sets the recurrence pattern of this item.</field>
			/// <field name="recurrenceState" type="MindFusion.Scheduling.RecurrenceState">Gets the recurrence state of this item.</field>
			/// <field name="reminder" type="MindFusion.Scheduling.Reminder">Gets or sets the reminder for this item.</field>
			/// <field name="resources" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of resources associated with this item.</field>
			/// <field name="startTime" type="MindFusion.Scheduling.DateTime">Gets or sets item's scheduled start time.</field>
			/// <field name="subject" type="String">Gets or sets the text rendered in the header for this item by the scheduling control.</field>
			/// <field name="tag" type="Object">Gets or sets custom data associated with the item.</field>
			/// <field name="task" type="MindFusion.Scheduling.Task">Gets or sets the task associated with this item.</field>
			/// <field name="visible" type="Boolean">Gets or sets a value indicating whether the item is visible or not.</field>
		},
		ItemEventArgs: function (item, rawEventArgs) {
			/// <summary>Specifies data for the item related events.</summary>
			/// <param name="item" type="Item">Item. The item, associated with the event.</param>
			/// <param name="rawEventArgs" type="Object">Object. The Javascript event data.</param>
			/// <field name="item" type="MindFusion.Scheduling.Item">Gets the item, associated with the event.</field>
			/// <field name="rawEventArgs" type="Object">Gets the Javascript event data.</field>
		},
		ItemModifiedEventArgs: function (item, oldItem, action) {
			/// <summary>Specifies data for the ItemModified event.</summary>
			/// <param name="item" type="Item">Item. The new item.</param>
			/// <param name="oldItem" type="Item">Item. The old item.</param>
			/// <param name="action" type="ItemModifyAction">ItemModifyAction. The action that has modified the item.</param>
			/// <field name="action" type="MindFusion.Scheduling.ItemModifyAction">Gets the type of action that is modifying the item.</field>
			/// <field name="item" type="MindFusion.Scheduling.Item">Gets the item that was modified.</field>
			/// <field name="oldItem" type="MindFusion.Scheduling.Item">Gets the item before the modification has occurred.</field>
		},
		ItemModifyingEventArgs: function (item, changes, action) {
			/// <summary>Specifies data for the ItemModifying event.</summary>
			/// <param name="item" type="Item">Item. The new item.</param>
			/// <param name="changes" type="Object">Object. An object containing the changed properties.</param>
			/// <param name="action" type="ItemModifyAction">ItemModifyAction. The action that is modifying the item.</param>
			/// <field name="action" type="MindFusion.Scheduling.ItemModifyAction">Gets the type of action that is modifying the item.</field>
			/// <field name="changes" type="Object">Gets the changed properties of the item, associated with the event.</field>
			/// <field name="item" type="MindFusion.Scheduling.Item">Gets the item that is modified.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		ItemSettings: function () {
			/// <summary>Defines properties that enable appearance customization of schedule items in the calendar views.</summary>
			/// <field name="cssClass" type="String">Gets or sets the default CSS class for all appointments whose CSS is not explicitly specified.</field>
			/// <field name="showContinuationArrows" type="Boolean">Gets or sets a value indicating whether to display small arrows at the beginning or at the end of each incomplete segment toindicate that the schedule item continues in an adjacent calendar cell.</field>
			/// <field name="showCues" type="Boolean">Gets or sets a value indicating whether to display a 'more items' link in a calendar cell which isn't big enough to contain all of its items.</field>
			/// <field name="showItems" type="Boolean">Gets or sets a value indicating whether to display schedule items.</field>
			/// <field name="size" type="Number">Gets or sets the size of schedule items drawn in the calendar.</field>
			/// <field name="spacing" type="Number">Gets or sets the amount of space between adjacent items.</field>
			/// <field name="titleFormat" type="String">Gets or sets a value indicating how to format and display item titles.</field>
			/// <field name="tooltipFormat" type="String">Gets or sets a value indicating how to format and display item tooltips.</field>
		},
		List: function (items) {
			/// <summary>Represents an array of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the list.</param>
		},
		ListSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a List view.</summary>
			/// <field name="cellUnits" type="MindFusion.Scheduling.TimeUnit">Gets or sets the resolution of the list view.</field>
			/// <field name="firstDayOfMonthFormat" type="String">Gets or sets the string used to format the cell header of the first day of each month.</field>
			/// <field name="firstDayOfYearFormat" type="String">Gets or sets the string used to format the cell header of the first day of each year.</field>
			/// <field name="generalFormat" type="String">Gets or sets the string used to format cells' headers.</field>
			/// <field name="headerStyle" type="MindFusion.Scheduling.MainHeaderStyle">Gets or sets the style of the view header.</field>
			/// <field name="maxItems" type="Number">Gets or sets the maximum number of items to display in a cell.</field>
			/// <field name="numberOfCells" type="Number">Gets or sets the total number of cells to be displayed in the view.</field>
			/// <field name="orientation" type="MindFusion.Scheduling.Orientation">Gets or sets the orientation of the view.</field>
			/// <field name="titleFormat" type="String">Gets or sets the string used to format the header title.</field>
			/// <field name="visibleCells" type="Number">Gets or sets the number of cells visible at the same time.</field>
		},
		Location: function () {
			/// <summary>Specifies data that identifies a location.</summary>
			/// <field name="address" type="String">Gets or sets the address of the location.</field>
			/// <field name="city" type="String">Gets or sets the city of the location.</field>
			/// <field name="country" type="String">Gets or sets the country of the location.</field>
			/// <field name="state" type="String">Gets or sets the state of the location.</field>
			/// <field name="zipCode" type="String">Gets or sets the zip code of the location.</field>
			/// <field name="id" type="String">Gets or sets the string identifier for this resource. Inherited from Resource.</field>
			/// <field name="name" type="String">Gets or sets the name for this resource. Inherited from Resource.</field>
			/// <field name="tag" type="Object">Gets or sets custom data associated with the resource. Inherited from Resource.</field>
		},
		MonthRangeSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a MonthRange view.</summary>
			/// <field name="headerStyle" type="MindFusion.Scheduling.MainHeaderStyle">Gets or sets the style of the view header.</field>
			/// <field name="monthsPerRow" type="Number">Gets or sets the number of months to be displayed in a row.</field>
			/// <field name="numberOfMonths" type="Number">Gets or sets the total number of months to be displayed in the view.</field>
			/// <field name="titleFormat" type="String">Gets or sets the string used to format the header title.</field>
			/// <field name="titleSeparator" type="String">Gets or sets the string used as a title separator.</field>
			/// <field name="visibleRows" type="Number">Gets or sets the number of rows visible at the same time.</field>
		},
		MonthSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a Month view.</summary>
			/// <field name="dayNamesHeaderStyle" type="MindFusion.Scheduling.HorizontalHeaderStyle">Gets or sets the style of the view day names header.</field>
			/// <field name="dayOfWeekFormat" type="MindFusion.Scheduling.DayOfWeekFormat">Gets or sets the format of the day names displayed in the day names header.</field>
			/// <field name="expandDayHeaders" type="Boolean">Gets or sets a value indicating whether day headers should fill the whole day cell.</field>
			/// <field name="firstDayOfMonthFormat" type="String">Gets or sets the string used to format the cell header of the first day of each month.</field>
			/// <field name="firstDayOfYearFormat" type="String">Gets or sets the string used to format the cell header of the first day of each year.</field>
			/// <field name="generalFormat" type="String">Gets or sets the string used to format cells' headers.</field>
			/// <field name="headerStyle" type="MindFusion.Scheduling.MainHeaderStyle">Gets or sets the style of the view header.</field>
			/// <field name="hideTrailingWeeks" type="Boolean">Gets or sets a value indicating whether to hide trailing weeks, which do not contain days from the current month.</field>
			/// <field name="leadingWeekCount" type="Number">Gets or sets the number of full weeks to display from the previous month.</field>
			/// <field name="maxItems" type="Number">Gets or sets the maximum number of items to display in a cell.</field>
			/// <field name="showPaddingDays" type="Boolean">Gets or sets a value indicating whether to display days from theprevious and next months at the beginning and the end of the current one, in order to fill the whole grid of day cells.</field>
			/// <field name="showPaddingItems" type="Boolean">Gets or sets a value indicating whether items are shown in padding days.</field>
			/// <field name="titleFormat" type="String">Gets or sets the string used to format the header title.</field>
			/// <field name="trailingWeekCount" type="Number">Gets or sets the number of full weeks to display from the next month.</field>
			/// <field name="weekHeaderStyle" type="MindFusion.Scheduling.VerticalHeaderStyle">Gets or sets the style of the view week numbers header.</field>
		},
		NotifyCollectionChangedAction: function () {
			/// <summary>Specifies the type of the collection changed action.</summary>
		},
		NotifyCollectionChangedEventArgs: function (action, changes, index) {
			/// <summary>Provides data for CollectionChanged events.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
		},
		NotifyCollectionChangedEventDispatcher: function () {
			/// <summary>Represents a dispatcher for NotifyCollectionChanged events.</summary>
		},
		NotifyCollectionChangingEventArgs: function (action, changes, index) {
			/// <summary>Provides data for CollectionChanging events.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		NotifyCollectionChangingEventDispatcher: function () {
			/// <summary>Represents a dispatcher for NotifyCollectionChanging events.</summary>
		},
		ObservableCollection: function (items) {
			/// <summary>Represents a collection of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
			/// <field name="collectionChanged" type="MindFusion.Scheduling.NotifyCollectionChangedEventDispatcher">Occurs when an item is added, removed, changed, moved, or the entire list is refreshed.</field>
			/// <field name="propertyChanged" type="MindFusion.Scheduling.PropertyChangedEventDispatcher">Occurs when a property value changes.</field>
		},
		PropertyChangedEventArgs: function () {
			/// <summary>Provides data for PropertyChanged events.</summary>
		},
		PropertyChangedEventDispatcher: function () {
			/// <summary>Represents a dispatcher for PropertyChanged events.</summary>
		},
		PropertyEventArgs: function (propertyName, oldValue, newValue) {
			/// <summary>Provides data for PropertyValueChanged events.</summary>
			/// <param name="propertyName" type="String">String. The name of the property that changed.</param>
			/// <param name="oldValue" type="Object">Object. The old value of the property.</param>
			/// <param name="newValue" type="Object">Object. The new value of the property.</param>
		},
		Recurrence: function () {
			/// <summary>Defines recurrence patterns for items scheduled to repeat over and over again.</summary>
			/// <field name="daily" type="MindFusion.Scheduling.DailyRecurrence">Gets or sets the type of daily recurrence.</field>
			/// <field name="day" type="MindFusion.Scheduling.DayOfWeekType">Gets or sets a value indicating the day of the week when the event occurs.</field>
			/// <field name="dayOfMonth" type="Number">Gets or sets the day of the month when the event occurs.</field>
			/// <field name="days" type="Number">Gets or sets the number of days between two consecutive occurrences of the same event.</field>
			/// <field name="daysOfWeek" type="MindFusion.Scheduling.DaysOfWeek">Gets or sets the days of the week when the event occurs.</field>
			/// <field name="end" type="MindFusion.Scheduling.RecurrenceEnd">Gets orsets the last time when the event occurs.</field>
			/// <field name="endDate" type="MindFusion.Scheduling.DateTime">Gets or sets the end date of the recurrence.</field>
			/// <field name="exceptions" type="MindFusion.Scheduling.Dictionary">Gets a list with all recurrence exceptions.</field>
			/// <field name="interval" type="Number">Gets or sets the interval of recurrence.</field>
			/// <field name="master" type="MindFusion.Scheduling.Item">Gets the master item for the recurrence.</field>
			/// <field name="monthly" type="MindFusion.Scheduling.MonthlyRecurrence">Gets or sets the type of monthly recurrence.</field>
			/// <field name="monthOfYear" type="Number">Gets or sets the month of the year when the event occurs.</field>
			/// <field name="months" type="Number">Gets or sets the number of months between two consecutive occurrences of the same event.</field>
			/// <field name="numOccurrences" type="Number">Gets or sets how many times a recurring event should occur.</field>
			/// <field name="occurrence" type="MindFusion.Scheduling.Occurrence">Gets or sets on which occurrence of the week within the month the event occurs.</field>
			/// <field name="pattern" type="MindFusion.Scheduling.RecurrencePattern">Gets or sets the recurrence pattern.</field>
			/// <field name="startDate" type="MindFusion.Scheduling.DateTime">Gets or sets the date and time of the event's first occurrence.</field>
			/// <field name="weeks" type="Number">Gets or sets the number of weeks between two consecutive occurrences of the event.</field>
			/// <field name="yearly" type="MindFusion.Scheduling.YearlyRecurrence">Gets or sets the type of yearly recurrence.</field>
		},
		Reminder: function () {
			/// <summary>Represents reminders associated with schedule items.</summary>
			/// <field name="message" type="String">Gets or sets the message to display as a reminder.</field>
			/// <field name="time" type="MindFusion.Scheduling.DateTime">Gets or sets the time when the Reminder is triggered.</field>
			/// <field name="timeInterval" type="MindFusion.Scheduling.TimeSpan">Gets or sets how much time before the item's scheduled start time to raise the event that triggers the reminder.</field>
			/// <field name="type" type="MindFusion.Scheduling.ReminderType">Gets or sets the type of this reminder.</field>
		},
		Resource: function () {
			/// <summary>Instances of the Resource class contain information about arbitrary resources.</summary>
			/// <field name="id" type="String">Gets or sets the string identifier for this resource.</field>
			/// <field name="name" type="String">Gets or sets the name for this resource.</field>
			/// <field name="tag" type="Object">Gets or sets custom data associated with the resource.</field>
		},
		ResourceViewSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a Resource view.</summary>
			/// <field name="bottomTimelineSettings" type="MindFusion.Scheduling.TimelineSettings">Gets the settings for the bottom timeline.</field>
			/// <field name="middleTimelineSettings" type="MindFusion.Scheduling.TimelineSettings">Gets the settings for the middle timeline.</field>
			/// <field name="timelines" type="Number">Gets or sets the number of timelines displayed in the view.</field>
			/// <field name="topTimelineSettings" type="MindFusion.Scheduling.TimelineSettings">Gets the settings for the top timeline.</field>
			/// <field name="visibleCells" type="Number">Gets or sets the number of cells visible at the same time.</field>
		},
		Schedule: function () {
			/// <summary>Represents a timetable of scheduled events. In the model-view architecture,Schedule instances are the documents whose data is displayed by Calendarinstances, which are the views.</summary>
			/// <field name="contacts" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of contacts in this schedule.</field>
			/// <field name="items" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of items in this schedule.</field>
			/// <field name="locations" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of locations in this schedule.</field>
			/// <field name="resources" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of resources in this schedule.</field>
			/// <field name="tasks" type="MindFusion.Scheduling.ObservableCollection">Gets the collection of tasks in this schedule.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} );</field>
		},
		Selection: function () {
			/// <summary>Represents a selected date-time range.</summary>
			/// <field name="allowMultiple" type="Boolean">Gets or sets a value indicating whether users are allowed to select more than one date cell at a time.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether users are allowed to select date cells.</field>
		},
		SelectionEventArgs: function (startTime, endTime, resource) {
			/// <summary>Specifies data for selection related events.</summary>
			/// <param name="startTime" type="DateTime">DateTime. The start time of the selection.</param>
			/// <param name="endTime" type="DateTime">DateTime. The end time of the selection</param>
			/// <param name="resource" type="Resource">Resource. The resource related to the event.</param>
			/// <field name="endTime" type="MindFusion.Scheduling.DateTime">Gets the end time of the selection.</field>
			/// <field name="resource" type="MindFusion.Scheduling.Resource">Gets the resource related to the event.</field>
			/// <field name="startTime" type="MindFusion.Scheduling.DateTime">Gets the start time of the selection.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		Task: function () {
			/// <summary>Represents a task in the calendar.</summary>
			/// <field name="actualCost" type="Number">Gets or sets the actual cost of the task.</field>
			/// <field name="actualDuration" type="Number">Gets or sets the actual duration of the task.</field>
			/// <field name="actualEnd" type="MindFusion.Scheduling.DateTime">Gets or sets the actual completion date of the task.</field>
			/// <field name="actualStart" type="MindFusion.Scheduling.DateTime">Gets or sets the actual start date of the task.</field>
			/// <field name="details" type="String">Gets or sets the details of the task.</field>
			/// <field name="dueDate" type="MindFusion.Scheduling.DateTime">Gets or sets the due date of the task.</field>
			/// <field name="estimatedCost" type="Number">Gets or sets the estimated cost of the task.</field>
			/// <field name="estimatedDuration" type="Number">Gets or sets the estimated duration of the task.</field>
			/// <field name="priority" type="MindFusion.Scheduling.TaskPriority">Gets or sets the priority of the task.</field>
			/// <field name="progress" type="Number">Gets or sets the progress of the task.</field>
			/// <field name="reminder" type="MindFusion.Scheduling.Reminder">Gets or sets the reminder of the task.</field>
			/// <field name="startDate" type="MindFusion.Scheduling.DateTime">Gets or sets the start date of the task.</field>
			/// <field name="status" type="MindFusion.Scheduling.TaskStatus">Gets or sets the status of the task.</field>
			/// <field name="subject" type="String">Gets or sets the subject of the task.</field>
			/// <field name="id" type="String">Gets or sets the string identifier for this resource. Inherited from Resource.</field>
			/// <field name="name" type="String">Gets or sets the name for this resource. Inherited from Resource.</field>
			/// <field name="tag" type="Object">Gets or sets custom data associated with the resource. Inherited from Resource.</field>
		},
		TaskEventArgs: function (task) {
			/// <summary>Specifies data for task related events.</summary>
			/// <param name="task" type="Task">Task. The Task instance for which the event is raised.</param>
			/// <field name="task" type="MindFusion.Scheduling.Task">Gets the Task instance for which the event is raised.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		TimelineSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of timelines in a Resource view.</summary>
			/// <field name="format" type="String">Gets or sets the string used to format timeline headers.</field>
			/// <field name="unit" type="MindFusion.Scheduling.TimeUnit">Gets the resolution of the timeline.</field>
			/// <field name="unitCount" type="Number">Gets or sets the number of units between adjacent ticks in the timeline.</field>
		},
		TimeRange: function (start, end) {
			/// <summary>Represents a date-time range.</summary>
			/// <param name="start" type="DateTime">DateTime. The beginning of the range.</param>
			/// <param name="end" type="DateTime">DateTime. The end of the range.</param>
			/// <field name="end" type="MindFusion.Scheduling.DateTime">Gets or sets the end of the range.</field>
			/// <field name="isEmpty" type="Boolean">Gets a value indicating whether the range is empty.</field>
			/// <field name="start" type="MindFusion.Scheduling.DateTime">Gets or sets the beginning of the range.</field>
		},
		TimeSpan: function (ticks) {
			/// <summary>Represents a time interval.</summary>
			/// <param name="ticks" type="Number">Number. The number of ticks that represent the value of the time span.</param>
			/// <field name="days" type="Number">Gets the number of days that represent the value of the time span.</field>
			/// <field name="hours" type="Number">Gets the number of hours that represent the value of the time span.</field>
			/// <field name="milliseconds" type="Number">Gets the number of milliseconds that represent the value of the time span.</field>
			/// <field name="minutes" type="Number">Gets the number of minutes that represent the value of the time span.</field>
			/// <field name="seconds" type="Number">Gets the number of seconds that represent the value of the time span.</field>
			/// <field name="ticks" type="Number">Gets the number of ticks that represent the value of the time span.</field>
		},
		TimetableSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a Timetable view.</summary>
			/// <field name="cellSize" type="Number">Gets or sets the size of time cells.</field>
			/// <field name="cellTime" type="MindFusion.Scheduling.TimeSpan">Gets or sets the time length of a single cell in a timetable view, accurate to the nearest second.</field>
			/// <field name="dates" type="MindFusion.Scheduling.ObservableCollection">Gets or sets the collection of dates to display in the view.</field>
			/// <field name="endTime" type="Number">Gets or sets the end time of the timetable, expressed in minutes since the beginning of the day.</field>
			/// <field name="groupHours" type="Boolean">Gets or sets a value indicating whether hours displayed in the timeline are grouped.</field>
			/// <field name="headerStyle" type="MindFusion.Scheduling.MainHeaderStyle">Gets or sets the style of the view header.</field>
			/// <field name="maxItems" type="Number">Gets or sets the maximum number of items to display in a cell.</field>
			/// <field name="orientation" type="MindFusion.Scheduling.Orientation">Gets or sets the orientation of the view.</field>
			/// <field name="reverseGrouping" type="Boolean">Gets or sets a value indicating whether grouping (if enabled) will be performed first by the resource, and then by the date.</field>
			/// <field name="scrollStep" type="Number">Gets or sets the number of days to scroll when the user clicks the navigation buttons.</field>
			/// <field name="showAM" type="Boolean">Gets or sets a value indicating whether the AM and PM suffixes are displayed.</field>
			/// <field name="showDayHeader" type="Boolean">Gets or sets a value indicating whether to show the header displaying all-day items.</field>
			/// <field name="showMinutes" type="Boolean">Gets or sets a value indicating whether to display the minutes of each hour in the timeline header when it displays whole hour cells.</field>
			/// <field name="startTime" type="Number">Gets or sets the start time of the timetable, expressed in minutes since the beginning of the day.</field>
			/// <field name="titleFormat" type="String">Gets or sets the string used to format the header title.</field>
			/// <field name="twelveHourFormat" type="Boolean">Gets or sets value indicating whether to use a 12-hour format.</field>
		},
		ViewCell: function () {
			/// <summary>Encapsulates data for a datetime cell in a calendar view.</summary>
			/// <field name="bgCell" type="DOMElement">Gets DOM element of the cell's content.</field>
			/// <field name="endTime" type="MindFusion.Scheduling.DateTime">Gets the end time of the cell.</field>
			/// <field name="index" type="Number">Gets the index of the cell.</field>
			/// <field name="isHeader" type="Boolean">Gets a value indicating whether this cell is a header cell.</field>
			/// <field name="resource" type="MindFusion.Scheduling.Resource">Gets the resource associated with the cell.</field>
			/// <field name="startTime" type="MindFusion.Scheduling.DateTime">Gets the start time of the cell.</field>
			/// <field name="title" type="DOMElement">Gets DOM element of the cell's header.</field>
		},
		WeekRangeSettings: function () {
			/// <summary>Defines properties that allow customization of the appearance of a WeekRange view.</summary>
			/// <field name="dayNamesHeaderStyle" type="MindFusion.Scheduling.HorizontalHeaderStyle">Gets or sets the style of the view day names header.</field>
			/// <field name="dayOfWeekFormat" type="MindFusion.Scheduling.DayOfWeekFormat">Gets or sets the format of the day names displayed in the day names header.</field>
			/// <field name="expandDayHeaders" type="Boolean">Gets or sets a value indicating whether day headers should fill the whole day cell.</field>
			/// <field name="firstDayOfMonthFormat" type="String">Gets or sets the string used to format the cell header of the first day of each month.</field>
			/// <field name="firstDayOfYearFormat" type="String">Gets or sets the string used to format the cell header of the first day of each year.</field>
			/// <field name="generalFormat" type="String">Gets or sets the string used to format cells' headers.</field>
			/// <field name="headerStyle" type="MindFusion.Scheduling.MainHeaderStyle">Gets or sets the style of the view header.</field>
			/// <field name="maxItems" type="Number">Gets or sets the maximum number of items to display in a cell.</field>
			/// <field name="titleFormat" type="String">Gets or sets the string used to format the header title.</field>
			/// <field name="titleSeparator" type="String">Gets or sets the string used as a title separator.</field>
			/// <field name="viewStyle" type="MindFusion.Scheduling.WeekRangeViewStyle">Gets or sets the style of the view.</field>
			/// <field name="visibleRows" type="Number">Gets or sets the number of rows visible at the same time.</field>
		},
		__namespace: true
	},
	UI: {
		CancelEventArgs: function () {
			/// <summary>Provides a value to use with cancellable events.</summary>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation.</field>
		},
		ConfirmDialog: function (title, message, parent) {
			/// <summary>Represents a modal dialog box with OK and Cancel buttons.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
			/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
			/// <param name="parent" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window. Inherited from WindowBase.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame. Inherited from WindowBase.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template. Inherited from WindowBase.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template. Inherited from WindowBase.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window. Inherited from WindowBase.</field>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether this window can be closed. Inherited from Window.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets a value indicating whether this window can be dragged. Inherited from Window.</field>
			/// <field name="allowMaximize" type="Boolean">Gets or sets a value indicating whether this window can be maximized. Inherited from Window.</field>
			/// <field name="allowMinimize" type="Boolean">Gets or sets a value indicating whether this window can be minimized. Inherited from Window.</field>
			/// <field name="allowPin" type="Boolean">Gets or sets a value indicating whether this window can be pinned. Inherited from Window.</field>
			/// <field name="allowRefresh" type="Boolean">Gets or sets a value indicating whether this window can be refreshed. Inherited from Window.</field>
			/// <field name="allowResize" type="Boolean">Gets or sets a value indicating whether this window can be resized. Inherited from Window.</field>
			/// <field name="footer" type="HTMLDivElement">Gets a reference to the window footer DOM element. Inherited from Window.</field>
			/// <field name="header" type="HTMLDivElement">Gets a reference to the window header DOM element. Inherited from Window.</field>
			/// <field name="iconSrc" type="String">Gets or sets the url of the title icon. Inherited from Window.</field>
			/// <field name="minHeight" type="MindFusion.UI.Unit">Gets or sets the minimum allowed height of this window. Inherited from Window.</field>
			/// <field name="minWidth" type="MindFusion.UI.Unit">Gets or sets the minimum allowed width of this window. Inherited from Window.</field>
			/// <field name="modal" type="Boolean">Gets or sets a value indicating whether this window should be modal. Inherited from Window.</field>
			/// <field name="pinned" type="Boolean">Gets or sets a value, indicating whether this window is pinned. Inherited from Window.</field>
			/// <field name="title" type="String">Gets or sets the title of this window. Inherited from Window.</field>
			/// <field name="useFrameTitle" type="Boolean">Gets or sets a value indicating whether the window will display the title of its content iframe. Inherited from Window.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a button in the command strip is clicked. Syntax: buttonClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragEnd" type="EventDispatcher">Raised when drag operation is finished. Syntax: dragEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragStart" type="EventDispatcher">Raised when a drag operation is started. Syntax: dragStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when the window header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeEnd" type="EventDispatcher">Raised when a resize operation is finished. Syntax: resizeEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeStart" type="EventDispatcher">Raised when a resize operation is started. Syntax: resizeStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
		},
		Container: function (element) {
			/// <summary>A base class for UI container controls.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="activeChild" type="MindFusion.UI.WindowBase">Gets the topmost child window.</field>
			/// <field name="children" type="MindFusion.UI.ObservableCollection">Gets the collection of child windows.</field>
			/// <field name="content" type="HTMLDivElement">Gets a reference to the container's content element.</field>
			/// <field name="contentBounds" type="MindFusion.Drawing.Rect">Gets the bounds of this container's content element.</field>
			/// <field name="contentRect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this container's content element.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		Control: function (element) {
			/// <summary>A base class for UI controls.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} );</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} );</field>
		},
		ControlModifiedEventArgs: function (control, changes) {
			/// <summary>Specifies data for notification events, related to control changes.</summary>
			/// <param name="control" type="Control">Control. The control that is being modified</param>
			/// <param name="changes" type="Object">Object. An object containing the changed properties.</param>
			/// <field name="changes" type="Object">Gets the changed properties of the control, associated with the event.</field>
			/// <field name="control" type="MindFusion.UI.Control">Gets the control that is modified.</field>
		},
		ControlModifyingEventArgs: function (control, changes) {
			/// <summary>Specifies data for validation events, related to control changes.</summary>
			/// <param name="control" type="Control">Control. The control that is being modified</param>
			/// <param name="changes" type="Object">Object. An object containing the changed properties.</param>
			/// <field name="changes" type="Object">Gets the changed properties of the control, associated with the event.</field>
			/// <field name="control" type="MindFusion.UI.Control">Gets the control that is being modified.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		Dialog: function (parent) {
			/// <summary>Represents a modal dialog box.</summary>
			/// <param name="parent" type="HTMLElement">HTMLElement. The DOM element to which to append the dialog.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window. Inherited from WindowBase.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame. Inherited from WindowBase.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template. Inherited from WindowBase.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template. Inherited from WindowBase.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window. Inherited from WindowBase.</field>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether this window can be closed. Inherited from Window.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets a value indicating whether this window can be dragged. Inherited from Window.</field>
			/// <field name="allowMaximize" type="Boolean">Gets or sets a value indicating whether this window can be maximized. Inherited from Window.</field>
			/// <field name="allowMinimize" type="Boolean">Gets or sets a value indicating whether this window can be minimized. Inherited from Window.</field>
			/// <field name="allowPin" type="Boolean">Gets or sets a value indicating whether this window can be pinned. Inherited from Window.</field>
			/// <field name="allowRefresh" type="Boolean">Gets or sets a value indicating whether this window can be refreshed. Inherited from Window.</field>
			/// <field name="allowResize" type="Boolean">Gets or sets a value indicating whether this window can be resized. Inherited from Window.</field>
			/// <field name="footer" type="HTMLDivElement">Gets a reference to the window footer DOM element. Inherited from Window.</field>
			/// <field name="header" type="HTMLDivElement">Gets a reference to the window header DOM element. Inherited from Window.</field>
			/// <field name="iconSrc" type="String">Gets or sets the url of the title icon. Inherited from Window.</field>
			/// <field name="minHeight" type="MindFusion.UI.Unit">Gets or sets the minimum allowed height of this window. Inherited from Window.</field>
			/// <field name="minWidth" type="MindFusion.UI.Unit">Gets or sets the minimum allowed width of this window. Inherited from Window.</field>
			/// <field name="modal" type="Boolean">Gets or sets a value indicating whether this window should be modal. Inherited from Window.</field>
			/// <field name="pinned" type="Boolean">Gets or sets a value, indicating whether this window is pinned. Inherited from Window.</field>
			/// <field name="title" type="String">Gets or sets the title of this window. Inherited from Window.</field>
			/// <field name="useFrameTitle" type="Boolean">Gets or sets a value indicating whether the window will display the title of its content iframe. Inherited from Window.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a button in the command strip is clicked. Syntax: buttonClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragEnd" type="EventDispatcher">Raised when drag operation is finished. Syntax: dragEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragStart" type="EventDispatcher">Raised when a drag operation is started. Syntax: dragStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when the window header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeEnd" type="EventDispatcher">Raised when a resize operation is finished. Syntax: resizeEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeStart" type="EventDispatcher">Raised when a resize operation is started. Syntax: resizeStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
		},
		Dialogs: function () {
			/// <summary>Contains static methods for different user dialogs.</summary>
		},
		Dictionary: function () {
			/// <summary>Represents a collection of keys and values.</summary>
			/// <field name="count" type="Number">Gets the number of key/value pairs contained in the dictionary.</field>
			/// <field name="keys" type="MindFusion.UI.List">Gets the list of all keys in the dictionary.</field>
			/// <field name="values" type="MindFusion.UI.List">Gets the list of all values in the dictionary.</field>
		},
		DragDropEventArgs: function (dragItem, dropTarget) {
			/// <summary>Specifies data for drag and drop related events.</summary>
			/// <param name="dragItem" type="ListItem">ListItem. The item, associated with the event.</param>
			/// <param name="dropTarget" type="Object">Object. An object, containing data about the target of the operation.</param>
			/// <field name="dragItem" type="MindFusion.UI.ListItem">Gets the item, associated with the event.</field>
			/// <field name="dropTarget" type="Object">Gets an object, containing data about the target of the operation.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		EmptyEventArgs: function () {
			/// <summary>Provides a value to use with events that do not have event data.</summary>
		},
		EventArgs: function () {
			/// <summary>The base type of classes that define arguments passed to event handler functions.</summary>
		},
		EventDispatcher: function () {
			/// <summary>Represents a dispatcher for an event.</summary>
		},
		IEnumerable: function (items) {
			/// <summary>Represents an array of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
		},
		InfoDialog: function (title, message, parent) {
			/// <summary>Represents a modal dialog box, displaying a custom message.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
			/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
			/// <param name="parent" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window. Inherited from WindowBase.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame. Inherited from WindowBase.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template. Inherited from WindowBase.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template. Inherited from WindowBase.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window. Inherited from WindowBase.</field>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether this window can be closed. Inherited from Window.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets a value indicating whether this window can be dragged. Inherited from Window.</field>
			/// <field name="allowMaximize" type="Boolean">Gets or sets a value indicating whether this window can be maximized. Inherited from Window.</field>
			/// <field name="allowMinimize" type="Boolean">Gets or sets a value indicating whether this window can be minimized. Inherited from Window.</field>
			/// <field name="allowPin" type="Boolean">Gets or sets a value indicating whether this window can be pinned. Inherited from Window.</field>
			/// <field name="allowRefresh" type="Boolean">Gets or sets a value indicating whether this window can be refreshed. Inherited from Window.</field>
			/// <field name="allowResize" type="Boolean">Gets or sets a value indicating whether this window can be resized. Inherited from Window.</field>
			/// <field name="footer" type="HTMLDivElement">Gets a reference to the window footer DOM element. Inherited from Window.</field>
			/// <field name="header" type="HTMLDivElement">Gets a reference to the window header DOM element. Inherited from Window.</field>
			/// <field name="iconSrc" type="String">Gets or sets the url of the title icon. Inherited from Window.</field>
			/// <field name="minHeight" type="MindFusion.UI.Unit">Gets or sets the minimum allowed height of this window. Inherited from Window.</field>
			/// <field name="minWidth" type="MindFusion.UI.Unit">Gets or sets the minimum allowed width of this window. Inherited from Window.</field>
			/// <field name="modal" type="Boolean">Gets or sets a value indicating whether this window should be modal. Inherited from Window.</field>
			/// <field name="pinned" type="Boolean">Gets or sets a value, indicating whether this window is pinned. Inherited from Window.</field>
			/// <field name="title" type="String">Gets or sets the title of this window. Inherited from Window.</field>
			/// <field name="useFrameTitle" type="Boolean">Gets or sets a value indicating whether the window will display the title of its content iframe. Inherited from Window.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a button in the command strip is clicked. Syntax: buttonClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragEnd" type="EventDispatcher">Raised when drag operation is finished. Syntax: dragEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragStart" type="EventDispatcher">Raised when a drag operation is started. Syntax: dragStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when the window header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeEnd" type="EventDispatcher">Raised when a resize operation is finished. Syntax: resizeEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeStart" type="EventDispatcher">Raised when a resize operation is started. Syntax: resizeStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
		},
		InputDialog: function (title, message, parent, input, property) {
			/// <summary>Represents a modal dialog box, displaying a custom input control.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
			/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
			/// <param name="parent" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
			/// <param name="input" type="HTMLElement" optional="true">Optional. HTMLElement. The input control to show in the dialog. If the parameter is not specified, an empty HTML text input will be displayed.</param>
			/// <param name="property" type="String" optional="true">Optional. String. The name of the property of the input control, whose value will be passed as the second argument to the callback function.If the parameter is not specified, the value property will be used.</param>
			/// <field name="input" type="HTMLElement">Gets a reference to the dialog's input element.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window. Inherited from WindowBase.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame. Inherited from WindowBase.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template. Inherited from WindowBase.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template. Inherited from WindowBase.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window. Inherited from WindowBase.</field>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether this window can be closed. Inherited from Window.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets a value indicating whether this window can be dragged. Inherited from Window.</field>
			/// <field name="allowMaximize" type="Boolean">Gets or sets a value indicating whether this window can be maximized. Inherited from Window.</field>
			/// <field name="allowMinimize" type="Boolean">Gets or sets a value indicating whether this window can be minimized. Inherited from Window.</field>
			/// <field name="allowPin" type="Boolean">Gets or sets a value indicating whether this window can be pinned. Inherited from Window.</field>
			/// <field name="allowRefresh" type="Boolean">Gets or sets a value indicating whether this window can be refreshed. Inherited from Window.</field>
			/// <field name="allowResize" type="Boolean">Gets or sets a value indicating whether this window can be resized. Inherited from Window.</field>
			/// <field name="footer" type="HTMLDivElement">Gets a reference to the window footer DOM element. Inherited from Window.</field>
			/// <field name="header" type="HTMLDivElement">Gets a reference to the window header DOM element. Inherited from Window.</field>
			/// <field name="iconSrc" type="String">Gets or sets the url of the title icon. Inherited from Window.</field>
			/// <field name="minHeight" type="MindFusion.UI.Unit">Gets or sets the minimum allowed height of this window. Inherited from Window.</field>
			/// <field name="minWidth" type="MindFusion.UI.Unit">Gets or sets the minimum allowed width of this window. Inherited from Window.</field>
			/// <field name="modal" type="Boolean">Gets or sets a value indicating whether this window should be modal. Inherited from Window.</field>
			/// <field name="pinned" type="Boolean">Gets or sets a value, indicating whether this window is pinned. Inherited from Window.</field>
			/// <field name="title" type="String">Gets or sets the title of this window. Inherited from Window.</field>
			/// <field name="useFrameTitle" type="Boolean">Gets or sets a value indicating whether the window will display the title of its content iframe. Inherited from Window.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a button in the command strip is clicked. Syntax: buttonClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragEnd" type="EventDispatcher">Raised when drag operation is finished. Syntax: dragEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="dragStart" type="EventDispatcher">Raised when a drag operation is started. Syntax: dragStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when the window header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeEnd" type="EventDispatcher">Raised when a resize operation is finished. Syntax: resizeEnd.addEventListener( function(sender, args){} ); Inherited from Window.</field>
			/// <field name="resizeStart" type="EventDispatcher">Raised when a resize operation is started. Syntax: resizeStart.addEventListener( function(sender, args){} ); Inherited from Window.</field>
		},
		InteractionEventArgs: function (rawEventArgs, action) {
			/// <summary>Contains the arguments passed to handlers of interaction-related events.</summary>
			/// <param name="rawEventArgs" type="Object">Object. The Javascript event data.</param>
			/// <param name="action" type="InteractionType">InteractionType. The action associated with the event.</param>
			/// <field name="action" type="MindFusion.UI.InteractionType">Gets the action associated with the event.</field>
			/// <field name="rawEventArgs" type="Object">Gets the Javascript event data.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		ItemEventArgs: function (item, rawEventArgs) {
			/// <summary>Specifies data for the item related events.</summary>
			/// <param name="item" type="ListItem">ListItem. The item, associated with the event.</param>
			/// <param name="rawEventArgs" type="Object">Object. The Javascript event data.</param>
			/// <field name="item" type="MindFusion.UI.ListItem">Gets the item, associated with the event.</field>
			/// <field name="rawEventArgs" type="Object">Gets the Javascript event data.</field>
		},
		List: function (items) {
			/// <summary>Represents an array of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the list.</param>
		},
		ListContainer: function (element) {
			/// <summary>A base class for UI controls, which serve as a container for a list of items.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="acceptDrop" type="MindFusion.UI.ListItem">Gets or sets the ListItem instance that can be dropped.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} );</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} );</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} );</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} );</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} );</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} );</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} );</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} );</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		ListItem: function (title) {
			/// <summary>Represents an item in a list control.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The display text of this item.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this item.</field>
			/// <field name="contentElement" type="HTMLElement">Gets a reference to the item's content element.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of this item.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data.</field>
			/// <field name="dataIndex" type="Number">Gets or sets the unique index of this item.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the item's DOM element.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this item.</field>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this item.</field>
			/// <field name="interactive" type="Boolean">Gets or sets a value indicating whether drag and drop operations are allowed for this item.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this item is loaded and ready for interaction.</field>
			/// <field name="selected" type="Boolean">Gets a value indicating whether the item is selected.</field>
			/// <field name="size" type="MindFusion.UI.Unit">Gets or sets the size of this item.</field>
			/// <field name="title" type="String">Gets or sets the display text of this item.</field>
			/// <field name="tooltip" type="String">Gets or sets the tooltip of this item.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this item.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the template. Inherited from TemplatedItem.</field>
		},
		ListView: function (element) {
			/// <summary>Represents a list view control.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="acceptDrop" type="MindFusion.UI.ListItem">Gets or sets the ListItem instance that can be dropped. Inherited from ListContainer.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		Menu: function (element) {
			/// <summary>Represents a vertical menu.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="closeTimeout" type="Number">Gets or sets the number of milliseconds to wait before closing an item.</field>
			/// <field name="flatItems" type="MindFusion.UI.List">Gets the collection of items as a flat list.</field>
			/// <field name="loadedItems" type="MindFusion.UI.List">Gets the collection of loaded items as a flat list.</field>
			/// <field name="loadOnDemand" type="Boolean">Gets or sets a value indicating whether menu items DOM will be created only after their parent item is expanded.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="acceptDrop" type="MindFusion.UI.ListItem">Gets or sets the ListItem instance that can be dropped. Inherited from ListContainer.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		MenuItem: function (title, href) {
			/// <summary>Represents an item in a menu.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The display text of this item.</param>
			/// <param name="href" type="String" optional="true">Optional. String. The URL this item is pointing to.</param>
			/// <field name="href" type="String">Gets or sets the URL this item is pointing to.</field>
			/// <field name="target" type="String">Gets or sets a value indicating where the linked document is loaded.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the template. Inherited from TemplatedItem.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this item. Inherited from ListItem.</field>
			/// <field name="contentElement" type="HTMLElement">Gets a reference to the item's content element. Inherited from ListItem.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of this item. Inherited from ListItem.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from ListItem.</field>
			/// <field name="dataIndex" type="Number">Gets or sets the unique index of this item. Inherited from ListItem.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the item's DOM element. Inherited from ListItem.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this item. Inherited from ListItem.</field>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this item. Inherited from ListItem.</field>
			/// <field name="interactive" type="Boolean">Gets or sets a value indicating whether drag and drop operations are allowed for this item. Inherited from ListItem.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this item is loaded and ready for interaction. Inherited from ListItem.</field>
			/// <field name="selected" type="Boolean">Gets a value indicating whether the item is selected. Inherited from ListItem.</field>
			/// <field name="size" type="MindFusion.UI.Unit">Gets or sets the size of this item. Inherited from ListItem.</field>
			/// <field name="title" type="String">Gets or sets the display text of this item. Inherited from ListItem.</field>
			/// <field name="tooltip" type="String">Gets or sets the tooltip of this item. Inherited from ListItem.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this item. Inherited from ListItem.</field>
			/// <field name="expandable" type="Boolean">Gets a value indicating whether the node is expandable. Inherited from TreeNode.</field>
			/// <field name="expanded" type="Boolean">Gets or sets a value indicating whether the node is expanded. Inherited from TreeNode.</field>
			/// <field name="flatItems" type="MindFusion.UI.List">Gets the collection of children items as a flat list. Inherited from TreeNode.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the children of the tree node. Inherited from TreeNode.</field>
			/// <field name="level" type="Number">Gets the depth of the tree node in the tree view hierarchy. Inherited from TreeNode.</field>
		},
		NotifyCollectionChangedAction: function () {
			/// <summary>Specifies the type of the collection changed action.</summary>
		},
		NotifyCollectionChangedEventArgs: function (action, changes, index) {
			/// <summary>Provides data for CollectionChanged events.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
			/// <field name="action" type="MindFusion.UI.NotifyCollectionChangedAction">Gets the action that caused the event.</field>
			/// <field name="index" type="Number">Gets the index where the change occurred.</field>
			/// <field name="newItems" type="Array">Gets the list of new items involved in the change.</field>
			/// <field name="oldItems" type="Array">Gets the list of the items affected by a Remove action.</field>
		},
		NotifyCollectionChangingEventArgs: function (action, changes, index) {
			/// <summary>Provides data for CollectionChanging events.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
			/// <field name="action" type="MindFusion.UI.NotifyCollectionChangedAction">Gets the action that caused the event.</field>
			/// <field name="newItems" type="Array">Gets the list of new items involved in the change.</field>
			/// <field name="oldItems" type="Array">Gets the list of the items affected by a Remove action.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		ObservableCollection: function (items) {
			/// <summary>Represents a collection of arbitrary objects.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
			/// <field name="collectionChanged" type="EventDispatcher">Occurs when an item is added, removed, changed, moved, or the entire list is refreshed. Syntax: collectionChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="collectionChanging" type="EventDispatcher">Occurs just before an item is added, removed, changed, moved, or the entire list is refreshed. Syntax: collectionChanging.addEventListener( function(sender, args){} );</field>
		},
		PropertyEventArgs: function (propertyName, oldValue, newValue) {
			/// <summary>Provides data for PropertyValueChanged events.</summary>
			/// <param name="propertyName" type="String">String. The name of the property that changed.</param>
			/// <param name="oldValue" type="Object">Object. The old value of the property.</param>
			/// <param name="newValue" type="Object">Object. The new value of the property.</param>
			/// <field name="newValue" type="Object">Gets the current value of the property.</field>
			/// <field name="oldValue" type="Object">Gets the value of the property before the change.</field>
			/// <field name="propertyName" type="String">Gets the name of the property that changed.</field>
		},
		SelectedItemChangedEventArgs: function (oldItem, newItem) {
			/// <summary>Specifies data for selectedItemChanged events.</summary>
			/// <param name="oldItem" type="ListItem">ListItem. Gets the selected item before the change.</param>
			/// <param name="newItem" type="ListItem">ListItem. Gets the new selected item.</param>
			/// <field name="newItem" type="MindFusion.UI.ListItem">Gets the new selected item.</field>
			/// <field name="oldItem" type="MindFusion.UI.ListItem">Gets the selected item before the change.</field>
		},
		SelectedItemChangingEventArgs: function (oldItem, newItem) {
			/// <summary>Specifies data for selectedItemChanging events.</summary>
			/// <param name="oldItem" type="ListItem">ListItem. The selected item before the change.</param>
			/// <param name="newItem" type="ListItem">ListItem. The new selected item.</param>
			/// <field name="newItem" type="MindFusion.UI.ListItem">Gets the new selected item.</field>
			/// <field name="oldItem" type="MindFusion.UI.ListItem">Gets the selected item before the change.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		TabControl: function (element) {
			/// <summary>Represents a tab pages container.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="selectedIndex" type="Number">Gets the index of the currently selected tab page.</field>
			/// <field name="selectedItem" type="MindFusion.UI.TabPage">Gets or sets the currently selected tab page.</field>
			/// <field name="tabs" type="MindFusion.UI.ObservableCollection">Gets the collection of tab pages.</field>
			/// <field name="tabSize" type="MindFusion.UI.Unit">Gets or sets the size of the tab headers.</field>
			/// <field name="tabStripSize" type="MindFusion.UI.Unit">Gets or sets the size of the tabStrip.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="acceptDrop" type="MindFusion.UI.ListItem">Gets or sets the ListItem instance that can be dropped. Inherited from ListContainer.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="selectedItemChanging" type="EventDispatcher">Raised when the selected tab is changed. Syntax: selectedItemChanging.addEventListener( function(sender, args){} );</field>
			/// <field name="tabHeaderClick" type="EventDispatcher">Raised when a tab header is clicked. Syntax: tabHeaderClick.addEventListener( function(sender, args){} );</field>
			/// <field name="tabHeaderDraw" type="EventDispatcher">Raised when a tab header is drawn. Syntax: tabHeaderDraw.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		TabPage: function (title) {
			/// <summary>Represents a tab page in a TabControl.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The display text of this tab.</param>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether to show a close button in the header of this tab page.</field>
			/// <field name="header" type="MindFusion.UI.ToolStripItem">Gets a reference to the tab page header.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the content IFrame.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a content template.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this item. Inherited from ListItem.</field>
			/// <field name="contentElement" type="HTMLElement">Gets a reference to the item's content element. Inherited from ListItem.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of this item. Inherited from ListItem.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from ListItem.</field>
			/// <field name="dataIndex" type="Number">Gets or sets the unique index of this item. Inherited from ListItem.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the item's DOM element. Inherited from ListItem.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this item. Inherited from ListItem.</field>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this item. Inherited from ListItem.</field>
			/// <field name="interactive" type="Boolean">Gets or sets a value indicating whether drag and drop operations are allowed for this item. Inherited from ListItem.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this item is loaded and ready for interaction. Inherited from ListItem.</field>
			/// <field name="selected" type="Boolean">Gets a value indicating whether the item is selected. Inherited from ListItem.</field>
			/// <field name="size" type="MindFusion.UI.Unit">Gets or sets the size of this item. Inherited from ListItem.</field>
			/// <field name="title" type="String">Gets or sets the display text of this item. Inherited from ListItem.</field>
			/// <field name="tooltip" type="String">Gets or sets the tooltip of this item. Inherited from ListItem.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this item. Inherited from ListItem.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the page's content is loaded. Syntax: contentLoad.addEventListener( function(sender, args){} );</field>
		},
		TabStrip: function (element) {
			/// <summary>Provides a container for tab headers.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="acceptDrop" type="MindFusion.UI.ListItem">Gets or sets the ListItem instance that can be dropped. Inherited from ListContainer.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="collapsible" type="Boolean">Gets or sets a value indicating whether the toolstrip can be collapsed. Inherited from ToolStrip.</field>
			/// <field name="expanded" type="Boolean">Gets a value indicating whether the toolstrip is currently expanded. Inherited from ToolStrip.</field>
			/// <field name="scrollable" type="Boolean">Gets or sets a value indicating whether the toolstrip displays scroll arrows when there is not enough room to display all items. Inherited from ToolStrip.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		TemplatedItem: function () {
			/// <summary>Represents an item which can be templated.</summary>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the template.</field>
		},
		ToolStrip: function (element) {
			/// <summary>Represents a container of toolbar buttons.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="acceptDrop" type="MindFusion.UI.ToolStripItem">Gets or sets the ToolStripItem instance that can be dropped.</field>
			/// <field name="collapsible" type="Boolean">Gets or sets a value indicating whether the toolstrip can be collapsed.</field>
			/// <field name="expanded" type="Boolean">Gets a value indicating whether the toolstrip is currently expanded.</field>
			/// <field name="scrollable" type="Boolean">Gets or sets a value indicating whether the toolstrip displays scroll arrows when there is not enough room to display all items.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		ToolStripItem: function (type, title) {
			/// <summary>Represents an item in a ToolStrip control.</summary>
			/// <param name="type" type="ToolStripItemType" optional="true">Optional. ToolStripItemType. The type of this item.</param>
			/// <param name="title" type="String" optional="true">Optional. String. The display text of this item.</param>
			/// <field name="type" type="MindFusion.UI.ToolStripItemType">Gets the type of this item.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the template. Inherited from TemplatedItem.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this item. Inherited from ListItem.</field>
			/// <field name="contentElement" type="HTMLElement">Gets a reference to the item's content element. Inherited from ListItem.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of this item. Inherited from ListItem.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from ListItem.</field>
			/// <field name="dataIndex" type="Number">Gets or sets the unique index of this item. Inherited from ListItem.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the item's DOM element. Inherited from ListItem.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this item. Inherited from ListItem.</field>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this item. Inherited from ListItem.</field>
			/// <field name="interactive" type="Boolean">Gets or sets a value indicating whether drag and drop operations are allowed for this item. Inherited from ListItem.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this item is loaded and ready for interaction. Inherited from ListItem.</field>
			/// <field name="selected" type="Boolean">Gets a value indicating whether the item is selected. Inherited from ListItem.</field>
			/// <field name="size" type="MindFusion.UI.Unit">Gets or sets the size of this item. Inherited from ListItem.</field>
			/// <field name="title" type="String">Gets or sets the display text of this item. Inherited from ListItem.</field>
			/// <field name="tooltip" type="String">Gets or sets the tooltip of this item. Inherited from ListItem.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this item. Inherited from ListItem.</field>
		},
		Tooltip: function (target, title) {
			/// <summary>Represents a popup window, containing a custom message.</summary>
			/// <param name="target" type="HTMLElement">HTMLElement. The HTML element that will trigger the tooltip.</param>
			/// <param name="title" type="String" optional="true">Optional. String. The display text of the tooltip.</param>
			/// <field name="follow" type="Boolean">Gets or sets a value indicating whether the tooltip will follow the mouse cursor.</field>
			/// <field name="offset" type="MindFusion.Drawing.Point">Gets or sets the offset of the tooltip.</field>
			/// <field name="position" type="MindFusion.UI.TooltipPosition">Gets or sets the position of the tooltip.</field>
			/// <field name="target" type="HTMLElement">Gets a reference to the tooltip's target element.</field>
			/// <field name="template" type="String">Gets or sets the tooltip content template.</field>
			/// <field name="text" type="String">Gets or sets the text of the tooltip.</field>
			/// <field name="trigger" type="MindFusion.UI.TooltipTrigger">Gets or sets the event, which shows the tooltip.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="tooltipHide" type="EventDispatcher">Raised when the tooltip is hidden. Syntax: tooltipHide.addEventListener( function(sender, args){} );</field>
			/// <field name="tooltipHiding" type="EventDispatcher">Raised when the tooltip is hiding. Syntax: tooltipHiding.addEventListener( function(sender, args){} );</field>
			/// <field name="tooltipShow" type="EventDispatcher">Raised when the tooltip is shown. Syntax: tooltipShow.addEventListener( function(sender, args){} );</field>
			/// <field name="tooltipShowing" type="EventDispatcher">Raised when the tooltip is showing. Syntax: tooltipShowing.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		TreeNode: function (title) {
			/// <summary>Represents an expandable list item.</summary>
			/// <param name="title" type="String" optional="true">Optional. String. The title of the new TreeNode.</param>
			/// <field name="expandable" type="Boolean">Gets a value indicating whether the node is expandable.</field>
			/// <field name="expanded" type="Boolean">Gets or sets a value indicating whether the node is expanded.</field>
			/// <field name="flatItems" type="MindFusion.UI.List">Gets the collection of children items as a flat list.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the children of the tree node.</field>
			/// <field name="level" type="Number">Gets the depth of the tree node in the tree view hierarchy.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the template. Inherited from TemplatedItem.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this item. Inherited from ListItem.</field>
			/// <field name="contentElement" type="HTMLElement">Gets a reference to the item's content element. Inherited from ListItem.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of this item. Inherited from ListItem.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from ListItem.</field>
			/// <field name="dataIndex" type="Number">Gets or sets the unique index of this item. Inherited from ListItem.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the item's DOM element. Inherited from ListItem.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this item. Inherited from ListItem.</field>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this item. Inherited from ListItem.</field>
			/// <field name="interactive" type="Boolean">Gets or sets a value indicating whether drag and drop operations are allowed for this item. Inherited from ListItem.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this item is loaded and ready for interaction. Inherited from ListItem.</field>
			/// <field name="selected" type="Boolean">Gets a value indicating whether the item is selected. Inherited from ListItem.</field>
			/// <field name="size" type="MindFusion.UI.Unit">Gets or sets the size of this item. Inherited from ListItem.</field>
			/// <field name="title" type="String">Gets or sets the display text of this item. Inherited from ListItem.</field>
			/// <field name="tooltip" type="String">Gets or sets the tooltip of this item. Inherited from ListItem.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this item. Inherited from ListItem.</field>
		},
		TreeView: function (element) {
			/// <summary>Represents a tree view control.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="acceptDrop" type="MindFusion.UI.TreeNode">Gets or sets the TreeNode instance that can be dropped.</field>
			/// <field name="flatItems" type="MindFusion.UI.List">Gets the collection of items as a flat list.</field>
			/// <field name="loadedItems" type="MindFusion.UI.List">Gets the collection of loaded items as a flat list.</field>
			/// <field name="loadOnDemand" type="Boolean">Gets or sets a value indicating whether tree nodes DOM will be created only after their parent node is expanded.</field>
			/// <field name="toggleMode" type="MindFusion.UI.ToggleMode">Gets or sets a value indicating how nodes expand/collapse will be triggered.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets whether drag and drop capabilities are enabled. Inherited from ListContainer.</field>
			/// <field name="allowDrop" type="Boolean">Gets or sets whether the control can be used as a drop target. Inherited from ListContainer.</field>
			/// <field name="allowMultipleSelection" type="Boolean">Gets or sets whether users are allowed to select more than one item at a time. Inherited from ListContainer.</field>
			/// <field name="content" type="HTMLElement">Gets a reference to the container's content element. Inherited from ListContainer.</field>
			/// <field name="items" type="MindFusion.UI.ObservableCollection">Gets the collection of list items. Inherited from ListContainer.</field>
			/// <field name="itemSize" type="MindFusion.UI.Unit">Gets or sets the size of the list items. Inherited from ListContainer.</field>
			/// <field name="orientation" type="MindFusion.UI.Orientation">Gets or sets a value indicating how list items are arranged. Inherited from ListContainer.</field>
			/// <field name="selection" type="MindFusion.UI.ObservableCollection">Gets the collection of selected items. Inherited from ListContainer.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="dragDrop" type="EventDispatcher">Raised when an item is dropped onto the control. Syntax: dragDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="dragOver" type="EventDispatcher">Raised when an item is dragged over the control. Syntax: dragOver.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemClick" type="EventDispatcher">Raised when an item is clicked. Syntax: itemClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDoubleClick" type="EventDispatcher">Raised when an item is double-clicked. Syntax: itemDoubleClick.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrag" type="EventDispatcher">Raised when an item is dragged. Syntax: itemDrag.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragEnd" type="EventDispatcher">Raised when a drag operation on an item is finished. Syntax: itemDragEnd.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDragStart" type="EventDispatcher">Raised when a drag operation on an item is started. Syntax: itemDragStart.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDraw" type="EventDispatcher">Raised when an item is being drawn. Syntax: itemDraw.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemDrop" type="EventDispatcher">Raised when a drop operation is finished. Syntax: itemDrop.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseDown" type="EventDispatcher">Raised when a mousedown event occurs in an item's element. Syntax: itemMouseDown.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseEnter" type="EventDispatcher">Raised when a mouseenter event occurs in an item's element. Syntax: itemMouseEnter.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemMouseLeave" type="EventDispatcher">Raised when a mouseleave event occurs in an item's element. Syntax: itemMouseLeave.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanged" type="EventDispatcher">Raised when the items collection is changed. Syntax: itemsChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="itemsChanging" type="EventDispatcher">Raised when the items collection is changing. Syntax: itemsChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanged" type="EventDispatcher">Raised when the selection collection is changed. Syntax: selectionChanged.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
			/// <field name="selectionChanging" type="EventDispatcher">Raised when the selection collection is changing. Syntax: selectionChanging.addEventListener( function(sender, args){} ); Inherited from ListContainer.</field>
		},
		Unit: function (value, type) {
			/// <summary>Represents a length measurement.</summary>
			/// <param name="value" type="Number" optional="true">Optional. Number. The value of the unit.</param>
			/// <param name="type" type="UnitType" optional="true">Optional. UnitType. The type of the unit.</param>
			/// <field name="isEmpty" type="Boolean">Gets a value representing whether this Unit instance has a set value.</field>
			/// <field name="type" type="MindFusion.UI.UnitType">The unit type.</field>
			/// <field name="value" type="Number">The unit value.</field>
		},
		Window: function (element) {
			/// <summary>Represents a window with title and contents, which can be moved, resized and arranged interactively.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="allowClose" type="Boolean">Gets or sets a value indicating whether this window can be closed.</field>
			/// <field name="allowDrag" type="Boolean">Gets or sets a value indicating whether this window can be dragged.</field>
			/// <field name="allowMaximize" type="Boolean">Gets or sets a value indicating whether this window can be maximized.</field>
			/// <field name="allowMinimize" type="Boolean">Gets or sets a value indicating whether this window can be minimized.</field>
			/// <field name="allowPin" type="Boolean">Gets or sets a value indicating whether this window can be pinned.</field>
			/// <field name="allowRefresh" type="Boolean">Gets or sets a value indicating whether this window can be refreshed.</field>
			/// <field name="allowResize" type="Boolean">Gets or sets a value indicating whether this window can be resized.</field>
			/// <field name="footer" type="HTMLDivElement">Gets a reference to the window footer DOM element.</field>
			/// <field name="header" type="HTMLDivElement">Gets a reference to the window header DOM element.</field>
			/// <field name="iconSrc" type="String">Gets or sets the url of the title icon.</field>
			/// <field name="minHeight" type="MindFusion.UI.Unit">Gets or sets the minimum allowed height of this window.</field>
			/// <field name="minWidth" type="MindFusion.UI.Unit">Gets or sets the minimum allowed width of this window.</field>
			/// <field name="modal" type="Boolean">Gets or sets a value indicating whether this window should be modal.</field>
			/// <field name="pinned" type="Boolean">Gets or sets a value, indicating whether this window is pinned.</field>
			/// <field name="title" type="String">Gets or sets the title of this window.</field>
			/// <field name="useFrameTitle" type="Boolean">Gets or sets a value indicating whether the window will display the title of its content iframe.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window. Inherited from WindowBase.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame. Inherited from WindowBase.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template. Inherited from WindowBase.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template. Inherited from WindowBase.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window. Inherited from WindowBase.</field>
			/// <field name="buttonClick" type="EventDispatcher">Raised when a button in the command strip is clicked. Syntax: buttonClick.addEventListener( function(sender, args){} );</field>
			/// <field name="dragEnd" type="EventDispatcher">Raised when drag operation is finished. Syntax: dragEnd.addEventListener( function(sender, args){} );</field>
			/// <field name="dragStart" type="EventDispatcher">Raised when a drag operation is started. Syntax: dragStart.addEventListener( function(sender, args){} );</field>
			/// <field name="headerClick" type="EventDispatcher">Raised when the window header is clicked. Syntax: headerClick.addEventListener( function(sender, args){} );</field>
			/// <field name="resizeEnd" type="EventDispatcher">Raised when a resize operation is finished. Syntax: resizeEnd.addEventListener( function(sender, args){} );</field>
			/// <field name="resizeStart" type="EventDispatcher">Raised when a resize operation is started. Syntax: resizeStart.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} ); Inherited from WindowBase.</field>
		},
		WindowBase: function (element) {
			/// <summary>Represents a window, which can be either templated or rendered as an IFrame.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="host" type="MindFusion.UI.Container">Gets the host of this window.</field>
			/// <field name="navigateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded in the control's content IFrame.</field>
			/// <field name="template" type="String">Gets or sets an HTML string, representing the content template.</field>
			/// <field name="templateUrl" type="String">Gets or sets a string, specifying the URL of the web page, that will be loaded as a control content template.</field>
			/// <field name="windowState" type="MindFusion.UI.WindowState">Gets or sets the state of this window.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="contentLoad" type="EventDispatcher">Raised when the windows's contents are loaded. Syntax: contentLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="stateChanged" type="EventDispatcher">Raised when the window's state is changed. Syntax: stateChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="stateChanging" type="EventDispatcher">Raised when the window's state is changing. Syntax: stateChanging.addEventListener( function(sender, args){} );</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when the window is closed. Syntax: windowClose.addEventListener( function(sender, args){} );</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when the window is closing. Syntax: windowClosing.addEventListener( function(sender, args){} );</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when the window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} );</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when the window is opening. Syntax: windowOpening.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		WindowHost: function (element) {
			/// <summary>Represents a container for Window objects.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="commandStrip" type="MindFusion.UI.ToolStrip">Gets a reference to the default commands toolStrip.</field>
			/// <field name="maximizedStrip" type="MindFusion.UI.ToolStrip">Gets a reference to the maximized windows toolStrip.</field>
			/// <field name="minimizedStrip" type="MindFusion.UI.ToolStrip">Gets a reference to the minimized windows toolStrip.</field>
			/// <field name="windows" type="MindFusion.UI.ObservableCollection">Gets the collection of child windows.</field>
			/// <field name="bounds" type="MindFusion.Drawing.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.UI.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.UI.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.UI.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.UI.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="activeChild" type="MindFusion.UI.WindowBase">Gets the topmost child window. Inherited from Container.</field>
			/// <field name="children" type="MindFusion.UI.ObservableCollection">Gets the collection of child windows. Inherited from Container.</field>
			/// <field name="content" type="HTMLDivElement">Gets a reference to the container's content element. Inherited from Container.</field>
			/// <field name="contentBounds" type="MindFusion.Drawing.Rect">Gets the bounds of this container's content element. Inherited from Container.</field>
			/// <field name="contentRect" type="MindFusion.Drawing.Rect">Gets the bounding rect of this container's content element. Inherited from Container.</field>
			/// <field name="windowClose" type="EventDispatcher">Raised when a child window is closed. Syntax: windowClose.addEventListener( function(sender, args){} );</field>
			/// <field name="windowClosing" type="EventDispatcher">Raised when a child window is being closed. Syntax: windowClosing.addEventListener( function(sender, args){} );</field>
			/// <field name="windowOpen" type="EventDispatcher">Raised when a child window is opened. Syntax: windowOpen.addEventListener( function(sender, args){} );</field>
			/// <field name="windowOpening" type="EventDispatcher">Raised when a child window is being opened. Syntax: windowOpening.addEventListener( function(sender, args){} );</field>
			/// <field name="windowStateChanged" type="EventDispatcher">Raised when the state of a child window is modified. Syntax: windowStateChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="windowStateChanging" type="EventDispatcher">Raised when the state of a child window is being modified. Syntax: windowStateChanging.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		__namespace: true
	},
	Diagramming: {
		Lanes: {
			Cell: function () {
				/// <summary>Represents a single cell in a lane grid.</summary>
			},
			Grid: function () {
				/// <summary>Represents a lane grid.</summary>
			},
			Header: function () {
				/// <summary>Represents a header in a lane grid.</summary>
			},
			Style: function () {
				/// <summary>Encapsulates the appearance properties of an element in a lane grid.</summary>
			},
			__namespace: true
		},
		AddItemCommand: function (diagram, item) {
			/// <summary>Implements creation of new diagram items.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="item" type="MindFusion.Diagramming.DiagramItem">A new DiagramItem that should be added to the Diagram.</param>
		},
		AeroEffect: function () {
			/// <summary>that adds semitransparency to the node and emphasizes its outline by adding a shade and an inner stroke.</summary>
		},
		AnchorPattern: function (points, id) {
			/// <summary>The AnchorPattern class represents a set of anchor points, which specify the exact locations where links are allowed to connect to nodes.</summary>
			/// <param name="points" type="Array">Contains the initial set of AnchorPoint instances for the new pattern.</param>
			/// <param name="id" type="String" optional="true">Optional. An unique identifier for this anchor pattern.</param>
		},
		AnchorPoint: function (x, y, allowIncoming, allowOutgoing, style, color, size) {
			/// <summary>The AnchorPoint class represents a location in a node, to which links are allowed to connect.</summary>
			/// <param name="x" type="Number">The horizontal position of the anchor expressed as percent of the width of a node.</param>
			/// <param name="y" type="Number">The vertical position of the anchor expressed as percent of the height of a node.</param>
			/// <param name="allowIncoming" type="Boolean" optional="true">Optional. Specifies whether incoming links can connect to this anchor.</param>
			/// <param name="allowOutgoing" type="Boolean" optional="true">Optional. Specifies whether outgoing links can connect to this anchor.</param>
			/// <param name="style" type="MindFusion.Diagramming.MarkStyle" optional="true">Optional. Defines how the anchor point is marked visually.</param>
			/// <param name="color" type="String" optional="true">Optional. Defines the color with which the anchor mark is painted.</param>
			/// <param name="size" type="Number" optional="true">Optional. Defines the size of the anchor mark.</param>
		},
		BehaviorBase: function (parent) {
			/// <summary>An abstract base class for types that define how the control reacts to users' actions with a mouse or other pointing devices.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		Border: function () {
			/// <summary>Represents a panel that draws a border around its child components.</summary>
			/// <field name="brush" type="void">The panel background color.</field>
			/// <field name="pen" type="void">The border color.</field>
			/// <field name="strokeThickness" type="void">The border thickness.</field>
		},
		Cell: function () {
			/// <summary>Represents a cell of a TableNode.</summary>
			/// <field name="getImage" type="void">Gets the image displayed inside this cell.</field>
			/// <field name="getImageAlign" type="void">Gets the alignment for the image of this cell.</field>
			/// <field name="getImageContent" type="void">Gets the Base64-encoded data of the image displayed inside this cell.</field>
			/// <field name="getImageLocation" type="void">Gets the URL of the image displayed inside this cell.</field>
			/// <field name="getImagePadding" type="void">Gets the padding distance between cell borders and image.</field>
			/// <field name="getLineAlignment" type="void">Gets how the text should be vertically aligned inside the cell's bounding rectangle.</field>
			/// <field name="getText" type="void">Gets the string containing the cell's text.</field>
			/// <field name="getTextAlignment" type="void">Gets how the text should be aligned inside the cell's bounding rectangle.</field>
			/// <field name="setImage" type="void">Sets the image displayed inside this cell.</field>
			/// <field name="setImageAlign" type="void">Sets the alignment for the image of this cell.</field>
			/// <field name="setImageContent" type="void">Sets the Base64-encoded data of the image displayed inside this cell.</field>
			/// <field name="setImageLocation" type="void">Sets the URL of the image displayed inside this cell.</field>
			/// <field name="setImagePadding" type="void">Sets the padding distance between cell borders and image.</field>
			/// <field name="setLineAlignment" type="void">Sets how the text should be vertically aligned inside the cell's bounding rectangle.</field>
			/// <field name="setText" type="void">Sets a string containing the cell's text.</field>
			/// <field name="setTextAlignment" type="void">Sets how the text should be aligned inside the cell's bounding rectangle.</field>
		},
		CellEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of table cell -related events.</summary>
		},
		CellValidationEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of table row and column resizing related events.</summary>
		},
		ChangeItemCommand: function (diagram, item) {
			/// <summary>Handles undo / redo of property changes.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem that will be modified.</param>
		},
		Command: function (diagram) {
			/// <summary>Represents an action that changes the diagram and whose effects can be undone.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
		},
		ComponentEventArgs: function (args) {
			/// <summary>Contains the arguments passed to handlers of component-related events.</summary>
			/// <param name="args" type="Object"></param>
		},
		CompositeCommand: function (diagram) {
			/// <summary>Represents a set of Command instances as a single operation. Undoing or redoing the composite action, respectively undoes or redoes all its constituent subactions at the same time.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
		},
		CompositeNode: function (parent) {
			/// <summary>CompositeNode implements nodes whose appearance can be defined via composition of components and layout containers.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the node properties.</param>
		},
		ConnectionPoint: function () {
			/// <summary>A class that represents a connection between an edge and a node in a graph.</summary>
		},
		ContainerNode: function (parent) {
			/// <summary>ContainerNode instances are diagram nodes that can contain other nodes.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the node properties.</param>
		},
		CreateLinkController: function (diagram, link) {
			/// <summary>A controller used to draw new links in the diagram.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The parent diagram of the new link.</param>
			/// <param name="link" type="MindFusion.Diagramming.DiagramLink">The link that will be drawn by this controller.</param>
		},
		CreateNodeController: function (diagram, node) {
			/// <summary>A controller used to draw new nodes in the diagram.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The parent diagram of the new node.</param>
			/// <param name="node" type="MindFusion.Diagramming.DiagramNode">The node that will be drawn by this controller.</param>
		},
		CreateSelectionController: function (selection) {
			/// <summary>A controller used to draw selection rectangle in the diagram.</summary>
			/// <param name="selection" type="MindFusion.Diagramming.Selection">The selection that will be drawn by this controller.</param>
		},
		Diagram: function (element) {
			/// <summary>The Diagram class represents a flow diagram.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this Diagram is associated with.</param>
		},
		DiagramEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of global diagram events such as clicked.</summary>
		},
		DiagramItem: function (parent) {
			/// <summary>Represents an item in the diagram document. All classes representing diagram elements derive from DiagramItem.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the item properties.</param>
		},
		DiagramLink: function (parent, origin, destination) {
			/// <summary>Represents a link between two diagram nodes.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the link properties.</param>
			/// <param name="origin" type="MindFusion.Diagramming.DiagramNode" optional="true">Optional. The origin node of the new link.</param>
			/// <param name="destination" type="MindFusion.Diagramming.DiagramNode" optional="true">Optional. The destination node of the new link.</param>
		},
		DiagramNode: function (parent) {
			/// <summary>DiagramNode is an abstract base class from which the ShapeNode, TableNode and ControlNode classes derive. DiagramNode instances can represent graph vertices, nodes in organizational or flow diagrams, entities in ER diagrams, and so on.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. A Diagram instance whose default node attributes are copied to this node.</param>
		},
		DoNothingBehavior: function (parent) {
			/// <summary>Implements the DoNothing behavior.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		DrawLinksBehavior: function (parent) {
			/// <summary>This class is used when the diagram behavior is set to Behavior.DrawLinks.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		DrawNodesBehavior: function (parent) {
			/// <summary>The base class for behavior types that allow drawing of nodes, but not links.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		DummyNode: function (parent) {
			/// <summary>DummyNode represents virtual nodes set as targets of disconnected links.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. A Diagram instance whose default node attributes are copied to this node.</param>
		},
		Events: function () {
			/// <summary>Defines all events raised by the Diagram component.</summary>
		},
		Factory: function () {
			/// <summary>Provides shortcut methods for creating and adding instances of the standard item types. Obtain an instance of this class through the getFactory method of the Diagram class.</summary>
		},
		FoldContainerCommand: function (diagram, container) {
			/// <summary>Handles undo / redo of container folding.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="container" type="MindFusion.Diagramming.ContainerNode">The ContainerNode instance that will be modified.</param>
		},
		FreeFormNode: function (parent) {
			/// <summary>A FreeFormNode collects all points from users' mouse or touch input and displaysthem as node's outline. To let users draw free-form nodes interactively, setBehavior to DrawFreeForms or LinkFreeForms. Use the Points property of FreeFormNodeto get or set outline points programmatically. If the Closed property is set,the node is drawn as a closed shape and its interior filled, or otherwise the nodeis drawn as a polyline. If the distance between first and last points drawn byuser is shorter than AutoCloseDistance, the node's Closed property is automaticallyset to true. AutoCloseDistance default value is Double.MaxValue, so free-form nodesare always closed.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. A Diagram instance whose default node attributes are copied to this node.</param>
		},
		GlassEffect: function () {
			/// <summary>Represents a glass-like visual effect.</summary>
		},
		GridColumn: function () {
			/// <summary>Represents a column in a GridPanel.</summary>
		},
		GridPanel: function () {
			/// <summary>A layout container that arranges its child components in a grid.</summary>
		},
		GridRouter: function (diagram) {
			/// <summary>Implements a link routing algorithm that uses a grid to represent the free and occupied regions in the diagram.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram" optional="true">Optional. Gets or sets the diagram this router is associated with.</param>
		},
		GridRow: function () {
			/// <summary>Represents a row in a GridPanel.</summary>
		},
		HeaderEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of header-related events.</summary>
		},
		HeaderResizeEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of header resize events.</summary>
		},
		InplaceEditEventArgs: function () {
			/// <summary>Contains the arguments passed to handlers of inplace edit related events.</summary>
		},
		LinkEventArgs: function (args) {
			/// <summary>Contains the arguments passed to handlers of link-related events.</summary>
			/// <param name="args" type="Object"></param>
		},
		LinkLabel: function (link, text) {
			/// <summary>Represents a label displayed by a DiagramLink. New labels can be added to a link by calling its addLabel method.</summary>
			/// <param name="link" type="MindFusion.Diagramming.DiagramLink">The DiagramLink that displays the label.</param>
			/// <param name="text" type="String">The label's text.</param>
		},
		LinkNodesBehavior: function (parent) {
			/// <summary>The base class for behavior types that allow drawing both nodes and links.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		links: function () {
			/// <summary>A collection of all DiagramLink elements participating in the path.</summary>
		},
		MagnifyBehavior: function (parent) {
			/// <summary>This class is used when the diagram behavior is set to Behavior.Magnify.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		Manipulator: function (node) {
			/// <summary>Manipulator is an abstract base class which defines the behavior of miscellaneous UI widgets attached to nodes.</summary>
			/// <param name="node" type="MindFusion.Diagramming.DiagramNode" optional="true">Optional. The DiagramNode containing this manipulator.</param>
		},
		ModifierKeyActions: function () {
			/// <summary>Maps keyboard modifier keys to special actions in MindFusion.Diagramming such as panning and drawing selection rectangle.</summary>
		},
		ModifyBehavior: function (parent) {
			/// <summary>This class is used when the diagram behavior is set to Behavior.Modify.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		ModifyLinkController: function (link, adjustmentHandle) {
			/// <summary>A controller used to modify existing links in the diagram.</summary>
			/// <param name="link" type="MindFusion.Diagramming.DiagramLink">The link that will be modified by this controller.</param>
			/// <param name="adjustmentHandle" type="Object">An object representing the adjustment handle used to modify the link.</param>
		},
		ModifyNodeController: function (node, adjustmentHandle) {
			/// <summary>A controller used to modify existing nodes in the diagram.</summary>
			/// <param name="node" type="MindFusion.Diagramming.DiagramNode">The node that will be modified by this controller.</param>
			/// <param name="adjustmentHandle" type="Object">An object representing the adjustment handle used to modify the node.</param>
		},
		ModifySelectionController: function (selection, adjustmentHandle) {
			/// <summary>A controller used to modify multiple selected items in the diagram.</summary>
			/// <param name="selection" type="MindFusion.Diagramming.Selection">The selection that will be modified by this controller.</param>
			/// <param name="adjustmentHandle" type="Object">An object representing the adjustment handle used to modify the selection.</param>
		},
		MouseInputDispatcher: function (diagram) {
			/// <summary>Processes mouse events and dispatches them to controller objects appropriate for current context.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram instance that should receive mouse input.</param>
		},
		NodeEventArgs: function (args) {
			/// <summary>Contains the arguments passed to handlers of node-related events.</summary>
			/// <param name="args" type="Object"></param>
		},
		NodeListView: function (element) {
			/// <summary>ListBox control with support for hosting DiagramNodes and dragging them to the Diagram control. Items' labels can be set by assigning them to the Tag property of nodes.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this NodeListView is associated with.</param>
		},
		Overview: function (element) {
			/// <summary>The Overview control provides a scaled-down view of a Diagram contents and allows scrolling and zooming the diagram with the mouse.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this Overview is associated with.</param>
		},
		PanBehavior: function (parent) {
			/// <summary>Pans the diagram when the users drags the mouse.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		PanController: function (diagram) {
			/// <summary>A controller used to pan the diagram view.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The diagram that will get scrolled by this controller.</param>
		},
		Panel: function () {
			/// <summary>Represents layout containers in CompositeNode visual tree.</summary>
		},
		Path: function () {
			/// <summary>Represents a sequence of connected DiagramNode and DiagramLink elements.</summary>
		},
		PathFinder: function (diagram) {
			/// <summary>Provides methods that help you find paths and cycles in a graph.</summary>
			/// <param name="diagram" type="Diagram">An instance of the Diagram class in which to look for paths or cycles.</param>
		},
		RemoveItemCommand: function (diagram, item) {
			/// <summary>Implements deletion of diagram items.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="item" type="MindFusion.Diagramming.DiagramItem">A DiagramItem that should be removed from the Diagram.</param>
		},
		ResizeTableColumnCommand: function (diagram, table, column) {
			/// <summary>Implements resizing of table's columns.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="table" type="MindFusion.Diagramming.TableNode">The TableNode instance that will be modified.</param>
			/// <param name="column" type="Object">The column object that will be resized.</param>
		},
		ResizeTableRowCommand: function (diagram, table, row) {
			/// <summary>Implements resizing of table's rows.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="table" type="MindFusion.Diagramming.TableNode">The TableNode instance that will be modified.</param>
			/// <param name="row" type="Object">The row object that will be resized.</param>
		},
		Router: function (diagram) {
			/// <summary>Implements a simple link routing algorithm that pulls link segments out of nodes they would overlap.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The diagram this router is associated with.</param>
		},
		Ruler: function (element) {
			/// <summary>The Ruler control provides horizontal and vertical scales that help users measure and align diagram items.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this Ruler is associated with.</param>
		},
		ScrollTableCommand: function (diagram, table) {
			/// <summary>Handles undo / redo of table scrolling.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram modified by this command.</param>
			/// <param name="table" type="MindFusion.Diagramming.TableNode">The TableNode instance that will be modified.</param>
		},
		Selection: function (parent) {
			/// <summary>Represents a set of items selected in the diagram document.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The diagram where the items are selected.</param>
		},
		SelectionEventArgs: function (args) {
			/// <summary>Contains the arguments passed to handlers of selection-related events.</summary>
			/// <param name="args" type="Object"></param>
		},
		SelectOnlyBehavior: function (parent) {
			/// <summary>Allows only selection of existing items. Modifying them or drawing new ones is disabled.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram">The Diagram this behavior will be associated with.</param>
		},
		SerializeTagEventArgs: function () {
			/// <summary>Contains the arguments passed to the serializeTag and deserializeTag event handlers.</summary>
		},
		Shape: function (params) {
			/// <summary>An instance of this class represents a shape defined through a series of arc, line and Bezier segments. The segments can be a part of the shape outline, in which case they define the part of the shape is filled, used for hit-testing and for aligning links to the node edges. Segments can also be added as decoration elements, in which case they only affect the appearance of a ShapeNode.</summary>
			/// <param name="params.outline" type="String" optional="true">Optional. A string defining the shape's outline.</param>
			/// <param name="params.decoration" type="String" optional="true">Optional. A string defining the shape's decoration.</param>
			/// <param name="params.shapeDecorations" type="Array" optional="true">Optional. An array containing shapeDecoration objects defining additional shape decoration.</param>
			/// <param name="params.id" type="String" optional="true">Optional. The string identifier of the shape.</param>
			/// <param name="params.fillMode" type="String" optional="true">Optional. A string specifying the fill mode;</param>
			/// <param name="params.outlinePen" type="String" optional="true">Optional. A string specifying the stroke of the shape's outline.</param>
			/// <param name="params.outlineBrush" type="String" optional="true">Optional. A string specifying the fill of the shape's outline.</param>
			/// <param name="params.decorationPen" type="String" optional="true">Optional. A string specifying the stroke of the shape's decoration.</param>
			/// <param name="params.decorationBrush" type="String" optional="true">Optional. A string specifying the fill of the shape's decoration.</param>
		},
		ShapeLibrary: function (shapes) {
			/// <summary>The ShapeLibrary class represents a collection of shape definitions stored together.</summary>
			/// <param name="shapes" type="Array">A list of MindFusion.Diagramming.Shape objects to initialize the library with.</param>
		},
		ShapeNode: function (parent) {
			/// <summary>ShapeNode instances are diagram nodes that represent geometric shapes.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the node properties.</param>
		},
		Shapes: function () {
			/// <summary>Provides alternative methods of access to the predefined shapes.</summary>
		},
		SimplePanel: function () {
			/// <summary>A layout container that arranges its child components on top of each other.</summary>
		},
		SinglePointerController: function (modifiedItem, adjustmentHandle) {
			/// <summary>Processes mouse or single-touch events targeting a diagram element.</summary>
			/// <param name="modifiedItem" type="MindFusion.Diagramming.DiagramItem">The item that will be modified by this controller.</param>
			/// <param name="adjustmentHandle" type="Object">An object representing the adjustment handle used to modify the item.</param>
		},
		StackPanel: function () {
			/// <summary>A layout container that arranges its child components stacked horizontally or vertically.</summary>
		},
		strokeThickness: function () {
			/// <summary>The border thickness.</summary>
		},
		Style: function (prototype) {
			/// <summary>Represents a set of appearance properties whose values can be inherited from parent objects if not set locally for an item.</summary>
			/// <param name="prototype" type="MindFusion.Diagramming.Style" optional="true">Optional. </param>
		},
		SvgContent: function () {
			/// <summary>SvgContent represents the markup code of an SVG drawing.</summary>
		},
		SvgExporter: function () {
			/// <summary>Creates SVG (Scalable Vector Graphics) drawings from the content of Diagram objects.</summary>
		},
		SvgNode: function (parent) {
			/// <summary>SvgNode instances are diagram nodes that can render SVG drawings.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the node properties.</param>
		},
		TableConnectionPoint: function () {
			/// <summary>A class that represents a connection between an edge and a node in a graph.</summary>
		},
		TableNode: function (parent) {
			/// <summary>TableNode instances are diagram nodes that can be used to display tabular or list data.</summary>
			/// <param name="parent" type="MindFusion.Diagramming.Diagram" optional="true">Optional. The Diagram from which to obtain default values for the node properties.</param>
			/// <field name="useScrollBars" type="void">Set this flag to show full scrollbars for scrollable tables instead of up/down buttons in captions.</field>
		},
		Theme: function () {
			/// <summary>Represents a set of Style objects whose properties are used to render items of a specific type in the current diagram.</summary>
		},
		XmlPersistContext: function (diagram) {
			/// <summary>Contains helper methods for serialization of diagram contents to and from XML documents.</summary>
			/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram that will be serialized or deserialized.</param>
		},
		__namespace: true
	},
	Gauges: {
		ArcArea: function () {
			/// <summary>Represents an ellipse visual.</summary>
		},
		ArcSegment: function () {
			/// <summary>Represents an elliptical arc between two points.</summary>
		},
		BaseGauge: function (element) {
			/// <summary>Represents the base class of linear and oval gauges.</summary>
			/// <param name="element" type="Object">The Div DOM element this gauge is associated with.</param>
		},
		BaseScale: function (parent) {
			/// <summary>Represents a scale within a gauge control.</summary>
			/// <param name="parent" type="BaseGauge">The gauge control this scale belongs to.</param>
		},
		CenterPanel: function () {
			/// <summary>Represents a container which centers its children and makes them with square size.</summary>
		},
		CustomInterval: function () {
			/// <summary>Represents an interval with associated custom values for fill and stroke.</summary>
		},
		Ellipse: function () {
			/// <summary>Represents an ellipse visual.</summary>
		},
		Events: function () {
			/// <summary>Defines all events raised by the Gauge component.</summary>
		},
		GeometryFactory: function () {
			/// <summary>A factory class for various geometry objects.</summary>
		},
		Length: function (value, type) {
			/// <summary>Specifies distance expressed either absolutely, through pixels, or relatively, through a percentage of the container's size.</summary>
			/// <param name="value" type="Number">A number specifying the initial length value.</param>
			/// <param name="type" type="LengthType">A member of the LengthType enumeration specifying the length type.</param>
		},
		LinearGauge: function (element) {
			/// <summary>Represents a linear gauge control.</summary>
			/// <param name="element" type="Object">The Div DOM Element this LinearGauge is associated with.</param>
		},
		LinearScale: function (parent) {
			/// <summary>Represents a linear scale.</summary>
			/// <param name="parent" type="BaseGauge">The gauge control this scale belongs to.</param>
		},
		LineSegment: function () {
			/// <summary>Represents a line between two points.</summary>
		},
		MajorTickSettings: function (parent) {
			/// <summary>Provides settings for the major ticks and labels in a gauge scale.</summary>
			/// <param name="parent" type="BaseScale">The scale these settings belong to.</param>
		},
		MiddleTickSettings: function (parent) {
			/// <summary>Provides settings for the middle ticks and labels in a gauge scale.</summary>
			/// <param name="parent" type="BaseScale">The scale these settings belong to.</param>
		},
		MinorTickSettings: function (parent) {
			/// <summary>Provides settings for the minor ticks and labels in a gauge scale.</summary>
			/// <param name="parent" type="BaseScale">The scale these settings belong to.</param>
		},
		MouseInfo: function () {
			/// <summary>Provides mouse information when processing mouse events in the visual element hierarchy.</summary>
		},
		OvalGauge: function (element) {
			/// <summary>Represents a circular gauge control.</summary>
			/// <param name="element" type="Object">The Div DOM Element this OvalGauge is associated with.</param>
		},
		OvalScale: function (parent) {
			/// <summary>Represents a radial scale.</summary>
			/// <param name="parent" type="BaseGauge">The gauge control this scale belongs to.</param>
		},
		PaintEventArgs: function () {
			/// <summary>Provides data for the various custom painting event.</summary>
		},
		PathFigure: function (data) {
			/// <summary>Represents a connected series of geometric segments.</summary>
			/// <param name="data" type="String">The path data string.</param>
		},
		Pointer: function () {
			/// <summary>Represents a needle (or arrow) within a gauge scale.</summary>
		},
		pointers: function () {
			/// <summary>A list of pointer objects.</summary>
		},
		PrepaintEventArgs: function () {
			/// <summary>Provides data for various pre-paint events.</summary>
		},
		Range: function () {
			/// <summary>Represents a range within a gauge scale.</summary>
		},
		ranges: function () {
			/// <summary>A list of range objects.</summary>
		},
		RoundRectangle: function () {
			/// <summary>Represents a rounded rectangle.</summary>
		},
		scales: function () {
			/// <summary>A list of scale objects.</summary>
		},
		Segment: function () {
			/// <summary>Represents a segment of a PathFigure object.</summary>
		},
		Thickness: function (left, top, right, bottom, isRelative) {
			/// <summary>Describes the thickness on all four sides of a rectangular frame.</summary>
			/// <param name="left" type="Number">The width of the left side of the frame.</param>
			/// <param name="top" type="Number">The width of the top side of the frame.</param>
			/// <param name="right" type="Number">The width of the right side of the frame.</param>
			/// <param name="bottom" type="Number">The width of the bottom side of the frame.</param>
			/// <param name="isRelative" type="Number">A flag indicating whether the thickness properties are expressed as relative or absolute quantities.</param>
		},
		Tick: function (settings) {
			/// <summary>Represents a tick mark within a gauge scale.</summary>
			/// <param name="settings" type="TickSettings">The TickSettings object associated with this tick.</param>
		},
		TickLabel: function (settings) {
			/// <summary>Represents a tick label within a gauge scale.</summary>
			/// <param name="settings" type="TickSettings">The TickSettings object associated with this label.</param>
		},
		TickSettings: function (parent) {
			/// <summary>Provides settings for the ticks and labels in a gauge scale.</summary>
			/// <param name="parent" type="BaseScale">The scale these settings belong to.</param>
		},
		ValueChangedEventArgs: function () {
			/// <summary>Contains the arguments passed to value changed notification handlers.</summary>
		},
		ValueChangingEventArgs: function () {
			/// <summary>Contains the arguments passed to value changing notification handlers.</summary>
		},
		VisualElement: function () {
			/// <summary>Represents an object with outline and fill, which can render itself to a canvas.</summary>
		},
		VisualElementContainer: function () {
			/// <summary>Represents a visual element which contains other visual elements.</summary>
		},
		__namespace: true
	},
	Graphs: {
		anchoring: function () {
			/// <summary>Indicates how to align links to the anchor points of nodes.</summary>
		},
		BorderedTreeLayout: function () {
			/// <summary>Implements algorithms for arranging tree structures.</summary>
		},
		compactAssistants: function () {
			/// <summary>Indicates whether the "assistant" nodes on the same side of a single parentare arranged as close to each other as possible.</summary>
		},
		containerPadding: function () {
			/// <summary>The padding inside containers.</summary>
		},
		destination: function () {
			/// <summary>The destination vertex.</summary>
		},
		direction: function () {
			/// <summary>The orientation of the arranged graph.</summary>
		},
		Edge: function (origin, destination) {
			/// <summary>Represents an edge connecting two vertices in a graph.</summary>
			/// <param name="origin" type="MindFusion.Graphs.Vertex">The origin vertex.</param>
			/// <param name="destination" type="MindFusion.Graphs.Vertex">The destination vertex.</param>
		},
		edges: function () {
			/// <summary>A list containing all edges in the graph.</summary>
		},
		enableAssistants: function () {
			/// <summary>Indicates whether the "assistant" trait is regarded when performing the layout.</summary>
		},
		FlowchartLayout: function () {
			/// <summary>FlowchartLayout can be used to arrange flowcharts representing program source code.</summary>
		},
		FractalLayout: function () {
			/// <summary>The FractalLayout tree layout algorithm places child nodes symmetrically around their parent node. Nodes at the lowest level are arranged directly in a circle around their parent. At the upper level, the already arranged nodes form branches that are arranged in a circle around the new parent node. The algorithm is recursively repeated till the highest level is reached.</summary>
		},
		Graph: function () {
			/// <summary>Represents a graph.</summary>
		},
		inEdges: function () {
			/// <summary>A list containing all incoming edges.</summary>
		},
		iterations: function () {
			/// <summary>The number of iterations to run the layout routine.</summary>
		},
		keepGroupLayout: function () {
			/// <summary>Indicates whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		},
		keepRootPosition: function () {
			/// <summary>Indicates whether to keep the root node at its original position.</summary>
		},
		layerDistance: function () {
			/// <summary>The desired distance between layer axis lines.</summary>
		},
		LayeredLayout: function () {
			/// <summary>Implements a layered graph layout algorithm. This algorithm assigns diagram nodes to distinct horizontal or vertical layers. While arranging the layers, the layout routine seeks to meet the following criteria: - connected nodes must be placed close together;- links must flow in one direction if possible;- links must cross as few layers as possible;- links must not cross other links;</summary>
		},
		layoutArea: function () {
			/// <summary>The rectangle in which the layout will try to arrange nodes.</summary>
		},
		levelDistance: function () {
			/// <summary>The space to leave between adjacent levels of the tree.</summary>
		},
		linkType: function () {
			/// <summary>The type of the links in the arranged tree.</summary>
		},
		multipleGraphsPlacement: function () {
			/// <summary>Indicates how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		},
		nodeDistance: function () {
			/// <summary>The space to leave between adjacent nodes on the same level.</summary>
		},
		orientation: function () {
			/// <summary>The orientation of the arranged graph.</summary>
		},
		origin: function () {
			/// <summary>The origin vertex.</summary>
		},
		outEdges: function () {
			/// <summary>A list containing all outgoing edges.</summary>
		},
		padding: function () {
			/// <summary>The distance between adjacent nodes.</summary>
		},
		root: function () {
			/// <summary>Specifies the node that should be placed at the center of the tree.</summary>
		},
		siftingRounds: function () {
			/// <summary>The number of iterations to perform when untwining the layout.</summary>
		},
		SpringLayout: function () {
			/// <summary>Implements the Spring-Embedder graph layout algorithm.</summary>
		},
		squarify: function () {
			/// <summary>Indicates whether the layout should attempt to keep the dimension ratio of nodes closer to 1.</summary>
		},
		TreeLayout: function () {
			/// <summary>Implements algorithms for arranging tree structures.</summary>
		},
		TreeMapLayout: function () {
			/// <summary>Performs tree-map layout on a graph.</summary>
		},
		Vertex: function () {
			/// <summary>Represents a vertex in a graph.</summary>
		},
		vertices: function () {
			/// <summary>A list containing all vertices in the graph.</summary>
		},
		weight: function () {
			/// <summary>The relative weight of this vertex.</summary>
		},
		__namespace: true
	},
	Drawing: {
		bold: function () {
			/// <summary>true if this font is bold, otherwise false.</summary>
		},
		Border3D: function (rect) {
			/// <summary>Represents a 3D border.</summary>
			/// <param name="rect" type="MindFusion.Drawing.Rect">A Rect instance containing the border coordinates.</param>
		},
		bottom: function () {
			/// <summary>The bottom of the left side of the frame.</summary>
		},
		bounds: function () {
			/// <summary>The object's bounds.</summary>
		},
		Canvas: function (element) {
			/// <summary>The Canvas class represents a wrapper class for the HTML5 Canvas element.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this Canvas is associated with.</param>
		},
		Component: function () {
			/// <summary>Represents components in CompositeNode visual tree.</summary>
		},
		Ellipse: function (x, y, width, height) {
			/// <summary>Represents an Ellipse.</summary>
			/// <param name="x" type="Number">The X-coordinate of the top left corner of the Ellipse.</param>
			/// <param name="y" type="Number">The Y-coordinate of the top left corner of the Ellipse.</param>
			/// <param name="width" type="Number">The width of the Ellipse.</param>
			/// <param name="height" type="Number">The height of the Ellipse.</param>
		},
		Font: function (name, size, bold, italic, underline) {
			/// <summary>Represents a font.</summary>
			/// <param name="name" type="String">The font name.</param>
			/// <param name="size" type="Number">The font size.</param>
			/// <param name="bold" type="Boolean">true if this font is bold, otherwise false.</param>
			/// <param name="italic" type="Boolean">true if this font is italic, otherwise false.</param>
			/// <param name="underline" type="Boolean">true if this font is underlined, otherwise false.</param>
		},
		height: function () {
			/// <summary>The object's height.</summary>
		},
		image: function () {
			/// <summary>The image to be displayed.</summary>
		},
		italic: function () {
			/// <summary>true if this font is italic, otherwise false.</summary>
		},
		left: function () {
			/// <summary>The width of the left side of the frame.</summary>
		},
		Image: function () {
			/// <summary>Represents an image.</summary>
			/// <field name="bounds" type="MindFusion.Drawing.void">The object's bounds.</field>
			/// <field name="image" type="MindFusion.Drawing.void">The image to be displayed.</field>
		},
measureUnit: function () {
	/// <summary>The unit of measure used for logical coordinates.</summary>
},
name: function () {
	/// <summary>The font name.</summary>
},
Path: function (pathString) {
	/// <summary>Represents a path.</summary>
	/// <param name="pathString" type="String">A string representing the path figures.</param>
},
pen: function () {
	/// <summary>A pen defining the stroke of the curve.</summary>
},
Point: function (x, y) {
	/// <summary>Represents a point.</summary>
	/// <param name="x" type="Number">The X-coordinate of the Point.</param>
	/// <param name="y" type="Number">The Y-coordinate of the Point.</param>
	/// <field name="x" type="MindFusion.Drawing.void">The x-coordinate of the point.</field>
	/// <field name="y" type="MindFusion.Drawing.void">The y-coordinate of the point.</field>
},
Rect: function (x, y, width, height) {
	/// <summary>Represents a rectangle.</summary>
	/// <param name="x" type="Number">The X-coordinate of the top left corner of the rectangle.</param>
	/// <param name="y" type="Number">The Y-coordinate of the top left corner of the rectangle.</param>
	/// <param name="width" type="Number">The width of the rectangle.</param>
	/// <param name="height" type="Number">The height of the rectangle.</param>
},
right: function () {
	/// <summary>The width of the right side of the frame.</summary>
},
size: function () {
	/// <summary>The font size.</summary>
},
Size: function (width, height) {
	/// <summary>Represents the size of 2D object.</summary>
	/// <param name="width" type="Number">Specifies width.</param>
	/// <param name="height" type="Number">Specifies height.</param>
},
text: function () {
	/// <summary>The text to be displayed.</summary>
},
Text: function (text, bounds) {
	/// <summary>Represents a text container.</summary>
	/// <param name="text" type="String">The text to be displayed in the container.</param>
	/// <param name="bounds" type="MindFusion.Drawing.Rect">The bounds of the container.</param>
},
Thickness: function (left, top, right, bottom) {
	/// <summary>Describes the thickness of a rectangular frame.</summary>
	/// <param name="left" type="Number">Specifies the width of the left side of the frame.</param>
	/// <param name="top" type="Number">Specifies the width of the top side of the frame.</param>
	/// <param name="right" type="Number">Specifies the width of the right side of the frame.</param>
	/// <param name="bottom" type="Number">Specifies the width of the bottom side of the frame.</param>
},
top: function () {
	/// <summary>The width of the top side of the frame.</summary>
},
underline: function () {
	/// <summary>true if this font is underlined, otherwise false.</summary>
},
Vector: function (x, y) {
	/// <summary>Represents a point.</summary>
	/// <param name="x" type="Number">The X-coordinate of the Vector.</param>
	/// <param name="y" type="Number">The Y-coordinate of the Vector.</param>
	/// <field name="x" type="MindFusion.Drawing.void">The x-coordinate of the vector.</field>
	/// <field name="y" type="MindFusion.Drawing.void">The y-coordinate of the vector.</field>
},
width: function () {
	/// <summary>The object's width.</summary>
},
x: function () {
	/// <summary>The x-coordinate of the upper-left corner of the rectangle.</summary>
},
y: function () {
	/// <summary>The y-coordinate of the upper-left corner of the rectangle.</summary>
},
zoomFactor: function () {
	/// <summary>The zoom factor used to scale up or down the drawing.</summary>
},
__namespace: true
},
Controls: {
		MouseCursors: function () {
			/// <summary>Specifies the type of the mouse cursor.</summary>
		},
		ZoomControl: function (element) {
			/// <summary>The ZoomControl lets users zoom and pan a target view control interactively.</summary>
			/// <param name="element" type="Canvas">The Canvas DOM Element this ZoomControl is associated with.</param>
		},
		__namespace: true
},
Animations: {
		Animation: function (item, options, onUpdateCallback, onCustomFunctionCallback) {
			/// <summary>Represents an object that is used to animate diagram items on the canvas.</summary>
			/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The diagram item to animate.</param>
			/// <param name="options" type="Object" optional="true">Optional. An object used to specify various property values for the animation.</param>
			/// <param name="onUpdateCallback" type="Function" optional="true">Optional. A callback function called on every animation tick.</param>
			/// <param name="onCustomFunctionCallback" type="Function" optional="true">Optional. A callback function called when the animation type is set to Custom.</param>
		},
		Events: function () {
			/// <summary>Defines all events raised in the Animations namespace.</summary>
		},
		item: function () {
			/// <summary>The DiagramItem associated with this animation.</summary>
		},
		__namespace: true
},
Collections: {
		ArrayList: function () {
			/// <summary>Represents an array of arbitrary objects.</summary>
		},
		Dictionary: function () {
			/// <summary>Represents a collection of keys and values.</summary>
		},
		Grid: function () {
			/// <summary>Represents a collection of tabular data.</summary>
		},
		ItemEventArgs: function (item) {
			/// <summary>Contains the arguments passed to event handlers of the ObservableCollection class.</summary>
			/// <param name="item" type="Object">The item related to the event.</param>
		},
		ObservableCollection: function () {
			/// <summary>Represents a collection that provides notifications when items get added or removed.</summary>
		},
		Queue: function () {
			/// <summary>Represents a first-in, first-out collection of objects.</summary>
		},
		Set: function () {
			/// <summary>Represents a collection of unique elements with no particular ordering.</summary>
		},
		__namespace: true
},
Mapping: {
		Bubble: function (location, text) {
			/// <summary>Initializes a new instance of the Bubble class.</summary>
			/// <param name="location" type="LatLong" optional="true">Optional. LatLong. The location of this bubble in geographical coordinates.</param>
			/// <param name="text" type="String" optional="true">Optional. String. The text of this bubble.</param>
			/// <field name="multiline" type="Boolean">Gets or sets a value indicating whether the bubble's text can be on more than one line.</field>
			/// <field name="text" type="String">Gets or sets the text of this bubble.</field>
		},
		CancelEventArgs: function () {
			/// <summary>Initializes a new instance of the CancelEventArgs class.</summary>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation.</field>
		},
		Control: function (element) {
			/// <summary>Initializes a new instance of the Control class.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="bounds" type="MindFusion.Mapping.Rect">Gets the bounds of this control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control.</field>
			/// <field name="height" type="MindFusion.Mapping.Unit">Gets or sets the height of this control.</field>
			/// <field name="left" type="MindFusion.Mapping.Unit">Gets or sets the X-coordinate of the location of this control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction.</field>
			/// <field name="rect" type="MindFusion.Mapping.Rect">Gets the bounding rect of this control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control.</field>
			/// <field name="top" type="MindFusion.Mapping.Unit">Gets or sets the Y-coordinate of the location of this control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control.</field>
			/// <field name="width" type="MindFusion.Mapping.Unit">Gets or sets the width of this control.</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} );</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} );</field>
		},
		Decoration: function (location) {
			/// <summary>Initializes a new instance of the Decoration class.</summary>
			/// <param name="location" type="LatLong" optional="true">Optional. LatLong. The location of this decoration in geographical coordinates.</param>
			/// <field name="cssClass" type="String">Gets or sets the css class of this decoration.</field>
			/// <field name="element" type="HTMLDivElement">Returns a reference to the decoration DOM element.</field>
			/// <field name="location" type="MindFusion.Mapping.LatLong">Gets or sets the location of this decoration.</field>
			/// <field name="offset" type="MindFusion.Mapping.Point">Gets or sets the client offset of this decoration.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this decoration.</field>
		},
		DecorationEventArgs: function (rawEventArgs) {
			/// <summary>Initializes a new instance of the DecorationEventArgs class.</summary>
			/// <param name="rawEventArgs" type="Object">Object. Gets the Javascript event data.</param>
			/// <field name="decoration" type="MindFusion.Mapping.Decoration">Gets the decoration related to the event.</field>
		},
		DecorationLayer: function (id) {
			/// <summary>Initializes a new instance of the DecorationLayer class.</summary>
			/// <param name="id" type="String" optional="true">Optional. String. The id of this layer.</param>
			/// <field name="bubbles" type="MindFusion.Mapping.ObservableCollection">Gets the collection of bubbles, displayed by this layer.</field>
			/// <field name="decorations" type="MindFusion.Mapping.ObservableCollection">Gets the collection of decorations, displayed by this layer.</field>
			/// <field name="id" type="String">Gets the id of this layer.</field>
			/// <field name="markers" type="MindFusion.Mapping.ObservableCollection">Gets the collection of markers, displayed by this layer.</field>
			/// <field name="parent" type="MindFusion.Mapping.MapView">Gets the parent control of this layer.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this layer.</field>
		},
		Dictionary: function () {
			/// <summary>Initializes a new instance of the Dictionary class.</summary>
			/// <field name="count" type="Number">Gets the number of key/value pairs contained in the dictionary.</field>
			/// <field name="keys" type="MindFusion.Mapping.List">Gets the list of all keys in the dictionary.</field>
			/// <field name="values" type="MindFusion.Mapping.List">Gets the list of all values in the dictionary.</field>
		},
		EmptyEventArgs: function () {
			/// <summary>Initializes a new instance of the EmptyEventArgs class.</summary>
		},
		EventArgs: function () {
			/// <summary>The base type of classes that define arguments passed to event handler functions.</summary>
		},
		EventDispatcher: function () {
			/// <summary>Represents a dispatcher for an event.</summary>
		},
		Hint: function () {
			/// <summary>Initializes a new instance of the Hint class.</summary>
		},
		IEnumerable: function (items) {
			/// <summary>Initializes a new instance of the IEnumerable class.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
		},
		LatLong: function (latitude, longitude) {
			/// <summary>Initializes a new instance of the LatLong class.</summary>
			/// <param name="latitude" type="Number">Number. The latitude of the location.</param>
			/// <param name="longitude" type="Number">Number. The longitude of the location.</param>
			/// <field name="latitude" type="Number">Gets or sets the latitude of the location.</field>
			/// <field name="longitude" type="Number">Gets or sets the longitude of the location.</field>
		},
		LayerController: function () {
			/// <summary>Initializes a new instance of the LayerController class.</summary>
		},
		List: function (items) {
			/// <summary>Initializes a new instance of the List class.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the list.</param>
		},
		MapEventArgs: function (location, position, rawEventArgs) {
			/// <summary>Initializes a new instance of the MapEventArgs class.</summary>
			/// <param name="location" type="LatLong">LatLong. The geographic cooordinates related to the event.</param>
			/// <param name="position" type="Point">Point. The client position related to the event.</param>
			/// <param name="rawEventArgs" type="Object">Object. The Javascript event data.</param>
			/// <field name="location" type="MindFusion.Mapping.LatLong">Gets the geographic cooordinates related to the event.</field>
			/// <field name="position" type="MindFusion.Mapping.Point">Gets the client position related to the event.</field>
			/// <field name="rawEventArgs" type="Object">Gets the Javascript event data.</field>
		},
		MapLayer: function (id) {
			/// <summary>Initializes a new instance of the MapLayer class.</summary>
			/// <param name="id" type="String" optional="true">Optional. String. The id of this layer.</param>
			/// <field name="attribution" type="String">Gets or sets the attribution HTML of the layer.</field>
			/// <field name="id" type="String">Gets the id of this layer.</field>
			/// <field name="parent" type="MindFusion.Mapping.MapView">Gets the parent control of this layer.</field>
			/// <field name="urlTemplate" type="String">Gets or sets the template string of the tile server URL.</field>
		},
		MapView: function (element) {
			/// <summary>Initializes a new instance of the MapView class.</summary>
			/// <param name="element" type="HTMLElement" optional="true">Optional. HTMLElement. The control's associated Dom element.</param>
			/// <field name="activeLayer" type="MindFusion.Mapping.MapLayer">Gets or sets the active map layer.</field>
			/// <field name="allowPan" type="Boolean">Gets or sets a value indicatin whether drag panning is enabled.</field>
			/// <field name="allowZoom" type="Boolean">Gets or sets a value indicatin whether mouse wheel zooming is enabled.</field>
			/// <field name="decorations" type="MindFusion.Mapping.ObservableCollection">Gets the default decorations collection.</field>
			/// <field name="layers" type="MindFusion.Mapping.ObservableCollection">Gets the collection of all layers.</field>
			/// <field name="mapCenter" type="MindFusion.Mapping.LatLong">Gets the geographical center of a loaded map.</field>
			/// <field name="mapLayers" type="MindFusion.Mapping.ObservableCollection">Gets the collection of map layers.</field>
			/// <field name="maxZoomLevel" type="Number">Gets or sets the maximum zoom of the map.</field>
			/// <field name="minZoomLevel" type="Number">Gets or sets the minimum zoom of the map.</field>
			/// <field name="overlays" type="MindFusion.Mapping.ObservableCollection">Gets the collection of decoration layers.</field>
			/// <field name="scrollX" type="Number">Gets the map's horizontal scroll position relative to the control bounds.</field>
			/// <field name="scrollY" type="Number">Gets the map's vertical scroll position relative to the control bounds.</field>
			/// <field name="showLayerController" type="Boolean">Gets or sets the visibility of the built-in layer controller.</field>
			/// <field name="showZoomController" type="Boolean">Gets or sets the visibility of the built-in zoom controller.</field>
			/// <field name="zoomStep" type="Number">Gets or sets the zoom step.</field>
			/// <field name="bounds" type="MindFusion.Mapping.Rect">Gets the bounds of this control. Inherited from Control.</field>
			/// <field name="cssClass" type="String">Gets or sets the css class of the control. Inherited from Control.</field>
			/// <field name="data" type="Object">Gets or sets an object, holding custom user data. Inherited from Control.</field>
			/// <field name="element" type="HTMLElement">Gets a reference to the control's element. Inherited from Control.</field>
			/// <field name="enabled" type="Boolean">Gets or sets a value indicating whether user interactions are allowed for this control. Inherited from Control.</field>
			/// <field name="height" type="MindFusion.Mapping.Unit">Gets or sets the height of this control. Inherited from Control.</field>
			/// <field name="left" type="MindFusion.Mapping.Unit">Gets or sets the X-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="licenseLocation" type="String">Gets or sets the URL of the control's license file. Inherited from Control.</field>
			/// <field name="loaded" type="Boolean">Gets a value indicating whether this control is loaded and ready for interaction. Inherited from Control.</field>
			/// <field name="rect" type="MindFusion.Mapping.Rect">Gets the bounding rect of this control. Inherited from Control.</field>
			/// <field name="theme" type="String">Gets or sets the current theme of the control. Inherited from Control.</field>
			/// <field name="top" type="MindFusion.Mapping.Unit">Gets or sets the Y-coordinate of the location of this control. Inherited from Control.</field>
			/// <field name="visible" type="Boolean">Gets or sets the visibility of this control. Inherited from Control.</field>
			/// <field name="width" type="MindFusion.Mapping.Unit">Gets or sets the width of this control. Inherited from Control.</field>
			/// <field name="click" type="EventDispatcher">Raised when the user clicks on the map surface. Syntax: click.addEventListener( function(sender, args){} );</field>
			/// <field name="decorationClick" type="EventDispatcher">Raised when the user clicks on a decoration element. Syntax: decorationClick.addEventListener( function(sender, args){} );</field>
			/// <field name="decorationHover" type="EventDispatcher">Raised when the user hovers over a decoration element. Syntax: decorationHover.addEventListener( function(sender, args){} );</field>
			/// <field name="hover" type="EventDispatcher">Raised when the user hovers over the map surface. Syntax: hover.addEventListener( function(sender, args){} );</field>
			/// <field name="layerLoad" type="EventDispatcher">Raised when all tiles in a map layer are loaded. Syntax: layerLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="viewLoad" type="EventDispatcher">Raised when map view layers are loaded. Syntax: viewLoad.addEventListener( function(sender, args){} );</field>
			/// <field name="controlLoad" type="EventDispatcher">Raised when the control is loaded. Syntax: controlLoad.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="controlUnload" type="EventDispatcher">Raised when the control is unloaded. Syntax: controlUnload.addEventListener( function(sender, args){} ); Inherited from Control.</field>
			/// <field name="focus" type="EventDispatcher">Raised when the control is focused. Syntax: focus.addEventListener( function(sender, args){} ); Inherited from Control.</field>
		},
		Marker: function (location) {
			/// <summary>Initializes a new instance of the Marker class.</summary>
			/// <param name="location" type="LatLong" optional="true">Optional. LatLong. The location of this marker in geographical coordinates.</param>
			/// <field name="imageSrc" type="String">Gets or sets the URL of the image displayed by this marker.</field>
			/// <field name="text" type="String">Gets or sets the text of this marker.</field>
		},
		NotifyCollectionChangedAction: function () {
			/// <summary>Specifies the type of the collection changed action.</summary>
		},
		NotifyCollectionChangedEventArgs: function (action, changes, index) {
			/// <summary>Initializes a new instance of the NotifyCollectionChangedEventArgs class.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
			/// <field name="action" type="MindFusion.Mapping.NotifyCollectionChangedAction">Gets the action that caused the event.</field>
			/// <field name="index" type="Number">Gets the index where the change occurred.</field>
			/// <field name="newItems" type="Array">Gets the list of new items involved in the change.</field>
			/// <field name="oldItems" type="Array">Gets the list of the items affected by a Remove action.</field>
		},
		NotifyCollectionChangingEventArgs: function (action, changes, index) {
			/// <summary>Initializes a new instance of the NotifyCollectionChangingEventArgs class.</summary>
			/// <param name="action" type="NotifyCollectionChangedAction">NotifyCollectionChangedAction. The action that caused the event.</param>
			/// <param name="changes" type="Array" optional="true">Optional. Array. The items affected by the change.</param>
			/// <param name="index" type="Number" optional="true">Optional. Number. The index where the change occurred.</param>
			/// <field name="action" type="MindFusion.Mapping.NotifyCollectionChangedAction">Gets the action that caused the event.</field>
			/// <field name="newItems" type="Array">Gets the list of new items involved in the change.</field>
			/// <field name="oldItems" type="Array">Gets the list of the items affected by a Remove action.</field>
			/// <field name="cancel" type="Boolean">Gets or sets a value indicating whether to allow the current operation. Inherited from CancelEventArgs.</field>
		},
		ObservableCollection: function (items) {
			/// <summary>Initializes a new instance of the ObservableCollection class.</summary>
			/// <param name="items" type="Array" optional="true">Optional. Array. The underlying array data structure of the collection.</param>
			/// <field name="collectionChanged" type="EventDispatcher">Occurs when an item is added, removed, changed, moved, or the entire list is refreshed. Syntax: collectionChanged.addEventListener( function(sender, args){} );</field>
			/// <field name="collectionChanging" type="EventDispatcher">Occurs just before an item is added, removed, changed, moved, or the entire list is refreshed. Syntax: collectionChanging.addEventListener( function(sender, args){} );</field>
		},
		PropertyEventArgs: function (propertyName, oldValue, newValue) {
			/// <summary>Initlializes a new instance of the PropertyEventArgs class.</summary>
			/// <param name="propertyName" type="String">String. The name of the property that changed.</param>
			/// <param name="oldValue" type="Object">Object. The old value of the property.</param>
			/// <param name="newValue" type="Object">Object. The new value of the property.</param>
			/// <field name="newValue" type="Object">Gets the current value of the property.</field>
			/// <field name="oldValue" type="Object">Gets the value of the property before the change.</field>
			/// <field name="propertyName" type="String">Gets the name of the property that changed.</field>
		},
		Unit: function (value, type) {
			/// <summary>Initializes a new instance of the Unit class.</summary>
			/// <param name="value" type="Number" optional="true">Optional. Number. The value of the unit.</param>
			/// <param name="type" type="UnitType" optional="true">Optional. UnitType. The type of the unit.</param>
			/// <field name="isEmpty" type="Boolean">Gets a value representing whether this Unit instance has a set value.</field>
			/// <field name="type" type="MindFusion.Mapping.UnitType">The unit type.</field>
			/// <field name="value" type="Number">The unit value.</field>
		},
		ZoomController: function () {
			/// <summary>Initializes a new instance of the ZoomController class.</summary>
		},
		__namespace: true
},
Charting: {
		Controls: {
			AreaChart: function (element, lineType, seriesRenderer) {
				/// <summary>A control used to draw area charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="lineType" type="LineType" optional="true">Optional. A member of the LineType enumeration.</param>
				/// <param name="seriesRenderer" type="AreaRenderer" optional="true">Optional. An AreaRenderer used to draw chart's data series.</param>
				/// <field name="areaOpacity" type="MindFusion.Charting.Controls.Number">Gets or sets the opacity of area polygons.</field>
				/// <field name="lineType" type="MindFusion.Charting.Controls.LineType">Gets or sets what type of line segments to draw between data points.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
			},
			BarChart: function (element, barLayout, seriesRenderer) {
				/// <summary>A control used to draw bar charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="barLayout" type="BarLayout" optional="true">Optional. A member of the BarLayout enumeration.</param>
				/// <param name="seriesRenderer" type="Renderer2D" optional="true">Optional. A Renderer2D used to draw chart's data series.</param>
				/// <field name="barLayout" type="MindFusion.Charting.Controls.BarLayout">Gets or sets how to arrange bars when rendering multiple series.</field>
				/// <field name="barSpacingRatio" type="MindFusion.Charting.Controls.Number">Gets or sets the ratio of empty space between bars to space occupied by bars.</field>
				/// <field name="horizontalBars" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value identifying whether bars should be horizontal.</field>
				/// <field name="innerLabelRotation" type="MindFusion.Charting.Controls.Number">Gets the rotation angle of inner labels. If not specified, labels are rotated at predefiend angles depending on bars' orientation and layout.</field>
				/// <field name="outerLabelRotation" type="MindFusion.Charting.Controls.Number">Gets the rotation angle of outer labels. If not specified, labels are rotated at predefiend angles depending on bars' orientation and layout.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
				/// <field name="stackOuterLabels" type="MindFusion.Charting.Controls.Boolean">Gets whether outer labels are displayed stacked on top of stacked bars, instead of showing them on the bar sides.</field>
			},
			BarChart3D: function (element, barLayout, barModel, seriesRenderer) {
				/// <summary>A control used to draw 3D bar charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="barLayout" type="BarLayout" optional="true">Optional. A member of the BarLayout enumeration.</param>
				/// <param name="barModel" type="BarModel3D" optional="true">Optional. A member of the BarModel3D enumeration.</param>
				/// <param name="seriesRenderer" type="Renderer2D" optional="true">Optional. A Renderer2D used to draw chart's data series.</param>
				/// <field name="barLayout" type="MindFusion.Charting.Controls.BarLayout">Gets or sets how to arrange bars when rendering multiple series.</field>
				/// <field name="barModel" type="MindFusion.Charting.Controls.BarModel3D">Gets or sets how to visualize the bars when rendering multiple series.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
			},
			BiaxialChart: function (element, seriesRenderer) {
				/// <summary>A base class for charts that display X and Y axes.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="Renderer2D" optional="true">Optional. A SeriesRenderer used to draw chart's data series.</param>
				/// <field name="allowPan" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether users are allowed to pan the chart's plot.</field>
				/// <field name="annotations" type="MindFusion.Charting.Collections.ObservableCollection<Series>">Gets or sets the list of series whose labels are drawn as annotations.</field>
				/// <field name="gridType" type="MindFusion.Charting.Controls.GridType">Gets or sets the type of grid to draw in this chart.</field>
				/// <field name="pinGrid" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether grid stripes should be pinned in place or scroll together with the plot when users pan it.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">Gets or sets the list of series whose data is drawn in this chart.</field>
				/// <field name="showScatter" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the chart should render scatter shapes.</field>
				/// <field name="showXCoordinates" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show X axis coordinates.</field>
				/// <field name="showXRangeSelector" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show a RangeSelector for the X axis, to let users scroll or resize the currently visible horizontal data window.</field>
				/// <field name="showXTicks" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show X axis ticks.</field>
				/// <field name="showYCoordinates" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show Y axis coordinates.</field>
				/// <field name="showYRangeSelector" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show a RangeSelector for the Y axis, to let users scroll or resize the currently visible vertical data window.</field>
				/// <field name="showYTicks" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether to show Y axis ticks.</field>
				/// <field name="xAxis" type="MindFusion.Charting.Axis">Gets or sets an Axis object representing horizontal data range.</field>
				/// <field name="xAxisLabelRotationAngle" type="MindFusion.Charting.Controls.Number">Gets or sets the rotation angle of the X axis labels.</field>
				/// <field name="xAxisTickLength" type="MindFusion.Charting.Controls.Number">Gets or sets the length of X axis ticks.</field>
				/// <field name="xScrollRangeMax" type="MindFusion.Charting.Controls.Number">Gets or sets the largest value allowed to scroll to using the X axis' RangeSelector.</field>
				/// <field name="xScrollRangeMin" type="MindFusion.Charting.Controls.Number">Gets or sets the smallest value allowed to scroll to using the X axis' RangeSelector.</field>
				/// <field name="yAxis" type="MindFusion.Charting.Axis">Gets or sets an Axis object representing vertical data range.</field>
				/// <field name="yAxisLabelRotationAngle" type="MindFusion.Charting.Controls.Number">Gets or sets the rotation angle of the Y axis labels.</field>
				/// <field name="yAxisTickLength" type="MindFusion.Charting.Controls.Number">Gets or sets the length of Y axis ticks.</field>
				/// <field name="yLabelAlignment" type="MindFusion.Charting.Drawing.StringAlignment">Gets the horizontal alignment of Y-axis labels.</field>
				/// <field name="yScrollRangeMax" type="MindFusion.Charting.Controls.Number">Gets or sets the largest value allowed to scroll to using the Y axis' RangeSelector.</field>
				/// <field name="yScrollRangeMin" type="MindFusion.Charting.Controls.Number">Gets or sets the smallest value allowed to scroll to using the Y axis' RangeSelector.</field>
			},
			BubbleChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw bubble charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="BubbleRenderer" optional="true">Optional. A LineRenderer used to draw chart's data series.</param>
				/// <field name="labelAlignment" type="MindFusion.Charting.Controls.BubbleLabelAlignment">Gets or sets the alignment of labels relative to their associated bubbles.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
			},
			CandlestickChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw candlestick charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="CandlestickRenderer" optional="true">Optional. A CandlestickRenderer used to draw chart's data series.</param>
				/// <field name="candlestickWidth" type="MindFusion.Charting.Controls.Number">Gets or sets the width of the candlesticks.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
			},
			Chart: function (element, renderer) {
				/// <summary>A base class for chart controls.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="renderer" type="SeriesRenderer" optional="true">Optional. A SeriesRenderer used to draw chart's data series.</param>
				/// <field name="allowMoveLegend" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether users are allowed to move the legend.</field>
				/// <field name="chartPanel" type="MindFusion.Charting.Controls.GridPanel">Gets or sets the GridPanel that contains the chart's PlotPanel and axis renderers.</field>
				/// <field name="dataBoundSeries" type="MindFusion.Charting.Collections.List<Series>">Contains series generated from DataSource data.</field>
				/// <field name="dataSource" type="MindFusion.Charting.Controls.Object">Gets or sets the chart's data source.</field>
				/// <field name="innerLabelsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as inner labels of rendered graphical elements.</field>
				/// <field name="legendHorizontalAlignment" type="MindFusion.Charting.Controls.LayoutAlignment">Gets or sets the horizontal alignment of the legend.</field>
				/// <field name="legendMargin" type="MindFusion.Charting.Controls.Margins">Gets or sets the margin space around the legend.</field>
				/// <field name="legendRenderer" type="MindFusion.Charting.Controls.LegendRenderer">Gets the LegendRenderer component used to draw the chart's legend.</field>
				/// <field name="legendSpacing" type="MindFusion.Charting.Controls.Number">Gets the distance between adjacent entries in the legend.</field>
				/// <field name="legendTitle" type="String">Gets or sets the legend title.</field>
				/// <field name="legendVerticalAlignment" type="MindFusion.Charting.Controls.LayoutAlignment">Gets or sets the vertical alignment of the legend.</field>
				/// <field name="outerLabelsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as outer labels of rendered graphical elements.</field>
				/// <field name="plot" type="MindFusion.Charting.Controls.Plot">Gets the chart's Plot component.</field>
				/// <field name="plotImageAlign" type="MindFusion.Charting.Drawing.ImageAlign">Gets or sets the alignment of PlotImage relatively to the plot boundaries.</field>
				/// <field name="plotImageAutoSize" type="MindFusion.Charting.Controls.Boolean">Gets or sets whether auto-size mode is enabled for PlotImage.</field>
				/// <field name="plotImageLocation" type="String">Gets or sets the Image drawn inside chart's plot area.</field>
				/// <field name="plotPanel" type="MindFusion.Charting.Components.Panel">Gets the Panel that contains the chart's plot and associated elements.</field>
				/// <field name="showDataLabels" type="MindFusion.Charting.Controls.Boolean">Gets or sets what kind of labels from data series should be drawn.</field>
				/// <field name="showHighlight" type="MindFusion.Charting.Controls.Boolean">Gets a value indicating whether to show highlights on data items.</field>
				/// <field name="showLegend" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the chart should draw a legend.</field>
				/// <field name="showLegendTitle" type="MindFusion.Charting.Controls.Boolean">Gets a value indicating whether to display the legend title.</field>
				/// <field name="showToolTips" type="MindFusion.Charting.Controls.Boolean">Gets a value indicating whether to show tooltips.</field>
				/// <field name="showZoomWidgets" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the plot should show zoom buttons.</field>
				/// <field name="subtitle" type="String">Gets or sets the sub-title of this chart.</field>
				/// <field name="subtitleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw chart's Subtitle.</field>
				/// <field name="subtitleFontName" type="String">Gets or sets the name of Font used to draw chart's Subtitle.</field>
				/// <field name="subtitleFontSize" type="MindFusion.Charting.Controls.Number">Gets or sets the size of Font used to draw chart's Subtitle.</field>
				/// <field name="subtitleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of Font used to draw chart's Subtitle.</field>
				/// <field name="subtitleMargin" type="MindFusion.Charting.Controls.Margins">Gets or sets the margin space around Subtitle.</field>
				/// <field name="title" type="String">Gets or sets the title of this chart.</field>
				/// <field name="titleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw chart's Title.</field>
				/// <field name="titleFontName" type="String">Gets or sets the name of Font used to draw chart's Title.</field>
				/// <field name="titleFontSize" type="MindFusion.Charting.Controls.Number">Gets or sets the size of Font used to draw chart's Title.</field>
				/// <field name="titleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of Font used to draw chart's Title.</field>
				/// <field name="titleMargin" type="MindFusion.Charting.Controls.Margins">Gets or sets the margin space around Title.</field>
				/// <field name="toolTipsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as tooltips of rendered graphical elements.</field>
				/// <field name="xAxisLabelsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as X axis labels of rendered graphical elements.</field>
				/// <field name="xDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are assigned to X coordinates of rendered graphical elements.</field>
				/// <field name="yAxisLabelsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as Y axis labels of rendered graphical elements.</field>
				/// <field name="yDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are assigned to Y coordinates of rendered graphical elements.</field>
				/// <field name="zAxisLabelsDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are shown as Z axis labels of rendered graphical elements.</field>
				/// <field name="zDataFields" type="MindFusion.Charting.Collections.ObservableCollection<String>">Gets or sets the names of fields in the data source whose values are assigned to Z coordinates of rendered graphical elements.</field>
			},
			Dashboard: function (element) {
				/// <summary>A control that contains multiple chart plots and gauges and manages their layout.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this dashboard with.</param>
				/// <field name="allowZoom" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether users are allowed to zoom into plots' data ranges.</field>
				/// <field name="backColor" type="MindFusion.Charting.Drawing.Color">Gets or sets dashboard's back color.</field>
				/// <field name="backgroundImageAlign" type="MindFusion.Charting.Drawing.ImageAlign">Gets or sets the alignment of BackgroundImage relatively to dashboard boundaries.</field>
				/// <field name="backgroundImageAutoSize" type="MindFusion.Charting.Controls.Boolean">Gets or sets whether auto-size mode is enabled for BackgroundImage.</field>
				/// <field name="backgroundImageLocation" type="String">Gets or sets dashboard's background image.</field>
				/// <field name="layoutBuilder" type="MindFusion.Charting.Controls.LayoutBuilder">Gets a LayoutBuilder instance that provides shortcut methods for building fragments of dashboard's user interface.</field>
				/// <field name="layoutPanel" type="MindFusion.Charting.Controls.StackPanel">Gets a Panel containing dashboard components that should participate in layout measurements and be arranged relatively to each other.</field>
				/// <field name="licenseKey" type="String">Gets or sets the license key of the control.</field>
				/// <field name="licenseLocation" type="String">Gets or sets the path to the license file.</field>
				/// <field name="rootPanel" type="MindFusion.Charting.Controls.Panel">Gets the root Panel in the hierarchy of dashboard components.</field>
				/// <field name="theme" type="MindFusion.Charting.Controls.Theme">Gets or sets a Theme specifying appearance of dashboard elements.</field>
			},
			FunnelChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw funnel charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="FunnelRenderer" optional="true">Optional. A FunnelRenderer used to draw chart's data series.</param>
				/// <field name="dimension" type="MindFusion.Charting.Controls.Number">Gets or sets the dimension index that should be used to read data from the Series.</field>
				/// <field name="segmentSpacing" type="MindFusion.Charting.Controls.Number">Gets or sets the spacing between segments.</field>
				/// <field name="series" type="MindFusion.Charting.Controls.Series">Gets or sets the series whose data is drawn in this chart.</field>
				/// <field name="stemWidth" type="MindFusion.Charting.Controls.Number">Gets or sets the width of the funnel stem.</field>
			},
			LayoutBuilder: function (board) {
				/// <summary>Provides shortcut methods for building fragments of dashboard's user interface.</summary>
				/// <param name="board" type="Dashboard">A Dashboard instance.</param>
			},
			LineChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw line charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="LineRenderer" optional="true">Optional. A LineRenderer used to draw chart's data series.</param>
				/// <field name="lineType" type="MindFusion.Charting.Controls.LineType">Gets or sets what type of line segments to draw between data points.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
			},
			PieChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw pie charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="PieRenderer" optional="true">Optional. A PieRenderer used to draw chart's data series.</param>
				/// <field name="allowRotate" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether users are allowed to rotate this chart.</field>
				/// <field name="chartPadding" type="MindFusion.Charting.Controls.Number">Gets or set padding space between the plot's border and series graphics.</field>
				/// <field name="detachedSlices" type="MindFusion.Charting.Controls.List<Number>">Gets or sets indices of detached slices.</field>
				/// <field name="doughnut" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the pie should be rendered as a doughnut.</field>
				/// <field name="series" type="MindFusion.Charting.Controls.Series">Gets or sets the series whose data is drawn in this chart.</field>
				/// <field name="startAngle" type="MindFusion.Charting.Controls.Number">Gets or sets the angle where first data item of series should be drawn.</field>
			},
			RadarChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw radar charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="RadarRenderer" optional="true">Optional. A RadarRenderer used to draw chart's data series.</param>
				/// <field name="alignToAxis" type="MindFusion.Charting.Controls.Boolean">Gets or sets whether pie-radar sectors should be aligned to axes in the radar grid or centered around them.</field>
				/// <field name="allowRotate" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether users are allowed to rotate this chart.</field>
				/// <field name="areaOpacity" type="MindFusion.Charting.Controls.Number">Gets or sets the opacity of radar polygons.</field>
				/// <field name="axes" type="MindFusion.Charting.Collections.ObservableCollection<Axis>">Gets the list of Axis objects representing ranges of variables represented in the radar chart.</field>
				/// <field name="chartPadding" type="MindFusion.Charting.Controls.Number">Gets or set padding space between the plot's border and series graphics.</field>
				/// <field name="defaultAxis" type="MindFusion.Charting.Axis">Gets a default Axis object used when data item index does not have corresponding element in the Axes collection.</field>
				/// <field name="gridColor1" type="MindFusion.Charting.Drawing.Color">Gets or sets the main color of the grid.</field>
				/// <field name="gridColor2" type="MindFusion.Charting.Drawing.Color">Gets or sets the alternating color of the grid.</field>
				/// <field name="gridDivisions" type="MindFusion.Charting.Controls.Number">Gets or sets the number of grid divisions.</field>
				/// <field name="gridType" type="MindFusion.Charting.Controls.RadarGridType">Gets or sets the type of grid drawn in this chart.</field>
				/// <field name="radarType" type="MindFusion.Charting.Controls.RadarType">Gets or sets the type of radar graphics drawn in this chart.</field>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">Gets or sets the list of series whose data is drawn in this chart.</field>
				/// <field name="showCoordinates" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the chart should show axis coordinates.</field>
				/// <field name="showScatter" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether the chart should render scatter shapes.</field>
				/// <field name="startAngle" type="MindFusion.Charting.Controls.Number">Gets or sets the angle where first data item of series should be drawn.</field>
				/// <field name="uniformScale" type="MindFusion.Charting.Controls.Boolean">Gets or sets a value indicating whether all axes should display same data range.</field>
			},
			ScatterChart: function (element, seriesRenderer) {
				/// <summary>A control used to draw scatter charts.</summary>
				/// <param name="element" type="HTMLCanvasElement">The canvas DOM element to associate this chart with.</param>
				/// <param name="seriesRenderer" type="ScatterRenderer" optional="true">Optional. A ScatterRenderer used to draw chart's data series.</param>
				/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">BiaxialChart.Series override. Gets or sets the list of series whose data is drawn in this chart.</field>
				/// <field name="shape" type="MindFusion.Charting.Controls.ScatterType">Gets or sets the type of scatter shapes.</field>
				/// <field name="shapeSize" type="MindFusion.Charting.Controls.Number">Gets or sets the size of scatter shapes.</field>
			},
			__namespace: true
		},
	ThreeD: {
			Label3D: function () {
				/// <summary>Represents a text label in 3D scene.</summary>
				/// <field name="bottomLeft" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the bottom-left corner of label's layout rectangle.</field>
				/// <field name="font" type="MindFusion.Drawing.Font">Gets or sets the label's font.</field>
				/// <field name="rotationAngle" type="MindFusion.Charting.ThreeD.Number">Gets or sets the label's rotation angle.</field>
				/// <field name="text" type="String">Gets or sets the label's text.</field>
				/// <field name="topRight" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the top-right corner of label's layout rectangle.</field>
			},
			LabelProjection: function (label, projTL, projBR) {
				/// <summary>Represents the projection of a Label3D on the projection plane.</summary>
				/// <param name="label" type="Label3D">The projected Label3D.</param>
				/// <param name="projTL" type="Point3D">Projection of top-left corner of Label3D's layout rectangle.</param>
				/// <param name="projBR" type="Point3D">Projection of bottom-right corner of Label3D's layout rectangle.</param>
				/// <field name="label" type="MindFusion.Charting.ThreeD.Label3D">Gets ot sets the projected Label3D.</field>
				/// <field name="projectionBottomRight" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the projection of bottom-right corner of label's layout rectangle.</field>
				/// <field name="projectionTopLeft" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the projection of top-left corner of label's layout rectangle.</field>
				/// <field name="zSort" type="MindFusion.Charting.ThreeD.Number">Gets or sets a value by which projections are sorted in depth buffer.</field>
			},
			Matrix3D: function (width, height) {
				/// <summary>Represents a a mathematical matrix, specialized in 3D transformations.</summary>
				/// <param name="width" type="number">The width of the matrix.</param>
				/// <param name="height" type="number">The height of the matrix.</param>
			},
			Mesh3D: function (facePoints, brush, normals) {
				/// <summary>Represents a 3D mesh.</summary>
				/// <param name="facePoints" type="MindFusion.Charting.Collections.List<List<Point3D>>">Lists of points defining mesh faces.</param>
				/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The Brush used to paint this mesh.</param>
				/// <param name="normals" type="Array<Array<Vector3D>>" optional="true">Optional. An array with the normal vectors in each vertex.</param>
				/// <field name="faces" type="MindFusion.Charting.Collections.List<Polygon3D>">Gets or sets the mesh faces.</field>
			},
			Model3D: function (brush) {
				/// <summary>Represents a three-dimensional model.</summary>
				/// <param name="brush" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. The Brush used to fill this model's projection.</param>
			},
			Polygon3D: function (points, brush, normals) {
				/// <summary>Represents a polygon in 3D space.</summary>
				/// <param name="points" type="IEnumerable<Point3D>" optional="true">Optional. A list of 3D points.</param>
				/// <param name="brush" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. A Brush used to fill the polygon.</param>
				/// <param name="normals" type="Array<Vector3D>" optional="true">Optional. An array with the normal vectors in each vertex.</param>
				/// <field name="points" type="MindFusion.Charting.Collections.List<Point3D>">Gets or sets the polygon's vertices.</field>
				/// <field name="zSort" type="MindFusion.Charting.ThreeD.Number">Gets or sets a value by which projections are sorted in depth buffer.</field>
			},
			Scene3D: function () {
				/// <summary>Represents a 3D scene.</summary>
				/// <field name="cameraOrientation" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the camera orientation.</field>
				/// <field name="cameraPosition" type="MindFusion.Charting.ThreeD.Point3D">Gets or sets the camera position.</field>
				/// <field name="focalLength" type="MindFusion.Charting.ThreeD.Number">Gets or sets the camera focal length.</field>
				/// <field name="models" type="MindFusion.Charting.Collections.List<Model3D>">Gets or sets a list of models in this scene.</field>
				/// <field name="projections" type="MindFusion.Charting.Collections.List<Projection>">Gets or sets a list of projections in this scene.</field>
				/// <field name="viewportCenter" type="MindFusion.Drawing.Point">Gets or sets the viewport center.</field>
			},
			Vector3D: function () {
				/// <summary>Represents a three-dimensional vector.</summary>
				/// <field name="x" type="MindFusion.Charting.ThreeD.Number">Gets or sets the X component of this vector.</field>
				/// <field name="y" type="MindFusion.Charting.ThreeD.Number">Gets or sets the Y component of this vector.</field>
				/// <field name="z" type="MindFusion.Charting.ThreeD.Number">Gets or sets the Z component of this vector.</field>
			},
			__namespace: true
	},
	Components: {
			BorderComponent: function () {
				/// <summary>Represents a border UI component.</summary>
				/// <field name="borderBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw the border outlines.</field>
				/// <field name="borderThickness" type="MindFusion.Charting.Components.Number">Gets or sets the border thickness.</field>
				/// <field name="content" type="MindFusion.Charting.Components.Component">Gets or sets the Component displayed inside this border.</field>
				/// <field name="padding" type="MindFusion.Charting.Components.Number">Gets or sets the padding space between this border and its Content.</field>
			},
			ButtonComponent: function () {
				/// <summary>Represents a button UI component.</summary>
				/// <field name="content" type="MindFusion.Charting.Components.Component">Gets or sets the Component displayed inside this border.</field>
				/// <field name="padding" type="MindFusion.Charting.Components.Number">Gets or sets the padding space between this border and its Content.</field>
			},
			ButtonDrawEventArgs: function () {
				/// <summary>Contains arguments passed to the CustomDraw event of buttons.</summary>
				/// <field name="clipBounds" type="MindFusion.Drawing.Rect">Gets the current clip rectangle.</field>
				/// <field name="graphics" type="MindFusion.Charting.Drawing.Graphics">Gets the Graphics surface where the event handler should draw.</field>
			},
			ButtonDrawEventDispatcher: function () {
				/// <summary>Represents a dispatcher for ButtonDraw events.</summary>
			},
			Component: function () {
				/// <summary>Represents a user interface component.</summary>
				/// <field name="actualHeight" type="MindFusion.Charting.Components.Number">Gets a number value specifying the component's assigned height. Valid only after calling arrange.</field>
				/// <field name="actualWidth" type="MindFusion.Charting.Components.Number">Gets a number value specifying the component's assigned width. Valid only after calling arrange.</field>
				/// <field name="desiredHeight" type="MindFusion.Charting.Components.Number">Gets a nullable number value specifying the component's desired height. Valid only after calling measure.</field>
				/// <field name="desiredWidth" type="MindFusion.Charting.Components.Number">Gets a nullable number value specifying the component's desired width. Valid only after calling measure.</field>
				/// <field name="gridColumn" type="MindFusion.Charting.Components.Number">Gets or sets the column index of this component when placed inside a GridPanel.</field>
				/// <field name="gridRow" type="MindFusion.Charting.Components.Number">Gets or sets the row index of this component when placed inside a GridPanel.</field>
				/// <field name="height" type="MindFusion.Charting.Components.Number">Gets or sets a fixed height for this component.</field>
				/// <field name="hitTestVisibility" type="MindFusion.Charting.Components.HitTestVisibility">Gets or sets the hit-test visibility of this component.</field>
				/// <field name="horizontalAlignment" type="MindFusion.Charting.Components.LayoutAlignment">Gets or sets the horizontal alignment of this component inside the layout rectangle allocated by its parent panel.</field>
				/// <field name="margin" type="MindFusion.Charting.Components.Margins">Gets the margin space around this component relative to the layout rectangle allocated by its parent panel.</field>
				/// <field name="rectInParent" type="MindFusion.Charting.Components.Number">Gets the boundaries of this component relative to its parent.</field>
				/// <field name="toolTip" type="String">Gets or sets the component's tooltip text.</field>
				/// <field name="verticalAlignment" type="MindFusion.Charting.Components.LayoutAlignment">Gets or sets the vertical alignment of this component inside the layout rectangle allocated by its parent panel.</field>
				/// <field name="visibility" type="MindFusion.Charting.Components.Visibility">Gets or sets the visibility of this component.</field>
				/// <field name="width" type="MindFusion.Charting.Components.Number">Gets or sets a fixed width for this component.</field>
				/// <field name="xInParent" type="MindFusion.Charting.Components.Number">Gets a number value specifying the component's horizontal position relative to its parent.</field>
				/// <field name="yInParent" type="MindFusion.Charting.Components.Number">Gets a number value specifying the component's vertical position relative to its parent.</field>
			},
			ComponentVisitor: function () {
				/// <summary>Defines the base visitor class for hierarchy of Component objects.</summary>
			},
			GridColumn: function () {
				/// <summary>Represents a column in a GridPanel.</summary>
				/// <field name="lengthType" type="MindFusion.Charting.Components.LengthType">Gets or sets the column's sizing mode.</field>
				/// <field name="width" type="MindFusion.Charting.Components.Number">Gets or sets fixed width for this column.</field>
			},
			GridPanel: function () {
				/// <summary>Represents a layout panel that arranges its child components in a grid.</summary>
				/// <field name="columns" type="MindFusion.Charting.Collections.List<GridColumn>">Gets or sets a list of GridColumn objects specifying column attributes.</field>
				/// <field name="rows" type="MindFusion.Charting.Collections.List<GridRow>">Gets or sets a list of GridRow objects specifying row attributes.</field>
			},
			GridRow: function () {
				/// <summary>Represents a row in a GridPanel.</summary>
				/// <field name="height" type="MindFusion.Charting.Components.Number">Gets or sets fixed height for this row.</field>
				/// <field name="lengthType" type="MindFusion.Charting.Components.LengthType">Gets or sets the row's sizing mode.</field>
			},
			ImageComponent: function () {
				/// <summary>Represents a component that draws a bitmap image.</summary>
				/// <field name="autoSize" type="MindFusion.Charting.Components.Boolean">Gets or sets a value indicating whether the component should auto-size to match the dimensions of its Image.</field>
				/// <field name="imageAlign" type="MindFusion.Charting.Drawing.ImageAlign">Gets or sets the image alignment relative to the component.</field>
				/// <field name="location" type="String">Gets or sets Image by its file location.</field>
			},
			Panel: function () {
				/// <summary>Represents a component that contains multiple child components and manages their layout.</summary>
				/// <field name="children" type="MindFusion.Charting.Collections.ObservableCollection<Component>">Gets the list of child components of this panel.</field>
				/// <field name="parentControl" type="MindFusion.Charting.Components.RootControl">Gets or sets a reference to the control containing this panel.</field>
			},
			RangeSelector: function (axis, minValue, maxValue) {
				/// <summary>Represents a control that handles zooming and scrolling of axes.</summary>
				/// <param name="axis" type="void"></param>
				/// <param name="minValue" type="void"></param>
				/// <param name="maxValue" type="void"></param>
				/// <field name="axesSource" type="MindFusion.Charting.Components.SeriesContainer">Gets or sets the object whose Axes will be handled by this component.</field>
				/// <field name="axis" type="MindFusion.Charting.Components.Axis">Gets or sets the Axis that will be handled by this component.</field>
				/// <field name="brush" type="MindFusion.Charting.Components.Brush">Gets or sets the Brush used to paint the component's background.</field>
				/// <field name="handleBrush" type="MindFusion.Charting.Components.Brush">Gets or sets the Brush used to paint resize handles.</field>
				/// <field name="handleSize" type="MindFusion.Charting.Components.Number">Gets or sets the width or height of resize handles.</field>
				/// <field name="maxValue" type="MindFusion.Charting.Components.Number">Gets or sets the largest value of the displayed range.</field>
				/// <field name="minValue" type="MindFusion.Charting.Components.Number">Gets or sets the smallest value of the displayed range.</field>
				/// <field name="orientation" type="MindFusion.Charting.Components.Orientation">Gets or sets the orientation of the component.</field>
				/// <field name="size" type="MindFusion.Charting.Components.Number">Gets or sets the width or height of the component.</field>
				/// <field name="thumbBrush" type="MindFusion.Charting.Components.Brush">Gets or sets the Brush used to paint the thumb.</field>
			},
			SimplePanel: function () {
				/// <summary>Represents a layout panel that arranges its child components over each other.</summary>
			},
			StackPanel: function () {
				/// <summary>Represents a layout panel that arranges its child components in a stack.</summary>
				/// <field name="orientation" type="MindFusion.Charting.Components.Orientation">Gets or sets the stack orientation.</field>
			},
			TextComponent: function () {
				/// <summary>Represents a Component that draws text.</summary>
				/// <field name="fontName" type="String">Gets or sets the name of the font that should be used to draw the component's text.</field>
				/// <field name="fontSize" type="MindFusion.Charting.Components.Number">Gets or sets the size of the font that should be used to draw the component's text.</field>
				/// <field name="fontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of the font that should be used to draw the component's text.</field>
				/// <field name="styleHint" type="MindFusion.Charting.Components.TextStyleHint">Gets or sets a value indicating which attribute values this component should inherit from current Theme if its local text appearance properties are not set.</field>
				/// <field name="text" type="String">Gets or sets the text that should be drawn inside this component.</field>
				/// <field name="textBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw the component's text.</field>
			},
			__namespace: true
	},
	Collections: {
			Dictionary: function () {
				/// <summary>Represents a collection of keys and values.</summary>
			},
			IEnumerable: function (items) {
				/// <summary>Represents an array of arbitrary objects.</summary>
				/// <param name="items" type="Array<T>" optional="true">Optional. The underlying array data structure of the collection.</param>
			},
			List: function (items) {
				/// <summary>Represents an array of arbitrary objects.</summary>
				/// <param name="items" type="Array<T>" optional="true">Optional. The underlying array data structure of the list.</param>
			},
			ObservableCollection: function (items) {
				/// <summary>Represents a collection of arbitrary objects.</summary>
				/// <param name="items" type="Array<T>" optional="true">Optional. The underlying array data structure of the collection.</param>
			},
			__namespace: true
	},
	Drawing: {
			Brush: function (color) {
				/// <summary>Represents a brush.</summary>
				/// <param name="color" type="Color | string">The color of this brush.</param>
				/// <field name="color" type="MindFusion.Charting.Drawing.Color">Gets or sets the color of this Brush object.</field>
			},
			Color: function (value) {
				/// <summary>Represents a color.</summary>
				/// <param name="value" type="String">A string representation of the color.</param>
			},
			Font: function (name, size, fontStyle) {
				/// <summary>Represents a font.</summary>
				/// <param name="name" type="String">The font name.</param>
				/// <param name="size" type="Number">The font size.</param>
				/// <param name="fontStyle" type="MindFusion.Charting.Drawing.FontStyle" optional="true">Optional. The FontStyle</param>
				/// <field name="fontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of this Font.</field>
				/// <field name="name" type="String">Gets or sets the name of this Font.</field>
				/// <field name="size" type="MindFusion.Charting.Drawing.Number">Gets or sets the size of this Font.</field>
			},
			Graphics: function (context) {
				/// <summary>Contains helper functions for drawing on a Canvas element.</summary>
				/// <param name="context" type="CanvasRenderingContext2D">The CanvasRenderingContext2D drawing object.</param>
				/// <field name="context" type="MindFusion.Charting.Drawing.CanvasRenderingContext2D">Gets or sets the underlying CanvasRenderingContext2D drawing object.</field>
			},
			LinearGradientBrush: function (startColor, endColor, angle, bounds) {
				/// <summary>Represents a linear gradient brush.</summary>
				/// <param name="startColor" type="Color | string">The starting color of the gradient.</param>
				/// <param name="endColor" type="Color | string">The ending color of the gradient.</param>
				/// <param name="angle" type="Number" optional="true">Optional. The angle of the gradient.</param>
				/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. The bounds of the gradient.</param>
				/// <field name="angle" type="MindFusion.Charting.Drawing.Number">Gets or sets angle of gradient rotation.</field>
				/// <field name="endColor" type="MindFusion.Charting.Drawing.Color">Gets or sets the end color of the gradient.</field>
				/// <field name="startColor" type="MindFusion.Charting.Drawing.Color">Gets or sets the start color of the gradient.</field>
			},
			Pen: function (brush, width) {
				/// <summary>Represents a pen.</summary>
				/// <param name="brush" type="Brush | Color | string">The color of this pen.</param>
				/// <param name="width" type="Number" optional="true">Optional. The width of this pen.</param>
				/// <field name="color" type="MindFusion.Charting.Drawing.Color">Gets or sets the color of this Pen.</field>
				/// <field name="dashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the dash style of this Pen.</field>
				/// <field name="width" type="MindFusion.Charting.Drawing.Number">Gets or sets the width of this Pen.</field>
			},
			StringFormat: function () {
				/// <summary>Encapsulates text layout information.</summary>
				/// <field name="alignment" type="MindFusion.Charting.Drawing.StringAlignment">Gets or sets the horizontal alignment of the text.</field>
				/// <field name="lineAlignment" type="MindFusion.Charting.Drawing.StringAlignment">Gets or sets the vertical alignment of the text.</field>
			},
			__namespace: true
	},
	Commands: {
			Command: function (manager) {
				/// <summary>Represents an action that modifies an object and whose effects can be undone.</summary>
				/// <param name="manager" type="UndoManager">The UndoManager that contains this command.</param>
			},
			CompositeCommand: function (manager) {
				/// <summary>Represents a set of Command instances as a single operation.Undoing or redoing the composite action, respectively undoes orredoes all its constituent subactions at the same time.</summary>
				/// <param name="manager" type="UndoManager">The UndoManager that contains this command.</param>
			},
			DisposableCommand: function (manager) {
				/// <summary>Represents a command that implements the IDisposable interface.</summary>
				/// <param name="manager" type="UndoManager">The UndoManager that contains this command.</param>
			},
			TrackChangesCommand: function () {
				/// <summary>Represents a command that can track and undo changes ofINotifyPropertyValueChanged objects.</summary>
			},
			UndoEventArgs: function (command) {
				/// <summary>Contains the arguments passed to the ActionUndone and ActionRedone event handlers.</summary>
				/// <param name="command" type="Command">The Command related to the event.</param>
			},
			__namespace: true
	},
	Common: {
			EventDispatcher: function () {
				/// <summary>Represents a dispatcher for an event.</summary>
			},
			NotifyCollectionChangedEventArgs: function (action, changes, index) {
				/// <summary>Provides data for CollectionChanged events.</summary>
				/// <param name="action" type="NotifyCollectionChangedAction">The action that caused the event.</param>
				/// <param name="changes" type="Array" optional="true">Optional. The items affected by the change.</param>
				/// <param name="index" type="Number" optional="true">Optional. The index where the change occurred.</param>
			},
			NotifyCollectionChangedEventDispatcher: function () {
				/// <summary>Represents a dispatcher for NotifyCollectionChanged events.</summary>
			},
			NotifyCollectionChangingEventArgs: function (action, changes, index) {
				/// <summary>Provides data for CollectionChanging events.</summary>
				/// <param name="action" type="NotifyCollectionChangedAction">The action that caused the event.</param>
				/// <param name="changes" type="Array" optional="true">Optional. The items affected by the change.</param>
				/// <param name="index" type="Number" optional="true">Optional. The index where the change occurred.</param>
			},
			NotifyCollectionChangingEventDispatcher: function () {
				/// <summary>Represents a dispatcher for NotifyCollectionChanging events.</summary>
			},
			PropertyChangedEventArgs: function (propertyName) {
				/// <summary>Provides data for PropertyChanged events.</summary>
				/// <param name="propertyName" type="void"></param>
			},
			PropertyChangedEventDispatcher: function () {
				/// <summary>Represents a dispatcher for PropertyChanged events.</summary>
			},
			PropertyEventArgs: function (propertyName, oldValue, newValue) {
				/// <summary>Provides data for PropertyValueChanged events.</summary>
				/// <param name="propertyName" type="String">The name of the property that changed.</param>
				/// <param name="oldValue" type="Object">The old value of the property.</param>
				/// <param name="newValue" type="Object">The new value of the property.</param>
			},
			__namespace: true
	},
	AnnotationRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws annotations in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as annotations.</param>
	},
	AreaRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws each series as an area in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as areas.</param>
		/// <field name="areaOpacity" type="MindFusion.Charting.Number">Gets or sets the opacity of area polygons.</field>
	},
	AreaStackRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws stacked areas in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as stacked areas.</param>
	},
	Axis: function () {
		/// <summary>Represents an Axis range.</summary>
		/// <field name="interval" type="MindFusion.Charting.Number">Gets or sets the size of axis intervals.</field>
		/// <field name="maxValue" type="MindFusion.Charting.Number">Gets or sets the largest value displayed on this axis.</field>
		/// <field name="minValue" type="MindFusion.Charting.Number">Gets or sets the smallest value displayed on this axis.</field>
		/// <field name="numberFormat" type="String">Gets or sets the number format of coordinate labels.</field>
		/// <field name="title" type="String">Gets or sets the axis title.</field>
	},
	AxisInfo: function () {
		/// <summary>Stores information about Axis ranges processed by this controller.</summary>
		/// <field name="origin" type="MindFusion.Charting.Number">The axis origin.</field>
		/// <field name="range" type="MindFusion.Charting.Number">The axis range.</field>
		/// <field name="resolution" type="MindFusion.Charting.Number">The axis resolution.</field>
	},
	AxisRenderer: function (axis) {
		/// <summary>A base class for components that render Axis ranges.</summary>
		/// <param name="axis" type="MindFusion.Charting.Axis">The Axis that will be drawn by this object.</param>
		/// <field name="axis" type="MindFusion.Charting.Axis">Gets or sets the Axis that will be drawn by this object.</field>
		/// <field name="axisStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw axis lines.</field>
		/// <field name="axisStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the dash style axis lines should be stroked with.</field>
		/// <field name="axisStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness axis lines should be stroked with.</field>
		/// <field name="labelBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw axis labels.</field>
		/// <field name="labelFontName" type="String">Gets or sets the name of font that should be used to draw axis labels.</field>
		/// <field name="labelFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font that should be used to draw axis labels.</field>
		/// <field name="labelFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font that should be used to draw axis labels.</field>
		/// <field name="labelPadding" type="MindFusion.Charting.Number">Gets or sets the padding space between the axis line and coordinate labels.</field>
		/// <field name="labelRotationAngle" type="MindFusion.Charting.Number">Gets or sets the rotation angle of the labels.</field>
		/// <field name="labelsSource" type="MindFusion.Charting.SeriesContainer">Gets or sets the object whose Series labels should be rendered along this axis.</field>
		/// <field name="pinLabels" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether coordinate labels should be pinned in place or scroll together with the plot when users pan it.</field>
		/// <field name="showCoordinates" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether this AxisRenderer should draw axis coordinates.</field>
		/// <field name="showSeriesLabels" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether this AxisRenderer should draw data labels.</field>
		/// <field name="showTicks" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether this AxisRenderer should draw axis ticks.</field>
		/// <field name="titleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw the axis Title.</field>
		/// <field name="titleFontName" type="String">Gets or sets the name of font that should be used to draw the axis Title.</field>
		/// <field name="titleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font that should be used to draw the axis Title.</field>
		/// <field name="titleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font that should be used to draw the axis Title.</field>
	},
	BarOverlayRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws overlaying bars in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as overlaying bars.</param>
		/// <field name="barSpacingRatio" type="MindFusion.Charting.Number">Gets or sets the ratio of empty space between adjacent bar groups to space occupied by bars.</field>
		/// <field name="horizontalBars" type="MindFusion.Charting.Boolean">Gets or sets a value identifying whether bars should be horizontal.</field>
	},
	BarOverlayRenderer3D: function (series) {
		/// <summary>A SeriesRenderer that draws a row of 3D bars for each series.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as rows of bars.</param>
	},
	BarRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws bars in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as bars.</param>
		/// <field name="barSpacingRatio" type="MindFusion.Charting.Number">Gets or sets the ratio of empty space between adjacent bar groups to space occupied by bars.</field>
		/// <field name="horizontalBars" type="MindFusion.Charting.Boolean">Gets or sets a value identifying whether bars should be horizontal.</field>
		/// <field name="innerLabelRotation" type="MindFusion.Charting.Number">Gets the rotation angle of inner labels. If not specified, labels are rotated at predefiend angles depending on bars' orientation and layout.</field>
		/// <field name="outerLabelRotation" type="MindFusion.Charting.Number">Gets the rotation angle of outer labels. If not specified, labels are rotated at predefiend angles depending on bars' orientation and layout.</field>
		/// <field name="sameIndexSpacingRatio" type="MindFusion.Charting.Number">Gets or sets the ratio of empty space to occupied space in bar groups drawn for data items as same index in each series.</field>
		/// <field name="stackOuterLabels" type="MindFusion.Charting.Boolean">Gets whether outer labels are displayed stacked on top of stacked bars, instead of showing them on the bar sides.</field>
	},
	BarRenderer3D: function (series) {
		/// <summary>A SeriesRenderer that draws 3D bars in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as 3D bars.</param>
	},
	BarSeries: function (values, innerLabels, topLabels, xAxisLabels) {
		/// <summary>Represents one-dimensional series defined by e list of data valuesand several lists of labels.</summary>
		/// <param name="values" type="MindFusion.Charting.Collections.List<Number> | Array<Nuber>">A list of data values.</param>
		/// <param name="innerLabels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of inner labels.</param>
		/// <param name="topLabels" type="MindFusion.Charting.Collections.List<String> | Array<String>" optional="true">Optional. A list of top labels.</param>
		/// <param name="xAxisLabels" type="MindFusion.Charting.Collections.List<String> | Array<String>" optional="true">Optional. A list of X axis labels.</param>
		/// <field name="innerLabels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the inner labels.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">SimpleSeries.SupportedLabels override. Returns a combination of InnerLabel, OuterLabel and XAxisLabel.</field>
		/// <field name="topLabels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the top labels.</field>
		/// <field name="xAxisLabels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the X axis labels.</field>
	},
	BarStackRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws stacked bars in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as stacked bars.</param>
		/// <field name="barSpacingRatio" type="MindFusion.Charting.Number">Gets or sets the ratio of empty space between adjacent bar groups to space occupied by bars.</field>
		/// <field name="horizontalBars" type="MindFusion.Charting.Boolean">Gets or sets a value identifying whether bars should be horizontal.</field>
	},
	BarStackRenderer3D: function (series) {
		/// <summary>A SeriesRenderer that draws stacked 3D bars in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as stacked bars.</param>
	},
	BubbleRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws bubbles representing data items in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as bubbles.</param>
		/// <field name="labelAlignment" type="MindFusion.Charting.BubbleLabelAlignment">Gets or sets the label alignment.</field>
	},
	CandlestickRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws candlesticks in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
		/// <field name="candlestickWidth" type="MindFusion.Charting.Number">Gets or sets the width of the candlesticks.</field>
		/// <field name="closeDimension" type="MindFusion.Charting.Number">Gets or sets the index of the dimension, containing close values.</field>
		/// <field name="highDimension" type="MindFusion.Charting.Number">Gets or sets the index of the dimension, containing high values.</field>
		/// <field name="lowDimension" type="MindFusion.Charting.Number">Gets or sets the index of the dimension, containing low values.</field>
		/// <field name="openDimension" type="MindFusion.Charting.Number">Gets or sets the index of the dimension, containing open values.</field>
	},
	CandlestickSeriesStyle: function (risingBrush, fallingBrush, stroke, strokeThickness, strokeDashStyle, renderer) {
		/// <summary>Defines appearance attributes for candlestick charts.</summary>
		/// <param name="risingBrush" type="void"></param>
		/// <param name="fallingBrush" type="void"></param>
		/// <param name="stroke" type="void"></param>
		/// <param name="strokeThickness" type="void"></param>
		/// <param name="strokeDashStyle" type="void"></param>
		/// <param name="renderer" type="void"></param>
		/// <field name="fallingBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to fill candlesticks, which open value is greater than its close value.</field>
		/// <field name="risingBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to fill candlesticks, which open value is smaller or equal to its close value.</field>
	},
	CurveAreaRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws each series as an area with curved boundaries in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as areas.</param>
	},
	CurveAreaStackRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws stacked areas in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as stacked areas.</param>
	},
	CurveRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws series as a cardinal spline.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as a cardinal spline.</param>
	},
	DataBoundSeries: function (dataSource) {
		/// <summary>Represents a series whose data items are retrieved from a data source.</summary>
		/// <param name="dataSource" type="any | Array<any> | IEnumerable<any>">A reference to the data source object.</param>
		/// <field name="dataSource" type="MindFusion.Charting.any">Gets or sets the data source this series is bound to.</field>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns the number of X/Y/ZDataField properties set.</field>
		/// <field name="innerLabelsDataField" type="String">Gets or sets the name of inner labels data field in the data source.</field>
		/// <field name="outerLabelsDataField" type="String">Gets or sets the name of inner labels data field in the data source.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Gets the number of data items in the data source.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Result depends on which *LabelsDataField properties are set.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
		/// <field name="toolTipsDataField" type="String">Gets or sets the name of tooltips data field in the data source.</field>
		/// <field name="xAxisLabelsDataField" type="String">Gets or sets the name of X axis labels data field in the data source.</field>
		/// <field name="xDataField" type="String">Gets or sets the name of X data field in the data source.</field>
		/// <field name="yAxisLabelsDataField" type="String">Gets or sets the name of Y axis labels data field in the data source.</field>
		/// <field name="yDataField" type="String">Gets or sets the name of Y data field in the data source.</field>
		/// <field name="zAxisLabelsDataField" type="String">Gets or sets the name of Z axis labels data field in the data source.</field>
		/// <field name="zDataField" type="String">Gets or sets the name of Z data field in the data source.</field>
	},
	DateTimeSeries: function (dates, values, minDate, maxDate) {
		/// <summary>Represents a series that contains Date values as X coordinates and number values as Y coordinates.</summary>
		/// <param name="dates" type="MindFusion.Charting.Collections.List<Date> | Array<Date>">A list of Date values.</param>
		/// <param name="values" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of number values.</param>
		/// <param name="minDate" type="Date">Identifies the start of the time range.</param>
		/// <param name="maxDate" type="Date">Identifies the end of the time range.</param>
		/// <field name="customDateTimeFormat" type="String">Gets or sets a custom format string for Date labels.</field>
		/// <field name="dates" type="MindFusion.Charting.Collections.List<Date>">Gets or sets a list of Date values used as X coordinates of this series.</field>
		/// <field name="dateTimeFormat" type="String">Gets or sets a value indicating how to format Date values as labels.</field>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 2.</field>
		/// <field name="labelPrefix" type="String">Gets or sets a prefix added in front of formatted Date labels.</field>
		/// <field name="labelSuffix" type="String">Gets or sets a suffix appended to formatted Date labels.</field>
		/// <field name="maxDate" type="MindFusion.Charting.Date">Gets or sets the end of the time range.</field>
		/// <field name="maxValue" type="MindFusion.Charting.Number">Gets or sets the coordinate corresponding to MaxDate.</field>
		/// <field name="minDate" type="MindFusion.Charting.Date">Gets or sets the start of the time range.</field>
		/// <field name="minValue" type="MindFusion.Charting.Number">Gets or sets the coordinate corresponding to MinDate.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements provided in Date list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns LabelKinds.XAxisLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
	},
	FunnelRenderer: function (series, dimension) {
		/// <summary>A SeriesRenderer that is used to represent stages in a sales processand show the amount of potential revenue for each stage.</summary>
		/// <param name="series" type="Series">The Series that should be rendered as a funnel.</param>
		/// <param name="dimension" type="Number" optional="true">Optional. Specifies the Series dimension index that should be used to access data.</param>
		/// <field name="dimension" type="MindFusion.Charting.Number">Gets or sets the dimension index that should be used to read data from the Series.</field>
		/// <field name="segmentSpacing" type="MindFusion.Charting.Number">Gets or sets the spacing between segments.</field>
		/// <field name="series" type="MindFusion.Charting.Series">Gets or sets the Series drawn by this FunnelRenderer.</field>
		/// <field name="stemWidth" type="MindFusion.Charting.Number">Gets or sets the width of the funnel stem.</field>
	},
	HitResult: function (renderer, index, value, series) {
		/// <summary>Represents the result of a hit-test operation.</summary>
		/// <param name="renderer" type="SeriesRenderer">A SeriesRenderer whose data item has been hit.</param>
		/// <param name="index" type="Number">An integer index of the data item.</param>
		/// <param name="value" type="Number">The item's vaue.</param>
		/// <param name="series" type="Series">The Series that contains the found item.</param>
		/// <field name="index" type="MindFusion.Charting.Number">Gets or sets the data item index within its Series.</field>
		/// <field name="plot" type="MindFusion.Charting.Plot">Gets or sets the Plot that has been hit.</field>
		/// <field name="renderer" type="MindFusion.Charting.SeriesRenderer">Gets or sets the SeriesRenderer that has been hit.</field>
		/// <field name="series" type="MindFusion.Charting.Series">Gets or sets the Series that has been hit.</field>
		/// <field name="value" type="MindFusion.Charting.Number">Gets or sets the data item value.</field>
	},
	LegendController: function (renderContext) {
		/// <summary>Lets users move a legend within the boundaries of its parent Panel.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	LegendRenderer: function () {
		/// <summary>A component that renders chart legend.</summary>
		/// <field name="allowMove" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether users are allowed to move this legend.</field>
		/// <field name="background" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to fill the background of this legend.</field>
		/// <field name="borderStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to stroke the borders of this legend.</field>
		/// <field name="borderStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the stroke dash style of legend borders.</field>
		/// <field name="borderStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the stroke thickness of legend borders.</field>
		/// <field name="content" type="MindFusion.Charting.Collections.ObservableCollection<SeriesRenderer>">Gets or sets a list of SeriesRenderer objects whose Series should be displayed in this legend.</field>
		/// <field name="elementLabelKind" type="MindFusion.Charting.LabelKinds">Gets or sets the type of label to show for series elements. This property is used only when showSeriesElements is set to true.</field>
		/// <field name="maxItemsPerColumn" type="MindFusion.Charting.Number">Gets or sets the maximum number ot items per display column.</field>
		/// <field name="padding" type="MindFusion.Charting.Number">Gets or sets the padding space between content and borders of this legend.</field>
		/// <field name="showSeriesElements" type="MindFusion.Charting.Boolean">Gets or sets a value, indicatating whether this legend will display individual series element labels instead of the series titles.</field>
		/// <field name="showTitle" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether to display the legend title.</field>
		/// <field name="spacing" type="MindFusion.Charting.Number">Gets or sets the distance between adjacent entries in the legend.</field>
		/// <field name="title" type="String">Gets or sets the legend's title.</field>
		/// <field name="titleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw the legend's Title.</field>
		/// <field name="titleFontName" type="String">Gets or sets the name of font that should be used to draw the legend's Title.</field>
		/// <field name="titleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font that should be used to draw the legend's Title.</field>
		/// <field name="titleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font that should be used to draw the legend's Title.</field>
	},
	LineRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws series as polylines.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as polylines.</param>
	},
	Margins: function (left, top, right, bottom) {
		/// <summary>Describes rectangular margins.</summary>
		/// <param name="left" type="void"></param>
		/// <param name="top" type="void"></param>
		/// <param name="right" type="void"></param>
		/// <param name="bottom" type="void"></param>
		/// <field name="bottom" type="MindFusion.Charting.Number">Gets or sets the width of the bottom side of the frame.</field>
		/// <field name="height" type="MindFusion.Charting.Number">Returns the sum of Top and Bottom margins.</field>
		/// <field name="left" type="MindFusion.Charting.Number">Gets or sets the width of the left side of the frame.</field>
		/// <field name="right" type="MindFusion.Charting.Number">Gets or sets the width of the right side of the frame.</field>
		/// <field name="top" type="MindFusion.Charting.Number">Gets or sets the width of the top side of the frame.</field>
		/// <field name="width" type="MindFusion.Charting.Number">Returns the sum of Left and Right margins.</field>
	},
	MixedSeriesStyle: function (fill, stroke, strokeThickness, strokeDashStyle) {
		/// <summary>Implements SeriesStyle using mixed per-element and uniform values for attributes.</summary>
		/// <param name="fill" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. A Brush used to fill all series elements.</param>
		/// <param name="stroke" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. A Brush used to stroke all series elements.</param>
		/// <param name="strokeThickness" type="Number" optional="true">Optional. Uniform thickness of series elements' strokes.</param>
		/// <param name="strokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle" optional="true">Optional. Uniform dash style of series elements' strokes.</param>
		/// <field name="commonFills" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of brushes, each Brush used to fill all elements of a series.</field>
		/// <field name="commonStrokeDashStyles" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets a list of dash styles, each style applied to all elements of a series.</field>
		/// <field name="commonStrokes" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of brushes, each Brush used to stroke all elements of a series.</field>
		/// <field name="commonStrokeThicknesses" type="MindFusion.Charting.Number">Gets or sets a list of stroke thicknesses, each thickness applied to all elements of a series.</field>
		/// <field name="fills" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to draw a different series, and each Brush used to fill individual elements of a series.</field>
		/// <field name="strokeDashStyles" type="MindFusion.Charting.Collections.List<List<DashStyle>>">Gets or sets a list of DashStyle lists, each list used to stroke a different series, and each DashStyle value specifying style of individual elements of a series.</field>
		/// <field name="strokes" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to stroke a different series, and each Brush used to stroke individual elements of a series.</field>
		/// <field name="strokeThicknesses" type="MindFusion.Charting.Collections.List<List<number>>">Gets or sets a list of number lists, each list used to stroke a different series, and each number value specifying thickness of individual elements of a series.</field>
		/// <field name="uniformFill" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to fill all elements of all series uniformly.</field>
		/// <field name="uniformStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke all elements of all series uniformly.</field>
		/// <field name="uniformStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets uniform stroke dash style for all elements of all series.</field>
		/// <field name="uniformStrokeThickness" type="MindFusion.Charting.Number">Gets or sets uniform stroke thickness for all elements of all series.</field>
	},
	Pair: function (first, second) {
		/// <summary>Contains two values.</summary>
		/// <param name="first" type="void">The first value.</param>
		/// <param name="second" type="void">The second value.</param>
		/// <field name="first" type="MindFusion.Charting.T1">Gets or sets the first value.</field>
		/// <field name="second" type="MindFusion.Charting.T1">Gets or sets the second value.</field>
	},
	PanController: function (renderContext, vertical) {
		/// <summary>Represents a controller that pans its plot's data range.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="vertical" type="Boolean">true to implement interaction along the Y axis, or false for the X axis.</param>
		/// <field name="enableAnimation" type="MindFusion.Charting.Boolean">Gets or sets whether to enable pan inertia.</field>
	},
	PanControllerAnimation: function () {
		/// <summary>Represents a controller that pans its plot's data range.</summary>
	},
	PerElementSeriesStyle: function (fills, strokes, strokeThicknesses, strokeDashStyles) {
		/// <summary>Implements SeriesStyle using different attributes for each data item.</summary>
		/// <param name="fills" type="MindFusion.Charting.Collections.List<List<Brush>>" optional="true">Optional. A list of Brush lists, each list used to draw a different series,and each Brush used to fill individual elements of a series.</param>
		/// <param name="strokes" type="MindFusion.Charting.Collections.List<List<Brush>>" optional="true">Optional. A list of Brush lists, each list used to stroke a different series,and each Brush used to stroke individual elements of a series.</param>
		/// <param name="strokeThicknesses" type="MindFusion.Charting.Collections.List<List<Number>>" optional="true">Optional. A list of number lists, each list used to stroke a different series,and each number value specifying thickness of individual elements of a series.</param>
		/// <param name="strokeDashStyles" type="MindFusion.Charting.Collections.List<List<DashStyle>>" optional="true">Optional. A list of DashStyle lists, each list used to stroke a different series,and each DashStyle value specifying style of individual elements of a series.</param>
		/// <field name="fills" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to draw a different series, and each Brush used to fill individual elements of a series.</field>
		/// <field name="strokeDashStyles" type="MindFusion.Charting.Collections.List<List<DashStyle>>">Gets or sets a list of DashStyle lists, each list used to stroke a different series, and each DashStyle value specifying style of individual elements of a series.</field>
		/// <field name="strokes" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to stroke a different series, and each Brush used to stroke individual elements of a series.</field>
		/// <field name="strokeThicknesses" type="MindFusion.Charting.Collections.List<List<number>>">Gets or sets a list of number lists, each list used to stroke a different series, and each number value specifying thickness of individual elements of a series.</field>
	},
	PerSeriesStyle: function (fills, strokes, strokeThicknesses, strokeDashStyles) {
		/// <summary>Implements SeriesStyle using a different set of attributes for each series,where all elements in a single series have common appearance.</summary>
		/// <param name="fills" type="MindFusion.Charting.Collections.List<Brush>" optional="true">Optional. A list of Brushes, each Brush used to fill all elements of a series.</param>
		/// <param name="strokes" type="MindFusion.Charting.Collections.List<Brush>" optional="true">Optional. A list of Brushes, each Brush used to stroke all elements of a series.</param>
		/// <param name="strokeThicknesses" type="MindFusion.Charting.Collections.List<Number>" optional="true">Optional. A list of stroke thicknesses, each thickness applied to all elements of a series.</param>
		/// <param name="strokeDashStyles" type="MindFusion.Charting.Collections.List<DashStyle>" optional="true">Optional. A list of dash styles, each style applied to all elements of a series.</param>
		/// <field name="fills" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of Brushes, each Brush used to fill all elements of a series.</field>
		/// <field name="strokeDashStyles" type="MindFusion.Charting.Collections.List<DashStyle>">Gets or sets a list of dash styles, each style applied to all elements of a series.</field>
		/// <field name="strokes" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of Brushes, each Brush used to stroke all elements of a series.</field>
		/// <field name="strokeThicknesses" type="MindFusion.Charting.Collections.List<Number>">Gets or sets a list of stroke thicknesses, each thickness applied to all elements of a series.</field>
	},
	PieRadarRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws pie-radars, where data items are representedby circular sectors of equal central angles, and the sector corresponding to a data item has radius proportional to its value.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
		/// <field name="alignToAxis" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether sectors should be aligned to axes in the radar grid or centered around them.</field>
	},
	PieRenderer: function (series, dimension) {
		/// <summary>A SeriesRenderer that draws pies in its containing plot.</summary>
		/// <param name="series" type="Series">The Series that should be rendered as a pie.</param>
		/// <param name="dimension" type="Number" optional="true">Optional. Specifies the Series dimension index that should be used to access data.</param>
		/// <field name="dimension" type="MindFusion.Charting.Number">Gets or sets the dimension index that should be used to read data from the Series.</field>
		/// <field name="doughnut" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether the pie should be rendered as a doughnut.</field>
		/// <field name="series" type="MindFusion.Charting.Series">Gets or sets the Series drawn by this PieRenderer.</field>
	},
	PieSeries: function (values, innerLabels, outerLabels) {
		/// <summary>Represents one-dimensional series defined by e list of data values and lists ofinner and outer labels, convenient for providing data to PieRenderer.</summary>
		/// <param name="values" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of data values.</param>
		/// <param name="innerLabels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of inner labels.</param>
		/// <param name="outerLabels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of outer labels.</param>
		/// <field name="detachedSlices" type="MindFusion.Charting.Collections.List<Number>">Gets or sets indices of detached slices.</field>
		/// <field name="outerLabels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the outer labels.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns a combination of InnerLabel and OuterLabel.</field>
	},
	Plot: function () {
		/// <summary>The base class for components used to draw chart graphics.</summary>
		/// <field name="background" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to fill the background of this plot.</field>
		/// <field name="borderStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to stroke the borders of this plot.</field>
		/// <field name="borderStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the stroke dash style of plot borders.</field>
		/// <field name="borderStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the stroke thickness of plot borders.</field>
		/// <field name="highlightedItem" type="MindFusion.Charting.HitResult">Gets or sets the data item that should be drawn highlighted.</field>
		/// <field name="highlightStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to stroke highlighted item.</field>
		/// <field name="highlightStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the stroke dash style of highlighted item.</field>
		/// <field name="highlightStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the stroke thickness of highlighted item.</field>
		/// <field name="seriesRenderers" type="MindFusion.Charting.Collections.ObservableCollection<SeriesRenderer>">Gets or sets the SeriesRenderer objects that should draw inside this plot.</field>
		/// <field name="seriesStyle" type="MindFusion.Charting.SeriesStyle">Gets or sets a SeriesStyle whose attributes should be used to draw series inside this plot, unless their own renderers have a local SeriesStyle value set for respetive attribute.</field>
	},
	Plot2D: function () {
		/// <summary>A plot whose series are rendered relatively to a two-dimensional Cartesian coordinate system.</summary>
		/// <field name="allowPan" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether users are allowed to pan this plot.</field>
		/// <field name="gridColor1" type="MindFusion.Charting.Drawing.Color">Gets or sets the main color of the grid.</field>
		/// <field name="gridColor2" type="MindFusion.Charting.Drawing.Color">Gets or sets the alternating color of the grid.</field>
		/// <field name="gridType" type="MindFusion.Charting.GridType">Gets or sets the type of grid to draw in this plot.</field>
		/// <field name="isZoomed" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether the user has zoomed into this plot.</field>
		/// <field name="pinGrid" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether grid stripes should be pinned in place or scroll together with the plot when users pan it.</field>
		/// <field name="verticalScroll" type="MindFusion.Charting.Boolean">Specifies whether the plot should scroll vertically when panned.</field>
		/// <field name="xAxis" type="MindFusion.Charting.Axis">Gets or sets default Axis instance used to map X data coordinates of series rendered inside this plot to the plot's pixels.</field>
		/// <field name="yAxis" type="MindFusion.Charting.Axis">Gets or sets default Axis instance used to map Y data coordinates of series rendered inside this plot to the plot's pixels.</field>
	},
	Plot2DController: function (renderContext, vertical) {
		/// <summary>A base class for controllers that let users interact with Plot2D objects.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="vertical" type="Boolean">true to implement interaction along the Y axis, or false for the X axis.</param>
		/// <field name="axisRanges" type="MindFusion.Charting.Dictionary<Axis, AxisInfo>">Contains information about Axis ranges processed by this controller.</field>
		/// <field name="vertical" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether interaction is done along the X or Y axis.</field>
	},
	Plot3D: function () {
		/// <summary>A plot whose series are rendered relatively to a three-dimensional Cartesian coordinate system.</summary>
		/// <field name="zAxis" type="MindFusion.Charting.Axis">Gets or sets default Axis instance used to map Z data coordinates of series rendered inside this plot to the plot's pixels.</field>
	},
	PlotController: function (renderContext) {
		/// <summary>A base class for controllers implementing user interaction with Plot components.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <field name="component" type="MindFusion.Charting.Component">Gets the component controlled by this PlotController.</field>
	},
	Point3D: function (x, y, z) {
		/// <summary>Represents a point in 3D space.</summary>
		/// <param name="x" type="Number">X coordinate of the point.</param>
		/// <param name="y" type="Number">Y coordinate of the point.</param>
		/// <param name="z" type="Number">Z coordinate of the point.</param>
		/// <field name="x" type="MindFusion.Charting.Number">Gets or sets the X coordinate of this point.</field>
		/// <field name="y" type="MindFusion.Charting.Number">Gets or sets the Y coordinate of this point.</field>
		/// <field name="z" type="MindFusion.Charting.Number">Gets or sets the Z coordinate of this point.</field>
	},
	PointSeries: function (points, labels) {
		/// <summary>Represents a data series defined by a list of Point objects.</summary>
		/// <param name="points" type="MindFusion.Charting.Collections.List<Point> | Array<Point>">A list of points.</param>
		/// <param name="labels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of labels.</param>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 2.</field>
		/// <field name="labels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the data labels.</field>
		/// <field name="points" type="MindFusion.Charting.Collections.List<Point>">Gets or sets the series' points.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in Points list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns InnerLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
	},
	PointSeries3D: function (points, labels) {
		/// <summary>Represents a data series defined by a list of Point3D objects.</summary>
		/// <param name="points" type="MindFusion.Charting.Collections.List<Point3D> | Array<Point3D>">A list of 3D points.</param>
		/// <param name="labels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of labels.</param>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 3.</field>
		/// <field name="labels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the data labels.</field>
		/// <field name="points" type="MindFusion.Charting.Collections.List<Point3D>">Gets or sets the series' points.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in Points list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns InnerLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
	},
	PolarPlot: function () {
		/// <summary>A plot used to draw graphics in polar coordinate system.</summary>
		/// <field name="allowRotate" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether users are allowed to rotate this plot.</field>
		/// <field name="padding" type="MindFusion.Charting.Number">Gets or set padding space between the plot's border and series graphics.</field>
		/// <field name="startAngle" type="MindFusion.Charting.Number">Gets or set the angle where first data item of series should be drawn.</field>
	},
	RadarAxisOptions: function (axis) {
		/// <summary>Provides properties for customizing axis rendering in radar charts.</summary>
		/// <param name="axis" type="void"></param>
	},
	RadarPlot: function () {
		/// <summary>A plot containing radar-chart graphics.</summary>
		/// <field name="axes" type="MindFusion.Charting.Collections.ObservableCollection<Axis>">Gets the list of Axis objects representing ranges of variables represented in the radar chart.</field>
		/// <field name="axisOptions" type="MindFusion.Charting.RadarAxisOptions">Gets a RadarAxisOptions object providing properties for customizing axis rendering in radar charts.</field>
		/// <field name="defaultAxis" type="MindFusion.Charting.Axis">ets a default Axis object used when data item index does not have corresponding element in the Axes collection.</field>
		/// <field name="gridColor1" type="MindFusion.Charting.Drawing.Color">Gets or sets the main color of the grid.</field>
		/// <field name="gridColor2" type="MindFusion.Charting.Drawing.Color">Gets or sets the alternating color of the grid.</field>
		/// <field name="gridDivisions" type="MindFusion.Charting.Number">Gets the number of concentric shapes to draw in the grid.</field>
		/// <field name="gridType" type="MindFusion.Charting.RadarGridType">Gets or sets the type of grid to draw in this plot.</field>
		/// <field name="showCoordinates" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether the grid should display axis coordinates.</field>
		/// <field name="uniformScale" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether all axes should display same data range.</field>
	},
	RadarRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws series as polygons in polar coordinate system,where adjacent data points are at equal angular distances and radialcoordinates correspond to magnitude of data item values.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
		/// <field name="areaOpacity" type="MindFusion.Charting.Number">Gets or sets the opacity of radar polygons.</field>
		/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">Gets or sets a list of Series drawn by this RadarRenderer.</field>
	},
	RadarScatterRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws scatter in radar plots.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as scatter.</param>
	},
	RenderContext: function (clipRect, theme) {
		/// <summary>Provides contextual information about the dashboard to its child componentswhen calling their draw, layout and user input methods.</summary>
		/// <param name="clipRect" type="Rect">A Rect specifying the clip rectangle.</param>
		/// <param name="theme" type="Theme">A Theme instance where appearance attributes should be derived from.</param>
		/// <field name="graphics" type="MindFusion.Charting.Drawing.Graphics">Gets or sets the current drawing surface.</field>
		/// <field name="theme" type="MindFusion.Charting.Theme">Gets or sets the Theme used to resolve appearance attributes.</field>
		/// <field name="xAxis" type="MindFusion.Charting.Axis">Gets the chart's XAxis.</field>
		/// <field name="yAxis" type="MindFusion.Charting.Axis">Gets the chart's YAxis.</field>
	},
	RenderContext2D: function (clipRect, theme) {
		/// <summary>Provides contextual information about the dashboard to its child componentswhen calling their draw, layout and user input methods.</summary>
		/// <param name="clipRect" type="void">A RectD specifying the clip rectangle.</param>
		/// <param name="theme" type="void">A Theme instance where appearance attributes should be derived from.</param>
		/// <field name="chart" type="MindFusion.Charting.BiaxialChart">Gets the chart.</field>
		/// <field name="xAxis" type="MindFusion.Charting.Axis">Gets the chart's XAxis.</field>
		/// <field name="yAxis" type="MindFusion.Charting.Axis">Gets the chart's YAxis.</field>
	},
	Renderer2D: function (series) {
		/// <summary>A base class for series renderers that draw in two dimensional Cartesian coordinate system.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
		/// <field name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">Gets or sets a list of Series drawn by this Renderer2D.</field>
		/// <field name="xAxis" type="MindFusion.Charting.Axis">Gets the X axis associated with this Renderer2D.</field>
		/// <field name="yAxis" type="MindFusion.Charting.Axis">Gets the Y axis associated with this Renderer2D.</field>
	},
	RotationController: function (renderContext) {
		/// <summary>Represents a controller that rotates a polar plot by changing its StartAngle.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <field name="enableAnimation" type="MindFusion.Charting.Boolean">Gets or sets whether to enable rotation inertia.</field>
	},
	RotationControllerAnimation: function () {
		/// <summary>Represents a controller that rotates a polar plot by changing its StartAngle.</summary>
	},
	ScatterRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws scatter in its containing plot.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered as scatter.</param>
		/// <field name="shape" type="MindFusion.Charting.ScatterType">Gets or sets the type of scatter shapes.</field>
		/// <field name="shapeSize" type="MindFusion.Charting.Number">Gets or sets the size of scatter shapes.</field>
	},
	Series2D: function (xValues, yValues, labels) {
		/// <summary>Represents a data series defined by two lists of values containingrespectively X and Y coordinates.</summary>
		/// <param name="xValues" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of X coordinates.</param>
		/// <param name="yValues" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of Y coordinates.</param>
		/// <param name="labels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of labels.</param>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 2.</field>
		/// <field name="labels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the data labels.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in XData list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Gets or sets the kind of labels reported as supported by this series.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
		/// <field name="xData" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the X coordinates of data items.</field>
		/// <field name="yData" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the Y coordinates of data items.</field>
	},
	Series3D: function (xValues, yValues, zValues, labels) {
		/// <summary>Represents a data series defined by three lists of values containingrespectively X, Y and Z coordinates.</summary>
		/// <param name="xValues" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of X coordinates.</param>
		/// <param name="yValues" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of Y coordinates.</param>
		/// <param name="zValues" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of Z coordinates.</param>
		/// <param name="labels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of labels.</param>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 3.</field>
		/// <field name="labels" type="MindFusion.Charting.Collections.List<String>">Gets or sets the data labels.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in XData list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns InnerLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
		/// <field name="xData" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the X coordinates of data items.</field>
		/// <field name="yData" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the Y coordinates of data items.</field>
		/// <field name="zData" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the Z coordinates of data items.</field>
	},
	SeriesRenderer: function () {
		/// <summary>Base class for renderer objects that draw data series inside a Plot.</summary>
		/// <field name="labelBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush that should be used to draw labels of data items.</field>
		/// <field name="labelFontName" type="String">Gets or sets the name of font that should be used to draw labels of data items.</field>
		/// <field name="labelFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font that should be used to draw labels of data items.</field>
		/// <field name="labelFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font that should be used to draw labels of data items.</field>
		/// <field name="seriesStyle" type="MindFusion.Charting.SeriesStyle">A SeriesStyle instance specifying the appearance of series associated with this renderer.</field>
		/// <field name="showDataLabels" type="MindFusion.Charting.Boolean">Gets or sets the kind of data labels to draw.</field>
		/// <field name="showHighlight" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether to show highlights on data items.</field>
		/// <field name="showToolTips" type="MindFusion.Charting.Boolean">Gets or sets a value indicating whether to show tooltips.</field>
	},
	SimpleSeries: function (values, labels) {
		/// <summary>Represents one-dimensional series defined by e list of data values and a list of labels.</summary>
		/// <param name="values" type="MindFusion.Charting.Collections.List<Number> | Array<Number>">A list of data values.</param>
		/// <param name="labels" type="MindFusion.Charting.Collections.List<String> | Array<String>">A list of labels.</param>
		/// <field name="data" type="MindFusion.Charting.Collections.List<Number>">Gets or sets the data values contained in this series.</field>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 1.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in Data list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns InnerLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
	},
	StackRenderer: function (series) {
		/// <summary>A base SeriesRenderer for stacked graphics.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>"></param>
	},
	StepAreaRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws series as filled steps between data points.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
		/// <field name="areaOpacity" type="MindFusion.Charting.Number">ets or sets the opacity of area polygons.</field>
	},
	StepRenderer: function (series) {
		/// <summary>A SeriesRenderer that draws series as steps between data points.</summary>
		/// <param name="series" type="MindFusion.Charting.Collections.ObservableCollection<Series>">A list of Series that should be rendered by this object.</param>
	},
	StockPrice: function (open, close, low, high, date) {
		/// <summary>Represents a data object, containing open, close, low and high values for a certain date.</summary>
		/// <param name="open" type="Number">The open value.</param>
		/// <param name="close" type="Number">The close value.</param>
		/// <param name="low" type="Number">The low value.</param>
		/// <param name="high" type="Number">The high value.</param>
		/// <param name="date" type="Date" optional="true">Optional. The corresponding date.</param>
	},
	StockPriceSeries: function (values) {
		/// <summary>Represents a data series defined by a list of StockPrice objects.</summary>
		/// <param name="values" type="MindFusion.Charting.Collections.List<StockPrice> | Array<StockPrice>">A list of StockPrice objects.</param>
		/// <field name="customDateTimeFormat" type="String">Gets or sets a custom format string for DateTime labels.</field>
		/// <field name="dateTimeFormat" type="MindFusion.Charting.DateTimeFormat">Gets or sets a value indicating how to format DateTime values as labels.</field>
		/// <field name="dimensions" type="MindFusion.Charting.Number">Implements Series.Dimensions. Returns 5.</field>
		/// <field name="labelPrefix" type="String">Gets or sets a prefix added in front of formatted DateTime labels.</field>
		/// <field name="labelSuffix" type="String">Gets or sets a suffix appended to formatted DateTime labels.</field>
		/// <field name="size" type="MindFusion.Charting.Number">Implements Series.Size. Returns the number of elements in Values list.</field>
		/// <field name="supportedLabels" type="MindFusion.Charting.LabelKinds">Implements Series.SupportedLabels. Returns InnerLabel.</field>
		/// <field name="title" type="String">Implements Series.Title. Gets or sets the title of this series.</field>
		/// <field name="values" type="MindFusion.Charting.Collections.List<StockPrice>">Gets or sets the series' points.</field>
	},
	TextRenderer: function (context, font, textBrush) {
		/// <summary>Draws text and labels inside chart components.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="font" type="MindFusion.Drawing.Font">A Font instance.</param>
		/// <param name="textBrush" type="MindFusion.Charting.Drawing.Brush">A Brush instance.</param>
		/// <field name="labelFont" type="MindFusion.Drawing.Font">Gets or sets the Font used to draw labels.</field>
		/// <field name="textBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the brush used to draw labels.</field>
	},
	TextStyle: function () {
		/// <summary>Defines text appearance attributes.</summary>
		/// <field name="fontName" type="String">Gets or sets font name.</field>
		/// <field name="fontSize" type="MindFusion.Charting.Number">Gets or sets font size.</field>
		/// <field name="fontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets font style.</field>
		/// <field name="textBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw text.</field>
	},
	Theme: function (fill, stroke, strokeThickness, strokeDashStyle) {
		/// <summary>Represents a dashboard's theme defining all appearance attributes of its elements.</summary>
		/// <param name="fill" type="MindFusion.Charting.Drawing.Brush">A Brush used to fill all series elements.</param>
		/// <param name="stroke" type="MindFusion.Charting.Drawing.Brush">A Brush used to stroke all series elements.</param>
		/// <param name="strokeThickness" type="Number">Uniform thickness of series elements' strokes.</param>
		/// <param name="strokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Uniform dash style of series elements' strokes.</param>
		/// <field name="axisLabelsBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw axis labels.</field>
		/// <field name="axisLabelsFontName" type="String">Gets or sets the name of font used to draw axis labels.</field>
		/// <field name="axisLabelsFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw axis labels.</field>
		/// <field name="axisLabelsFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw axis labels.</field>
		/// <field name="axisStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke axis lines.</field>
		/// <field name="axisStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the dash style of axis lines.</field>
		/// <field name="axisStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of axis lines.</field>
		/// <field name="axisTitleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw axis titles.</field>
		/// <field name="axisTitleFontName" type="String">Gets or sets the name of font used to draw axis titles.</field>
		/// <field name="axisTitleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw axis titles.</field>
		/// <field name="axisTitleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw axis titles.</field>
		/// <field name="commonSeriesFills" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of brushes, each Brush used to fill all elements of a series.</field>
		/// <field name="commonSeriesStrokeDashStyles" type="MindFusion.Charting.Collections.List<DashStyle>">Gets or sets a list of dash styles, each style applied to all elements of a series.</field>
		/// <field name="commonSeriesStrokes" type="MindFusion.Charting.Collections.List<Brush>">Gets or sets a list of brushes, each Brush used to stroke all elements of a series.</field>
		/// <field name="commonSeriesStrokeThicknesses" type="MindFusion.Charting.Collections.List<Number>">Gets or sets a list of stroke thicknesses, each thickness applied to all elements of a series.</field>
		/// <field name="dataLabelsBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw data labels.</field>
		/// <field name="dataLabelsFontName" type="String">Gets or sets the name of font used to draw data labels.</field>
		/// <field name="dataLabelsFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw data labels.</field>
		/// <field name="dataLabelsFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw data labels.</field>
		/// <field name="gaugeBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw gauge backgrounds.</field>
		/// <field name="gaugeFontName" type="String">Gets or sets the name of font used to draw text in gauges.</field>
		/// <field name="gaugeFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw text in gauges.</field>
		/// <field name="gaugeFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw text in gauges.</field>
		/// <field name="gaugePointerBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw gauge pointer backgrounds.</field>
		/// <field name="gaugePointerStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke gauge pointer borders.</field>
		/// <field name="gaugePointerStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of gauge pointer borders.</field>
		/// <field name="gaugeScaleBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw gauge scale backgrounds.</field>
		/// <field name="gaugeScaleStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke gauge scale borders.</field>
		/// <field name="gaugeScaleStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of gauge scale borders.</field>
		/// <field name="gaugeStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke gauge borders.</field>
		/// <field name="gaugeStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of gauge borders.</field>
		/// <field name="gaugeTickBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw gauge tick backgrounds.</field>
		/// <field name="gaugeTickStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke gauge tick borders.</field>
		/// <field name="gaugeTickStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of gauge tick borders.</field>
		/// <field name="gridColor1" type="MindFusion.Charting.Drawing.Color">Gets or sets the main color of plot grid.</field>
		/// <field name="gridColor2" type="MindFusion.Charting.Drawing.Color">Gets or sets the alternating color of plot grid.</field>
		/// <field name="gridLineColor" type="MindFusion.Charting.Drawing.Color">Gets or sets the line color of plot grid.</field>
		/// <field name="gridLineStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the style of plot grid lines.</field>
		/// <field name="gridLineThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of plot grid lines.</field>
		/// <field name="highlightStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke highlighted items.</field>
		/// <field name="highlightStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the dash style of highlight strokes.</field>
		/// <field name="highlightStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of highlight strokes.</field>
		/// <field name="legendBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw legend background.</field>
		/// <field name="legendBorderStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw legend borders.</field>
		/// <field name="legendBorderStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the dash style of legend borders.</field>
		/// <field name="legendBorderStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of legend borders.</field>
		/// <field name="legendLabelsBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw legend labels.</field>
		/// <field name="legendTitleFontName" type="String">Gets or sets the name of font used to draw legend titles.</field>
		/// <field name="legendTitleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw legend titles.</field>
		/// <field name="legendTitleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw legend titles.</field>
		/// <field name="plotBackground" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to draw the background of plots.</field>
		/// <field name="plotBorderStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke plot borders.</field>
		/// <field name="plotBorderStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets the thickness of plot borders.</field>
		/// <field name="plotBorderStrokeThickness" type="MindFusion.Charting.Number">Gets or sets the thickness of plot borders.</field>
		/// <field name="seriesFills" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to draw a different series, and each Brush used to fill individual elements of a series.</field>
		/// <field name="seriesStrokeDashStyles" type="MindFusion.Charting.Collections.List<List<DashStyle>>">Gets or sets a list of DashStyle lists, each list used to stroke a different series, and each DashStyle value specifying style of individual elements of a series.</field>
		/// <field name="seriesStrokes" type="MindFusion.Charting.Collections.List<List<Brush>>">Gets or sets a list of Brush lists, each list used to stroke a different series, and each Brush used to stroke individual elements of a series.</field>
		/// <field name="seriesStrokeThicknesses" type="MindFusion.Charting.Collections.List<List<number>>">Gets or sets a list of number lists, each list used to stroke a different series, and each number value specifying thickness of individual elements of a series.</field>
		/// <field name="subtitleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw the chart sub-title.</field>
		/// <field name="subtitleFontName" type="String">Gets or sets the name of font used to draw the chart sub-title.</field>
		/// <field name="subtitleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw the chart sub-title.</field>
		/// <field name="subtitleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw the chart sub-title.</field>
		/// <field name="titleBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw the chart title.</field>
		/// <field name="titleFontName" type="String">Gets or sets the name of font used to draw the chart title.</field>
		/// <field name="titleFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw the chart title.</field>
		/// <field name="titleFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw the chart title.</field>
		/// <field name="uniformSeriesFill" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to fill all elements of all series uniformly.</field>
		/// <field name="uniformSeriesStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke all elements of all series uniformly.</field>
		/// <field name="uniformSeriesStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets uniform stroke dash style for all elements of all series.</field>
		/// <field name="uniformSeriesStrokeThickness" type="MindFusion.Charting.Number">Gets or sets uniform stroke thickness for all elements of all series.</field>
		/// <field name="widgetBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the Brush used to draw text in UI widgets.</field>
		/// <field name="widgetFontName" type="String">Gets or sets the name of font used to draw text in UI widgets.</field>
		/// <field name="widgetFontSize" type="MindFusion.Charting.Number">Gets or sets the size of font used to draw text in UI widgets.</field>
		/// <field name="widgetFontStyle" type="MindFusion.Charting.Drawing.FontStyle">Gets or sets the style of font used to draw text in UI widgets.</field>
	},
	ToolTip: function () {
		/// <summary>Represents current tooltip.</summary>
		/// <field name="brush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the tooltip background brush.</field>
		/// <field name="font" type="MindFusion.Charting.Drawing.Font">Gets or sets the tooltip font.</field>
		/// <field name="horizontalOffset" type="MindFusion.Charting.Number">Gets or sets the horizontal offset from the pointer.</field>
		/// <field name="horizontalPadding" type="MindFusion.Charting.Number">Gets or sets the horizontal padding to the left and right of the tooltip text.</field>
		/// <field name="pen" type="MindFusion.Charting.Drawing.Pen">Gets or sets the tooltip border pen.</field>
		/// <field name="position" type="MindFusion.Drawing.Point">Gets or sets the tooltip position.</field>
		/// <field name="text" type="String">Gets or sets the tooltip text.</field>
		/// <field name="textBrush" type="MindFusion.Charting.Drawing.Brush">Gets or sets the tooltip text brush.</field>
		/// <field name="verticalOffset" type="MindFusion.Charting.Number">Gets or sets the horizontal offset from the pointer.</field>
		/// <field name="verticalPadding" type="MindFusion.Charting.Number">Gets or sets the vertical padding above and below the tooltip text.</field>
	},
	UniformSeriesStyle: function (fill, stroke, strokeThickness, strokeDashStyle) {
		/// <summary>Implements SeriesStyle using uniform attributes for all elements in all series.</summary>
		/// <param name="fill" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. A Brush used to fill all series elements.</param>
		/// <param name="stroke" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. A Brush used to stroke all series elements.</param>
		/// <param name="strokeThickness" type="Number" optional="true">Optional. Uniform thickness of series elements' strokes.</param>
		/// <param name="strokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle" optional="true">Optional. Uniform dash style of series elements' strokes.</param>
		/// <field name="uniformFill" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to fill all elements of all series uniformly.</field>
		/// <field name="uniformStroke" type="MindFusion.Charting.Drawing.Brush">Gets or sets a Brush used to stroke all elements of all series uniformly.</field>
		/// <field name="uniformStrokeDashStyle" type="MindFusion.Charting.Drawing.DashStyle">Gets or sets uniform stroke dash style for all elements of all series.</field>
		/// <field name="uniformStrokeThickness" type="MindFusion.Charting.Number">Gets or sets uniform stroke thickness for all elements of all series.</field>
	},
	Vector: function (x, y) {
		/// <summary>Represents a two-dimensional vector.</summary>
		/// <param name="x" type="Number">X component of the vector.</param>
		/// <param name="y" type="Number">Y component of the vector.</param>
		/// <field name="length" type="MindFusion.Charting.Number">Gets the length of this vector.</field>
		/// <field name="lengthSquared" type="MindFusion.Charting.Number">Gets the squared length of this vector.</field>
		/// <field name="x" type="MindFusion.Charting.Number">Gets or sets the X component of this vector.</field>
		/// <field name="y" type="MindFusion.Charting.Number">Gets or sets the Y component of this vector.</field>
	},
	XAxisRenderer: function (axis) {
		/// <summary>A Component that renders horizontal Axis ranges.</summary>
		/// <param name="axis" type="MindFusion.Charting.Axis">The Axis that will be drawn by this object.</param>
		/// <field name="plotBottomSide" type="MindFusion.Charting.Boolean">Gets or sets whether this XAxisRenderer is shown at the bottom side of a plot.</field>
	},
	XmlPersistContext: function (document, fileVersion) {
		/// <summary>Contains methods that facilitate serializing and deserializing objects to and from XML documents.</summary>
		/// <param name="document" type="XMLDocument">The associated XMLDocument.</param>
		/// <param name="fileVersion" type="number">Specifies the current file format number.</param>
	},
	YAxisRenderer: function (axis, xAxis) {
		/// <summary>A Component that renders vertical Axis ranges.</summary>
		/// <param name="axis" type="MindFusion.Charting.Axis">The Axis that will be drawn by this object.</param>
		/// <param name="xAxis" type="MindFusion.Charting.Axis" optional="true">Optional. The Axis used to check data item visibility.</param>
		/// <field name="plotLeftSide" type="MindFusion.Charting.Boolean">Gets or sets whether this YAxisRenderer is shown at the left side of a plot.</field>
	},
	ZoomController: function (renderContext, vertical) {
		/// <summary>Represents a controller that zooms into plot's data range.</summary>
		/// <param name="renderContext" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="vertical" type="Boolean">true to implement interaction along the Y axis, or false for the X axis.</param>
	},
	__namespace: true
},
CancelEventArgs: function () {
	/// <summary>Contains the arguments passed to handlers of cancellable events.</summary>
},
EventArgs: function () {
	/// <summary>Base events args class.</summary>
},
Key: function (config) {
	/// <summary>Represents a key in the keyboard.</summary>
	/// <param name="config" type="Object">An object literal whose fields are assigned to respective Key properties.</param>
},
KeyboardLayout: function () {
	/// <summary>Defines layout of keyboard keys.</summary>
},
KeyboardState: function () {
	/// <summary>Specifies state of modifier keys.</summary>
},
VirtualKeyboard: function (element) {
	/// <summary>Implements a reusable Virtual Keyboard component.</summary>
	/// <param name="element" type="Div">The Div DOM Element where this VirtualKeyboard instance should be rendered.</param>
},
__namespace: true
};

MindFusion.Scheduling.BaseForm.prototype = {
	addControl: function(control) {
		/// <summary>Adds the specified control to the collection of controls.</summary>
		/// <param name="control" type="Object">Object. The control to add.</param>
	},
	clearControls: function() {
		/// <summary>Clears all items from the collection of controls.</summary>
	},
	closeForm: function(formId) {
		/// <summary>Closes the form.</summary>
		/// <param name="formId" type="String" optional="true">Optional. String. The Id of the form to be closed.</param>
	},
	col: function() {
		/// <summary>Renders a column element.</summary>
	},
	createButton: function(options) {
		/// <summary>Creates a button with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created button.</returns>
	},
	createCheckBox: function(options) {
		/// <summary>Creates a check-box with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created check-box</returns>
	},
	createCheckBoxList: function(options) {
		/// <summary>Creates a check box list with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created check-box list.</returns>
	},
	createDropDownList: function(options) {
		/// <summary>Creates a drop-down list with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created drop-down list.</returns>
	},
	createEditBox: function(options) {
		/// <summary>Creates an edit box with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created edit box.</returns>
	},
	createRadioButton: function(options) {
		/// <summary>Creates a radio button with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created radio button.</returns>
	},
	createTextArea: function(options) {
		/// <summary>Creates a text area with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created text area.</returns>
	},
	createTextBox: function(options) {
		/// <summary>Creates a text box with the specified options.</summary>
		/// <param name="options" type="Object">Object. Object, containing data for the new control.</param>
		/// <returns type="Object">Object. The newly created text box.</returns>
	},
	divider: function() {
		/// <summary>Renders a horizontal line divider.</summary>
	},
	drawButtons: function() {
		/// <summary>Renders the form buttons.</summary>
	},
	drawContent: function() {
		/// <summary>Renders the form content.</summary>
	},
	drawHeader: function() {
		/// <summary>Renders the form header.</summary>
	},
	getControlValue: function(controlId) {
		/// <summary>Gets the value of the control with the specified id.</summary>
		/// <param name="controlId" type="String">String. The id of the control to check.</param>
		/// <returns type="Object">Object. The value of the control.</returns>
	},
	removeControl: function(control) {
		/// <summary>Removes the specified control from the collection of controls.</summary>
		/// <param name="control" type="Object">Object. The control to remove.</param>
	},
	row: function() {
		/// <summary>Renders a row element.</summary>
	},
	showForm: function() {
		/// <summary>Renders the form.</summary>
	}
};
MindFusion.Scheduling.BaseForm.__class = true;

MindFusion.Scheduling.ButtonEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.ButtonEventArgs.__class = true;

MindFusion.Scheduling.Calendar.prototype = {
	attach: function() {
		/// <summary>Prepares the calendar for user interaction.</summary>
	},
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	},
	detach: function() {
		/// <summary>Detaches calendar event handlers.</summary>
	},
	draw: function() {
		/// <summary>Draws the calendar control.</summary>
		/// <returns type="DomElement">DomElement. the calendar element.</returns>
	},
	getCellAt: function(x, y) {
		/// <summary>Gets the calendar view cell that contains the specified coordinates.</summary>
		/// <param name="x" type="Number">Number. The X-coordinate of the point.</param>
		/// <param name="y" type="Number">Number. The Y-coordinate of the point.</param>
		/// <returns type="ViewCell">ViewCell. The calendar view cell that contains the specified coordinates or null if there is no cell at point.</returns>
	},
	getCellItems: function(cell) {
		/// <summary>Gets the items, whose visual elements are contained in the specified calendar cell.</summary>
		/// <param name="cell" type="ViewCell">ViewCell. The cell to check.</param>
		/// <returns type="Array">Array. An array of Item objects whose visual elements are contained in the specified calendar cell.</returns>
	},
	getItemCells: function(item) {
		/// <summary>Gets the calendar view cells that hold the specified item's visual elements.</summary>
		/// <param name="item" type="Item">Item. The item.</param>
		/// <returns type="Array">Array. An array of ViewCell objects that hold the specified item's visual elements.</returns>
	},
	getItemDom: function(item) {
		/// <summary>Gets the specified item's visual elements.</summary>
		/// <param name="item" type="Item">Item. The item.</param>
		/// <returns type="Array">Array. An array of div objects that represent the specified item's visual elements.</returns>
	},
	getTimeCell: function(time, isEndTime, resource) {
		/// <summary>Gets the calendar view cell that corresponds to the specified DateTime and resource.</summary>
		/// <param name="time" type="DateTime">DateTime. The time to search for.</param>
		/// <param name="isEndTime" type="Boolean" optional="true">Optional. Boolean. true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;false if the index of the second interval is contained. The default is false.</param>
		/// <param name="resource" type="Resource" optional="true">Optional. Resource. The resource to search for.</param>
		/// <returns type="ViewCell">ViewCell. The cell that corresponds the specified DateTime and resource.</returns>
	},
	getTimeCells: function(startTime, endTime, isEndTime, resource) {
		/// <summary>Gets the calendar view cells that corresponds to the specified DateTime range and the specified resource.</summary>
		/// <param name="startTime" type="DateTime">DateTime. The start time of the range.</param>
		/// <param name="endTime" type="DateTime" optional="true">Optional. DateTime. The end time of the range.</param>
		/// <param name="isEndTime" type="Boolean" optional="true">Optional. Boolean. true if the index of the first interval is returned when the time is the boundary between two consecutive intervals;false if the index of the second interval is contained. The default is false.</param>
		/// <param name="resource" type="Resource" optional="true">Optional. Resource. The resource to search for.</param>
		/// <returns type="Array">Array. An array of ViewCell objects that correspond to the specified DateTime range and resource.</returns>
	},
	hasItemsToRemind: function() {
		/// <summary>Checks if there are items which reminder has not come yet.</summary>
		/// <returns type="Boolean">Boolean. true if there are items with a future reminder; otherwise false.</returns>
	},
	hasTasksToRemind: function() {
		/// <summary>Checks if there are tasks which reminder has not come yet.</summary>
		/// <returns type="Boolean">Boolean. true if there are tasks with a future reminder; otherwise false.</returns>
	},
	render: function() {
		/// <summary>Draws the calendar control and prepares it for user interaction.</summary>
	},
	repaint: function(full) {
		/// <summary>Repaints the calendar contents.</summary>
		/// <param name="full" type="Boolean" optional="true">Optional. Boolean. True to recreate calendar items, otherwise false.</param>
	}
};
MindFusion.Scheduling.Calendar.__class = true;

MindFusion.Scheduling.CalendarView = {
	/// <summary>Specifies the type of view to display in a calendar control.</summary>
	/// <field name="List">The calendar displays several seconds, minutes, hours, days, weeks, months or years in a row.</field>
	/// <field name="MonthRange">The calendar displays several months in a grid. The days of each month are visible too.</field>
	/// <field name="ResourceView">The calendar displays the distribution of resources over a period of time.</field>
	/// <field name="SingleMonth">The calendar displays a single month at a time. The days of the month are displayed in a grid.</field>
	/// <field name="Timetable">The calendar displays a timetable where each row represents a fixed arbitrary time interval and each column represents a day.</field>
	/// <field name="WeekRange">The calendar displays a grid of days, with the columns representing the week days from Monday to Sunday and the rows representing weeks.</field>
	List: 3,
	MonthRange: 0,
	ResourceView: 5,
	SingleMonth: 1,
	Timetable: 4,
	WeekRange: 2
}
MindFusion.Scheduling.CalendarView.__enum = true;

MindFusion.Scheduling.CancelEventArgs.prototype = {
};
MindFusion.Scheduling.CancelEventArgs.__class = true;

MindFusion.Scheduling.CellEventArgs.prototype = {
};
MindFusion.Scheduling.CellEventArgs.__class = true;

MindFusion.Scheduling.Contact.prototype = {
	fromJson: function(json) {
		/// <summary>Deserializes this contact from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the contact content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the contact's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the contact content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the contact's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this contact into a JSON string.</summary>
		/// <returns type="String">String. A string containing the contact's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Contact.__class = true;

MindFusion.Scheduling.DailyRecurrence = {
	/// <summary>Specifies daily recurrence patterns.</summary>
	/// <field name="ByDayInterval">Repeats the item at regular intervals specified in the Recurrence.Days property.</field>
	/// <field name="EveryWeekend">Repeats the item each Saturday and Sunday.</field>
	/// <field name="EveryWorkday">Repeats the item each workday, Monday through Friday.</field>
	ByDayInterval: 0,
	EveryWeekend: 2,
	EveryWorkday: 1
}
MindFusion.Scheduling.DailyRecurrence.__enum = true;

MindFusion.Scheduling.DateChangedEventArgs.prototype = {
};
MindFusion.Scheduling.DateChangedEventArgs.__class = true;

MindFusion.Scheduling.DateTime.prototype = {
	__getDate: function() {
		/// <summary>Gets the day component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The day of month (1-31).</returns>
	},
	__getDay: function() {
		/// <summary>Gets the day of the week component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The day of the week (0-6). 0 is Sunday, 1 is Monday, etc.</returns>
	},
	__getFullYear: function() {
		/// <summary>Gets the year component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The year (four digits).</returns>
	},
	__getHours: function() {
		/// <summary>Gets the hours component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The hours (0-23).</returns>
	},
	__getMilliseconds: function() {
		/// <summary>Gets the milliseconds component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The milliseconds (0-999).</returns>
	},
	__getMinutes: function() {
		/// <summary>Gets the minutes component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The minutes (0-59).</returns>
	},
	__getMonth: function() {
		/// <summary>Gets the month component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The month (0-11). 0 is January, 1 is February, etc.</returns>
	},
	__getSeconds: function() {
		/// <summary>Gets the seconds component of this DateTime instance.</summary>
		/// <returns type="Number">Number. The seconds (0-59).</returns>
	},
	__getTime: function() {
		/// <summary>Gets the number of milliseconds between Jan 1 1970 00:00:00 and this DateTime instance.</summary>
		/// <returns type="Number">Number. The number of milliseconds since Jan 1 1970 00:00:00.</returns>
	},
	__getTimezoneOffset: function() {
		/// <summary>Gets the difference between GMT and local time in minutes.</summary>
		/// <returns type="Number">Number. The difference between GMT and local time in minutes.</returns>
	},
	__getUTCDate: function() {
		/// <summary>Gets the day component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The day of month (1-31).</returns>
	},
	__getUTCDay: function() {
		/// <summary>Gets the day of the week component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The day of the week (0-6). 0 is Sunday, 1 is Monday, etc.</returns>
	},
	__getUTCFullYear: function() {
		/// <summary>Gets the year component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The year (four digits).</returns>
	},
	__getUTCHours: function() {
		/// <summary>Gets the hours component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The hours (0-23).</returns>
	},
	__getUTCMilliseconds: function() {
		/// <summary>Gets the milliseconds component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The milliseconds (0-999).</returns>
	},
	__getUTCMinutes: function() {
		/// <summary>Gets the minutes component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The minutes (0-59).</returns>
	},
	__getUTCMonth: function() {
		/// <summary>Gets the month component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The month (0-11). 0 is January, 1 is February, etc.</returns>
	},
	__getUTCSeconds: function() {
		/// <summary>Gets the seconds component of this DateTime instance, according to universal time.</summary>
		/// <returns type="Number">Number. The seconds (0-59).</returns>
	},
	__setDate: function(day) {
		/// <summary>Sets the day component of this DateTime instance.</summary>
		/// <param name="day" type="Number">Number. The day of month (1-31).</param>
	},
	__setFullYear: function(year, month, day) {
		/// <summary>Sets the year component of this DateTime instance.</summary>
		/// <param name="year" type="Number">Number. A four-digit value representing the year.</param>
		/// <param name="month" type="Number" optional="true">Optional. Number. An integer between 0 and 11 representing the month.</param>
		/// <param name="day" type="Number" optional="true">Optional. Number. An integer between 1 and 31 representing the date.</param>
	},
	__setHours: function(hour, min, sec, millisec) {
		/// <summary>Sets the hours component of this DateTime instance.</summary>
		/// <param name="hour" type="Number">Number. An integer between 0 and 23 representing the hour.</param>
		/// <param name="min" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the minutes.</param>
		/// <param name="sec" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setMilliseconds: function(millisec) {
		/// <summary>Sets the milliseconds component of this DateTime instance.</summary>
		/// <param name="millisec" type="Number">Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setMinutes: function(min, sec, millisec) {
		/// <summary>Sets the minutes component of this DateTime instance.</summary>
		/// <param name="min" type="Number">Number. An integer between 0 and 59 representing the minutes.</param>
		/// <param name="sec" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setSeconds: function(sec, millisec) {
		/// <summary>Sets the seconds component of this DateTime instance.</summary>
		/// <param name="sec" type="Number">Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setTime: function(millisec) {
		/// <summary>Sets a date and time by adding or subtracting a specified number of milliseconds to/from midnight 1 Jan 1970.</summary>
		/// <param name="millisec" type="Number">Number. The number of milliseconds to be added to, or subtracted from, midnight 1 Jan 1970.</param>
	},
	__setUTCDate: function(day) {
		/// <summary>Sets the day component of this DateTime instance, according to universal time.</summary>
		/// <param name="day" type="Number">Number. The day of month (1-31).</param>
	},
	__setUTCFullYear: function(year, month, day) {
		/// <summary>Sets the year component of this DateTime instance, according to universal time.</summary>
		/// <param name="year" type="Number">Number. A four-digit value representing the year.</param>
		/// <param name="month" type="Number" optional="true">Optional. Number. An integer between 0 and 11 representing the month.</param>
		/// <param name="day" type="Number" optional="true">Optional. Number. An integer between 1 and 31 representing the date.</param>
	},
	__setUTCHours: function(hour, min, sec, millisec) {
		/// <summary>Sets the hours component of this DateTime instance, according to universal time.</summary>
		/// <param name="hour" type="Number">Number. An integer between 0 and 23 representing the hour.</param>
		/// <param name="min" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the minutes.</param>
		/// <param name="sec" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setUTCMilliseconds: function(millisec) {
		/// <summary>Sets the milliseconds component of this DateTime instance, according to universal time.</summary>
		/// <param name="millisec" type="Number">Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setUTCMinutes: function(min, sec, millisec) {
		/// <summary>Sets the minutes component of this DateTime instance, according to universal time.</summary>
		/// <param name="min" type="Number">Number. An integer between 0 and 59 representing the minutes.</param>
		/// <param name="sec" type="Number" optional="true">Optional. Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__setUTCSeconds: function(sec, millisec) {
		/// <summary>Sets the seconds component of this DateTime instance, according to universal time.</summary>
		/// <param name="sec" type="Number">Number. An integer between 0 and 59 representing the seconds.</param>
		/// <param name="millisec" type="Number" optional="true">Optional. Number. An integer between 0 and 999 representing the milliseconds.</param>
	},
	__toDateString: function() {
		/// <summary>Converts the date component of this DateTime instance to a readable string.</summary>
		/// <returns type="String">String. A readable string representation of the date component of this DateTime instance.</returns>
	},
	__toLocaleDateString: function() {
		/// <summary>Converts the date component of this DateTime instance to a readable string, using locale conventions.</summary>
		/// <returns type="String">String. A readable locale string representation of the date component of this DateTime instance.</returns>
	},
	__toLocaleString: function() {
		/// <summary>Converts this DateTime instance to a readable string, using locale conventions.</summary>
		/// <returns type="String">String. A readable locale string representation of this DateTime instance.</returns>
	},
	__toLocaleTimeString: function() {
		/// <summary>Converts the time component of this DateTime instance to a readable string, using locale conventions.</summary>
		/// <returns type="String">String. A readable locale string representation of the time component of this DateTime instance.</returns>
	},
	__toString: function() {
		/// <summary>Converts this DateTime instance to a readable string.</summary>
		/// <returns type="String">String. A readable string representation of this DateTime instance.</returns>
	},
	__toTimeString: function() {
		/// <summary>Converts the time component of this DateTime instance to a readable string.</summary>
		/// <returns type="String">String. A readable string representation of the time component of this DateTime instance.</returns>
	},
	__toUTCString: function() {
		/// <summary>Converts this DateTime instance to a readable string, according to universal time.</summary>
		/// <returns type="String">String. A readable string representation of this DateTime instance.</returns>
	},
	__valueOf: function() {
		/// <summary>Represents the primitive value of this DateTime object.</summary>
		/// <returns type="Number">Number. The primitive value of this DateTime object.</returns>
	},
	addDays: function(days) {
		/// <summary>Adds the specified number of days to the current DateTime object.</summary>
		/// <param name="days" type="Number">Number. The number of days to add.</param>
	},
	addHours: function(hours) {
		/// <summary>Adds the specified number of hours to the current DateTime object.</summary>
		/// <param name="hours" type="Number">Number. The number of hours to add.</param>
	},
	addMilliseconds: function(milliseconds) {
		/// <summary>Adds the specified number of milliseconds to the current DateTime object.</summary>
		/// <param name="milliseconds" type="Number">Number. The number of milliseconds to add.</param>
	},
	addMinutes: function(minutes) {
		/// <summary>Adds the specified number of minutes to the current DateTime object.</summary>
		/// <param name="minutes" type="Number">Number. The number of minutes to add.</param>
	},
	addMonths: function(months) {
		/// <summary>Adds the specified number of months to the current DateTime object.</summary>
		/// <param name="months" type="Number">Number. The number of months to add.</param>
	},
	addSeconds: function(seconds) {
		/// <summary>Adds the specified number of seconds to the current DateTime object.</summary>
		/// <param name="seconds" type="Number">Number. The number of seconds to add.</param>
	},
	addYears: function(years) {
		/// <summary>Adds the specified number of years to the current DateTime object.</summary>
		/// <param name="years" type="Number">Number. The number of years to add.</param>
	},
	clone: function() {
		/// <summary>Returns a copy of the current DateTime object.</summary>
		/// <returns type="DateTime">DateTime. The cloned DateTime object.</returns>
	},
	compareTo: function(date) {
		/// <summary>Compares the current DateTime instance with another DateTime object and returns an integer that indicates whether the current instance precedes, follows, or occurs in the same position in the sort order as the other object.</summary>
		/// <param name="date" type="DateTime">DateTime. A DateTime object to compare with this instance.</param>
		/// <returns type="Number">Number. A value that indicates the relative order of the DateTime objects being compared.</returns>
	},
	equals: function(date) {
		/// <summary>Returns a value indicating whether two DateTime objects are equal.</summary>
		/// <param name="date" type="DateTime">DateTime. The DateTime object to compare with.</param>
		/// <returns type="Boolean">Boolean. True if the values are equal, otherwise false.</returns>
	},
	getDate: function() {
		/// <summary>For internal use only.</summary>
		/// <returns type="Object"></returns>
	},
	getDaysInMonth: function() {
		/// <summary>Returns the number of days in the month of the current DateTime instance.</summary>
		/// <returns type="Number">Number. The number of days.</returns>
	},
	getMonth: function() {
		/// <summary>Returns the month component of the current DateTime object.</summary>
		/// <returns type="Number">Number. The month.</returns>
	},
	greaterThan: function(date) {
		/// <summary>Checks if this DateTime object is greater than the specified DateTime object.</summary>
		/// <param name="date" type="DateTime">DateTime. The DateTime object to compare with.</param>
		/// <returns type="Boolean">Boolean. true if this value is greater than the specified value, otherwise false.</returns>
	},
	greaterThanOrEqual: function(date) {
		/// <summary>Checks if this DateTime object is greater than or equal to the specified DateTime object.</summary>
		/// <param name="date" type="DateTime">DateTime. The DateTime object to compare with.</param>
		/// <returns type="Boolean">Boolean. true if this value is greater than or equal to the specified value, otherwise false.</returns>
	},
	isLeapYear: function() {
		/// <summary>Returns a value indicating whether the year of the current DateTime instance is a leap year.</summary>
		/// <returns type="Boolean">Boolean. True if it is a leap year, otherwise false.</returns>
	},
	lessThan: function(date) {
		/// <summary>Checks if this DateTime object is less than the specified DateTime object.</summary>
		/// <param name="date" type="DateTime">DateTime. The DateTime object to compare with.</param>
		/// <returns type="Boolean">Boolean. true if this value is less than the specified value, otherwise false.</returns>
	},
	lessThanOrEqual: function(date) {
		/// <summary>Checks if this DateTime object is less than or equal to the specified DateTime object.</summary>
		/// <param name="date" type="DateTime">DateTime. The DateTime object to compare with.</param>
		/// <returns type="Boolean">Boolean. true if this value is less than or equal to the specified value, otherwise false.</returns>
	},
	subtract: function(date) {
		/// <summary>Subtracts the specified date from the current date and returns the number of milliseconds between them.</summary>
		/// <param name="date" type="DateTime">DateTime. The date to subtract.</param>
		/// <returns type="Number">Number. The number of milliseconds between the specified date and this date.</returns>
	},
	toString: function(format, formatInfo) {
		/// <summary>Returns a string representation of the current DateTime object.</summary>
		/// <param name="format" type="String" optional="true">Optional. String. The DateTime format used for the string representation.</param>
		/// <param name="formatInfo" type="Object" optional="true">Optional. Object. The formatInfo object used for the string representation.</param>
		/// <returns type="String">String. The string representation of the current DateTime object.</returns>
	},
	valueOf: function() {
		/// <summary>Represents the primitive value of this DateTime object.</summary>
		/// <returns type="Number">Number. The primitive value of this DateTime object in milliseconds.</returns>
	},
};
MindFusion.Scheduling.DateTime.__class = true;

MindFusion.Scheduling.DateTime.addDays = function(date, days) {
	/// <summary>Adds the specified number of days to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="days" type="Number">Number. The number of days to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addHours = function(date, hours) {
	/// <summary>Adds the specified number of hours to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="hours" type="Number">Number. The number of hours to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addMilliseconds = function(date, milliseconds) {
	/// <summary>Adds the specified number of milliseconds to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="milliseconds" type="Number">Number. The number of milliseconds to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addMinutes = function(date, minutes) {
	/// <summary>Adds the specified number of minutes to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="minutes" type="Number">Number. The number of minutes to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addMonths = function(date, months) {
	/// <summary>Adds the specified number of months to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="months" type="Number">Number. The number of months to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addSeconds = function(date, seconds) {
	/// <summary>Adds the specified number of seconds to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="seconds" type="Number">Number. The number of seconds to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.addYears = function(date, years) {
	/// <summary>Adds the specified number of years to the specified DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. The DateTime instance to modify.</param>
	/// <param name="years" type="Number">Number. The number of years to add.</param>
	/// <returns type="DateTime">DateTime. The modified DateTime instance.</returns>
};
MindFusion.Scheduling.DateTime.combine = function(date, time) {
	/// <summary>Combines the date component of a DateTime object and the time component of another DateTime object into a new DateTime object.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime object to get the date part from.</param>
	/// <param name="time" type="DateTime">DateTime. A DateTime object to get the time part from.</param>
	/// <returns type="DateTime">DateTime. The new combined DateTime object.</returns>
};
MindFusion.Scheduling.DateTime.daysBetween = function(date1, date2) {
	/// <summary>Returns the number of days between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of days.</returns>
};
MindFusion.Scheduling.DateTime.fromDateParts = function(year, month, day, hours, minutes, seconds, milliseconds) {
	/// <summary>Creates a new DateTime object, by specifying its different date and time components.</summary>
	/// <param name="year" type="Number">Number. The year component.</param>
	/// <param name="month" type="Number">Number. The month component (0-11).</param>
	/// <param name="day" type="Number" optional="true">Optional. Number. The day component (1-31). If not provided, a default value of 1 will be used.</param>
	/// <param name="hours" type="Number" optional="true">Optional. Number. The hours component (0-23). If not provided, a default value of 0 will be used.</param>
	/// <param name="minutes" type="Number" optional="true">Optional. Number. The minutes component (0-59). If not provided, a default value of 0 will be used.</param>
	/// <param name="seconds" type="Number" optional="true">Optional. Number. The seconds component (0-59). If not provided, a default value of 0 will be used.</param>
	/// <param name="milliseconds" type="Number" optional="true">Optional. Number. The milliseconds component (0-999). If not provided, a default value of 0 will be used.</param>
	/// <returns type="DateTime">DateTime. The new DateTime object, or null if a Date instance cannot be created from the provided values.</returns>
};
MindFusion.Scheduling.DateTime.fromDateString = function(dateString) {
	/// <summary>Creates a new DateTime object from a provided date string.</summary>
	/// <param name="dateString" type="String">String. The date string to create the DateTime from.</param>
	/// <returns type="DateTime">DateTime. The new DateTime object, or null if a Date instance cannot be created from the provided string.</returns>
};
MindFusion.Scheduling.DateTime.fromMilliseconds = function(milliseconds) {
	/// <summary>Creates a new DateTime object from the number of milliseconds since Jan 1st 1970.</summary>
	/// <param name="milliseconds" type="Number">Number. The number of milliseconds since Jan 1st 1970;</param>
	/// <returns type="DateTime">DateTime. The new DateTime object, or null if a Date instance cannot be created from the provided value.</returns>
};
MindFusion.Scheduling.DateTime.getDayOfMonth = function(date) {
	/// <summary>Returns the day of the month of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The day of the month.</returns>
};
MindFusion.Scheduling.DateTime.getDayOfWeek = function(date) {
	/// <summary>Returns the day of the week of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The day of the week.</returns>
};
MindFusion.Scheduling.DateTime.getDaysInMonth = function(date) {
	/// <summary>Returns the number of days in the month of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of days.</returns>
};
MindFusion.Scheduling.DateTime.getMonth = function(date) {
	/// <summary>Returns the month component of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The month.</returns>
};
MindFusion.Scheduling.DateTime.getWeekFirstDate = function(date, formatInfo) {
	/// <summary>Returns the beginning of the week of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="formatInfo" type="Object" optional="true">Optional. Object. The formatInfo object.</param>
	/// <returns type="DateTime">DateTime. A DateTime instance specifying the beginning of the week.</returns>
};
MindFusion.Scheduling.DateTime.getYear = function(date) {
	/// <summary>Returns the year component of the specified DateTime.</summary>
	/// <param name="date" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The year.</returns>
};
MindFusion.Scheduling.DateTime.hoursBetween = function(date1, date2) {
	/// <summary>Returns the number of hours between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of hours.</returns>
};
MindFusion.Scheduling.DateTime.maxDate = function(date1, date2) {
	/// <summary>Returns the latter of two DateTime objects.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime object.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime object.</param>
	/// <returns type="DateTime">DateTime. The latter of two DateTime objects.</returns>
};
MindFusion.Scheduling.DateTime.maxValue = function() {
	/// <summary>Returns the highest possible DateTime value.</summary>
	/// <returns type="DateTime">DateTime. The highest possible DateTime value.</returns>
};
MindFusion.Scheduling.DateTime.millisecondsBetween = function(date1, date2) {
	/// <summary>Returns the number of milliseconds between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of milliseconds.</returns>
};
MindFusion.Scheduling.DateTime.minDate = function(date1, date2) {
	/// <summary>Returns the former of two DateTime objects.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime object.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime object.</param>
	/// <returns type="DateTime">DateTime. The former of two DateTime objects.</returns>
};
MindFusion.Scheduling.DateTime.minutesBetween = function(date1, date2) {
	/// <summary>Returns the number of minutes between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of minutes.</returns>
};
MindFusion.Scheduling.DateTime.minValue = function() {
	/// <summary>Returns the lowest possible DateTime value.</summary>
	/// <returns type="DateTime">DateTime. The lowest possible DateTime value.</returns>
};
MindFusion.Scheduling.DateTime.monthsBetween = function(date1, date2) {
	/// <summary>Returns the number of months between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of months.</returns>
};
MindFusion.Scheduling.DateTime.now = function() {
	/// <summary>Returns a DateTime object representing the current DateTime.</summary>
	/// <returns type="DateTime">DateTime. The DateTime object representing the current DateTime.</returns>
};
MindFusion.Scheduling.DateTime.secondsBetween = function(date1, date2) {
	/// <summary>Returns the number of seconds between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of seconds.</returns>
};
MindFusion.Scheduling.DateTime.subtract = function(date1, date2) {
	/// <summary>Returns the number of milliseconds between the specified dates.</summary>
	/// <param name="date1" type="DateTime">DateTime. The date to subtract from.</param>
	/// <param name="date2" type="DateTime">DateTime. The date to subtract.</param>
	/// <returns type="Number">Number. The number of milliseconds between the specified dates.</returns>
};
MindFusion.Scheduling.DateTime.today = function() {
	/// <summary>Returns a DateTime object representing the current Date.</summary>
	/// <returns type="DateTime">DateTime. The DateTime object representing the current Date.</returns>
};
MindFusion.Scheduling.DateTime.weeksBetween = function(date1, date2) {
	/// <summary>Returns the number of weeks between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of weeks.</returns>
};
MindFusion.Scheduling.DateTime.yearsBetween = function(date1, date2) {
	/// <summary>Returns the number of years between two DateTime instances.</summary>
	/// <param name="date1" type="DateTime">DateTime. A DateTime instance.</param>
	/// <param name="date2" type="DateTime">DateTime. A DateTime instance.</param>
	/// <returns type="Number">Number. The number of years.</returns>
};

MindFusion.Scheduling.DayOfWeek = {
	/// <summary>Specifies the day of the week.</summary>
	/// <field name="Friday">Indicates Friday.</field>
	/// <field name="Monday">Indicates Monday.</field>
	/// <field name="Saturday">Indicates Saturday.</field>
	/// <field name="Sunday">Indicates Sunday.</field>
	/// <field name="Thursday">Indicates Thursday.</field>
	/// <field name="Tuesday">Indicates Tuesday.</field>
	/// <field name="Wednesday">Indicates Wednesday.</field>
	Friday: 5,
	Monday: 1,
	Saturday: 6,
	Sunday: 0,
	Thursday: 4,
	Tuesday: 2,
	Wednesday: 3
}
MindFusion.Scheduling.DayOfWeek.__enum = true;

MindFusion.Scheduling.DayOfWeekFormat = {
	/// <summary>Specifies the display format of a day of the week.</summary>
	/// <field name="Abbreviated">The first three letters of the day of the week are displayed.</field>
	/// <field name="Full">The complete name of the day of the week is displayed.</field>
	/// <field name="SingleLetter">Only the first letter of the name of the day is displayed.</field>
	Abbreviated: 1,
	Full: 2,
	SingleLetter: 0
}
MindFusion.Scheduling.DayOfWeekFormat.__enum = true;

MindFusion.Scheduling.DayOfWeekType = {
	/// <summary>Specifies the type of week day to use with ByDayType monthly and yearly recurrence patterns.</summary>
	/// <field name="AnyDay">Indicates any day.</field>
	/// <field name="Friday">Indicates Friday.</field>
	/// <field name="Monday">Indicates Monday.</field>
	/// <field name="Saturday">Indicates Saturday.</field>
	/// <field name="Sunday">Indicates Sunday.</field>
	/// <field name="Thursday">Indicates Thursday.</field>
	/// <field name="Tuesday">Indicates Tuesday.</field>
	/// <field name="Wednesday">Indicates Wednesday.</field>
	/// <field name="Weekend">Indicates a weekend day.</field>
	/// <field name="Workday">Indicates a workday.</field>
	AnyDay: 0,
	Friday: 8,
	Monday: 4,
	Saturday: 9,
	Sunday: 3,
	Thursday: 7,
	Tuesday: 5,
	Wednesday: 6,
	Weekend: 2,
	Workday: 1
}
MindFusion.Scheduling.DayOfWeekType.__enum = true;

MindFusion.Scheduling.DaysOfWeek = {
	/// <summary>Specifies the day of the week. This enum allows bitwise combination of its members.</summary>
	/// <field name="All">Indicates all days of the week.</field>
	/// <field name="Friday">Indicates Friday.</field>
	/// <field name="Monday">Indicates Monday.</field>
	/// <field name="None">Indicates an undefined day value.</field>
	/// <field name="Saturday">Indicates Saturday.</field>
	/// <field name="Sunday">Indicates Sunday.</field>
	/// <field name="Thursday">Indicates Thursday.</field>
	/// <field name="Tuesday">Indicates Tuesday.</field>
	/// <field name="Wednesday">Indicates Wednesday.</field>
	All: 127,
	Friday: 32,
	Monday: 2,
	None: 0,
	Saturday: 64,
	Sunday: 1,
	Thursday: 16,
	Tuesday: 4,
	Wednesday: 8
}
MindFusion.Scheduling.DaysOfWeek.__enum = true;

MindFusion.Scheduling.Dictionary.prototype = {
	contains: function(key) {
		/// <summary>Determines whether the dictionary contains a specific key.</summary>
		/// <param name="key" type="TKey">TKey. The key to locate in the dictionary.</param>
		/// <returns type="Boolean">Boolean. true if the element exists in the collection, otherwise false.</returns>
	},
	get: function(key) {
		/// <summary>Gets the value associated with the specified key within the dictionary.</summary>
		/// <param name="key" type="TKey">TKey. The key whose value to get.</param>
		/// <returns type="Object">Object. The item associated with this key.</returns>
	},
	remove: function(key) {
		/// <summary>Removes the element with the specified key from the dictionary.</summary>
		/// <param name="key" type="TKey">TKey. The key of the element to remove.</param>
	},
	set: function(key, value) {
		/// <summary>Associates the specified value with the specified key within the dictionary.</summary>
		/// <param name="key" type="TKey">TKey. The key to associate the value with.</param>
		/// <param name="value" type="TValue">TValue. The value to associate.</param>
	}
};
MindFusion.Scheduling.Dictionary.__class = true;

MindFusion.Scheduling.EmptyEventArgs.prototype = {
};
MindFusion.Scheduling.EmptyEventArgs.__class = true;

MindFusion.Scheduling.EventArgs.prototype = {
};
MindFusion.Scheduling.EventArgs.__class = true;

MindFusion.Scheduling.EventDispatcher.prototype = {
	addEventListener: function() {
		/// <summary>Subcribes an event listener to this event.</summary>
	},
	raiseEvent: function() {
		/// <summary>Raises this event.</summary>
	},
	removeEventListener: function() {
		/// <summary>Removes an event listener from this event.</summary>
	}
};
MindFusion.Scheduling.EventDispatcher.__class = true;

MindFusion.Scheduling.FormEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.FormEventArgs.__class = true;

MindFusion.Scheduling.GroupType = {
	/// <summary>Specifies grouping or filtering criteria for views that support grouping.</summary>
	/// <field name="FilterByContacts">Filter by contacts.</field>
	/// <field name="FilterByLocations">Filter by locations.</field>
	/// <field name="FilterByResources">Filter by resources.</field>
	/// <field name="FilterByTasks">Filter by tasks.</field>
	/// <field name="GroupByContacts">Group by contacts.</field>
	/// <field name="GroupByLocations">Group by locations.</field>
	/// <field name="GroupByResources">Group by resources.</field>
	/// <field name="GroupByTasks">Group by tasks.</field>
	/// <field name="None">No grouping or filtering.</field>
	FilterByContacts: 5,
	FilterByLocations: 6,
	FilterByResources: 8,
	FilterByTasks: 7,
	GroupByContacts: 1,
	GroupByLocations: 3,
	GroupByResources: 2,
	GroupByTasks: 4,
	None: 0
}
MindFusion.Scheduling.GroupType.__enum = true;

MindFusion.Scheduling.HeaderEventArgs.prototype = {
};
MindFusion.Scheduling.HeaderEventArgs.__class = true;

MindFusion.Scheduling.HeaderType = {
	/// <summary>Specifies the type of a calendar header.</summary>
	/// <field name="Cell">Indicates a date cell header.</field>
	/// <field name="DayNames">Indicates the day names header.</field>
	/// <field name="Group">Indicates the group header.</field>
	/// <field name="Main">Indicates the main view header.</field>
	/// <field name="Timeline">Indicates the timeline header.</field>
	/// <field name="WeekNumbers">Indicates the week numbers header.</field>
	Cell: 0,
	DayNames: 4,
	Group: 2,
	Main: 1,
	Timeline: 3,
	WeekNumbers: 5
}
MindFusion.Scheduling.HeaderType.__enum = true;

MindFusion.Scheduling.HorizontalHeaderStyle = {
	/// <summary>Specifies the appearance of a horizontal header in the calendar.</summary>
	/// <field name="Bottom">The header is displayed to the bottom side of the calendar.</field>
	/// <field name="None">The header is not displayed.</field>
	/// <field name="Top">The header is displayed to the top side of the calendar.</field>
	Bottom: 2,
	None: 0,
	Top: 1
}
MindFusion.Scheduling.HorizontalHeaderStyle.__enum = true;

MindFusion.Scheduling.IEnumerable.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection.</summary>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection.</summary>
		/// <returns type="IEnumerable">IEnumerable. A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection.</summary>
		/// <param name="item" type="Object">Object. The object to check for.</param>
		/// <returns type="Boolean">Boolean. True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection.</summary>
		/// <param name="destination" type="IEnumerable">IEnumerable. The destination collection.</param>
		/// <param name="length" type="Number">Number. The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. Number. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. Number. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements.</summary>
		/// <returns type="Number">Number. The number of elements.</returns>
	},
	first: function() {
		/// <summary>Returns the first element in the collection.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection.</summary>
		/// <param name="obj" type="Object">Object. The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. Number. The starting index to search from.</param>
		/// <returns type="Number">Number. The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <returns type="Object">Object. The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection.</returns>
	},
	last: function() {
		/// <summary>Returns the last element in the collection.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns the maximum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection.</summary>
		/// <param name="item" type="Object">Object. The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index.</summary>
		/// <param name="index" type="Number">Number. The starting index of the range.</param>
		/// <param name="count" type="Number">Number. The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array.</summary>
		/// <param name="compareFn" type="function" optional="true">Optional. function. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that are obtained by invoking a transform function on each element.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection.</summary>
		/// <returns type="Array">Array. The array.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Scheduling.IEnumerable.__class = true;

MindFusion.Scheduling.Item.prototype = {
	clone: function() {
		/// <summary>Creates an exact copy of this item.</summary>
		/// <returns type="Item">Item. An item, identical to this one.</returns>
	},
	fromJson: function(json) {
		/// <summary>Deserializes this item from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the item content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the item's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the item content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this item into a JSON string.</summary>
		/// <returns type="String">String. A string containing the item's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Item.__class = true;

MindFusion.Scheduling.ItemEventArgs.prototype = {
};
MindFusion.Scheduling.ItemEventArgs.__class = true;

MindFusion.Scheduling.ItemModifiedEventArgs.prototype = {
};
MindFusion.Scheduling.ItemModifiedEventArgs.__class = true;

MindFusion.Scheduling.ItemModifyAction = {
	/// <summary>Specifies the type of modification action used, when an item is modified.</summary>
	/// <field name="Clone">Specifies that the item was interactively cloned.</field>
	/// <field name="Create">Specifies that the item was interactively created.</field>
	/// <field name="Delete">Specifies that the item was interactively deleted.</field>
	/// <field name="Drag">Specifies that the item is modified through an interactive drag operation.</field>
	/// <field name="Edit">Specifies that the item was modified through a modification of one or more of its properties, excluding drag and resize interactive operations.</field>
	/// <field name="InplaceEdit">Specifies that the item is modified through an interactive inplace-edit operation.</field>
	/// <field name="Resize">Specifies that the item is modified through an interactive resize operation.</field>
	Clone: 5,
	Create: -1,
	Delete: 4,
	Drag: 1,
	Edit: 0,
	InplaceEdit: 3,
	Resize: 2
}
MindFusion.Scheduling.ItemModifyAction.__enum = true;

MindFusion.Scheduling.ItemModifyingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.ItemModifyingEventArgs.__class = true;

MindFusion.Scheduling.ItemSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.ItemSettings.__class = true;

MindFusion.Scheduling.Keys = {
	/// <summary>Identifies special Keys.</summary>
	/// <field name="Alt">Indicates the ALT modifier key.</field>
	/// <field name="Control">Indicates the CTRL modifier key.</field>
	/// <field name="None">No key pressed.</field>
	/// <field name="Shift">Indicates the SHIFT modifier key.</field>
	Alt: 3,
	Control: 2,
	None: 0,
	Shift: 1
}
MindFusion.Scheduling.Keys.__enum = true;

MindFusion.Scheduling.List.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection. Inherited from IEnumerable.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <param name="item" type="T">The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The starting index of the range.</param>
		/// <param name="count" type="Number">The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Scheduling.List.__class = true;

MindFusion.Scheduling.ListSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.ListSettings.__class = true;

MindFusion.Scheduling.Location.prototype = {
	fromJson: function(json) {
		/// <summary>Deserializes this location from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the location content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the location's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the location content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the location's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this location into a JSON string.</summary>
		/// <returns type="String">String. A string containing the location's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Location.__class = true;

MindFusion.Scheduling.MainHeaderStyle = {
	/// <summary>Specifies the appearance of the calendar's main header.</summary>
	/// <field name="Buttons">The header displays navigation buttons.</field>
	/// <field name="None">The header is not displayed.</field>
	/// <field name="Title">The header displays a title.</field>
	Buttons: 2,
	None: 0,
	Title: 1
}
MindFusion.Scheduling.MainHeaderStyle.__enum = true;

MindFusion.Scheduling.MonthlyRecurrence = {
	/// <summary>Specifies monthly recurrence patterns.</summary>
	/// <field name="ByDayNumber">The event occurs on the given day of the month.</field>
	/// <field name="ByDayType">The event occurs on a given type of day in the specified week of the month.</field>
	ByDayNumber: 0,
	ByDayType: 1
}
MindFusion.Scheduling.MonthlyRecurrence.__enum = true;

MindFusion.Scheduling.MonthRangeSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.MonthRangeSettings.__class = true;

MindFusion.Scheduling.MonthSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.MonthSettings.__class = true;

MindFusion.Scheduling.NotifyCollectionChangedAction.prototype = {
};
MindFusion.Scheduling.NotifyCollectionChangedAction.__class = true;

MindFusion.Scheduling.NotifyCollectionChangedEventArgs.prototype = {
};
MindFusion.Scheduling.NotifyCollectionChangedEventArgs.__class = true;

MindFusion.Scheduling.NotifyCollectionChangedEventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event. Inherited from EventDispatcher.</summary>
		/// <param name="sender" type="void"></param>
		/// <param name="args" type="void"></param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	}
};
MindFusion.Scheduling.NotifyCollectionChangedEventDispatcher.__class = true;

MindFusion.Scheduling.NotifyCollectionChangingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.NotifyCollectionChangingEventArgs.__class = true;

MindFusion.Scheduling.NotifyCollectionChangingEventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event. Inherited from EventDispatcher.</summary>
		/// <param name="sender" type="void"></param>
		/// <param name="args" type="void"></param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	}
};
MindFusion.Scheduling.NotifyCollectionChangingEventDispatcher.__class = true;

MindFusion.Scheduling.ObservableCollection.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the collection.</summary>
		/// <param name="item" type="Object">Object. The item to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection</summary>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	onCollectionChanged: function(args) {
		/// <summary>Raises the collectionChanged event.</summary>
		/// <param name="args" type="NotifyCollectionChangedEventArgs">NotifyCollectionChangedEventArgs. An instance of the NotifyCollectionChangedEventArgs class.</param>
	},
	onCollectionChanging: function(args) {
		/// <summary>Raises the collectionChanging validation event.</summary>
		/// <param name="args" type="NotifyCollectionChangingEventArgs">NotifyCollectionChangingEventArgs. An instance of the NotifyCollectionChangingEventArgs class.</param>
	},
	onPropertyChanged: function(args) {
		/// <summary>Raises the propertyChanged event.</summary>
		/// <param name="args" type="PropertyChangedEventArgs">PropertyChangedEventArgs. An instance of the PropertyChangedEventArgs class.</param>
	},
	remove: function(item) {
		/// <summary>Deletes an object from the collection</summary>
		/// <param name="item" type="TObject">TObject. The item to remove.</param>
	},
	removeAt: function(itemIndex) {
		/// <summary>Delete the element at the specified index.</summary>
		/// <param name="itemIndex" type="Number">Number. The index to remove at.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Deletes a range of elements from the collection</summary>
		/// <param name="index" type="Number">Number. The starting index of the range to remove.</param>
		/// <param name="count" type="Number">Number. The length of the range to remove.</param>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Scheduling.ObservableCollection.__class = true;

MindFusion.Scheduling.Occurrence = {
	/// <summary>Specifies the index of occurrence.</summary>
	/// <field name="First">Indicates the first occurrence.</field>
	/// <field name="Fourth">Indicates the fourth occurrence.</field>
	/// <field name="Last">Indicates the last occurrence.</field>
	/// <field name="Second">Indicates the second occurrence.</field>
	/// <field name="Third">Indicates the third occurrence.</field>
	First: 0,
	Fourth: 3,
	Last: 4,
	Second: 1,
	Third: 2
}
MindFusion.Scheduling.Occurrence.__enum = true;

MindFusion.Scheduling.Orientation = {
	/// <summary>Specifies orientation for calendar elements.</summary>
	/// <field name="Horizontal">Indicates a horizontal orientation.</field>
	/// <field name="Vertical">Indicates a vertical orientation.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.Scheduling.Orientation.__enum = true;

MindFusion.Scheduling.PropertyChangedEventArgs.prototype = {
};
MindFusion.Scheduling.PropertyChangedEventArgs.__class = true;

MindFusion.Scheduling.PropertyChangedEventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event. Inherited from EventDispatcher.</summary>
		/// <param name="sender" type="void"></param>
		/// <param name="args" type="void"></param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event. Inherited from EventDispatcher.</summary>
		/// <param name="handler" type="void"></param>
	}
};
MindFusion.Scheduling.PropertyChangedEventDispatcher.__class = true;

MindFusion.Scheduling.PropertyEventArgs.prototype = {
};
MindFusion.Scheduling.PropertyEventArgs.__class = true;

MindFusion.Scheduling.Recurrence.prototype = {
	applyPattern: function(recurrence) {
		/// <summary>Copies the property values of the specified Recurrence object asvalues for the properties of this Recurrence object.This method behaves similarly to the clone method but does not create a new object.</summary>
		/// <param name="recurrence" type="Recurrence">Recurrence. The Recurrence object whose fields to copy.</param>
	},
	associateWith: function(master) {
		/// <summary>Associates the recurrence with the specified item. If the supplied reference is null,the recurrence is detached from the currently associated master.</summary>
		/// <param name="master" type="Item">Item. The item to associate with.</param>
	},
	clearExceptions: function() {
		/// <summary>Removes all exceptions of this Recurrence.</summary>
	},
	clone: function() {
		/// <summary>Creates an exact copy of this Recurrence object.</summary>
		/// <returns type="Recurrence">Recurrence. A new Recurrence object, identical to the current one.</returns>
	},
	fromJson: function(json) {
		/// <summary>Deserializes this recurrence from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	generateItems: function(startDate, endDate) {
		/// <summary>Creates occurrence items for this Recurrence in the specified date range.</summary>
		/// <param name="startDate" type="DateTime">DateTime. The range start date.</param>
		/// <param name="endDate" type="DateTime">DateTime. The range end date.</param>
		/// <returns type="Array">Array. A collection of Item instances representing each occurrence of the recurrent event in the specified date range.</returns>
	},
	getEndDate: function() {
		/// <summary>Returns the end date for this recurrence. The end date is calculated based on the specified repeat number if RecurrenceEnd *is set to NumOccurrences.</summary>
		/// <returns type="DateTime">DateTime. The end date of the recurrence if the recurrence is set to expire or DateTime.MaxValue otherwise.</returns>
	},
	getExceptions: function() {
		/// <summary>Gets a list with all recurrence exceptions.</summary>
		/// <returns type="Dictionary">Dictionary. A Dictionary with all the Exceptions.</returns>
	},
	getOccurrence: function(index, refIsDeleted, noException) {
		/// <summary>Returns the occurrence with the specified index.</summary>
		/// <param name="index" type="Number">Number. The index of the occurrence to retrieve.</param>
		/// <param name="refIsDeleted" type="*">*. If the specified occurrence is an exception, this parameterindicates upon function completion whether the exception is deleted or not.</param>
		/// <param name="noException" type="Boolean">Boolean. Specifies whether to return the original item, in case this occurrence is an exception.</param>
		/// <returns type="Item">Item. A reference to the occurrence with the specified index or null, if there is no such occurrence.</returns>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the recurrence content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the recurrence's serialized content.</param>
		/// <param name="context" type="MindFusion.Scheduling.XmlPersistContext">MindFusion.Scheduling.XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	markException: function(item, deleted, reminder) {
		/// <summary>Marks the specified item as an exception in the Recurrence pattern.</summary>
		/// <param name="item" type="Item">Item. The item to be marked as an exception.</param>
		/// <param name="deleted" type="Boolean" optional="true">Optional. Boolean. Specifies whether the exception is created by deleting oneoccurrence from the recurrent pattern or by changing the occurrence time properties.</param>
		/// <param name="reminder" type="*">*. For internal use.</param>
	},
	removeException: function(item) {
		/// <summary>Removes the exception associated with the specified item from the recurrence.</summary>
		/// <param name="item" type="Item">Item. The item whose exception to remove.</param>
	},
	samePatternAs: function(recurrence) {
		/// <summary>Determines whether two Recurrence objects define the same recurrence pattern.</summary>
		/// <param name="recurrence" type="Recurrence">Recurrence. A Recurrence object to compare with this recurrence.</param>
		/// <returns type="Boolean">Boolean. true if the Recurrence instances have the same recurrence pattern; otherwise false.</returns>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the recurrence content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the recurrence's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">MindFusion.Diagramming.XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this recurrence into a JSON string.</summary>
		/// <returns type="String">String. A string containing the recurrence's JSON representation.</returns>
	},
	toLocalizedString: function(formatInfo, localInfo) {
		/// <summary>Returns a localized string that represents this Recurrence using the specified dateand time formatting info and localization information.</summary>
		/// <param name="formatInfo" type="Object">Object. Specifies how date and time values are formatted and displayed.</param>
		/// <param name="localInfo" type="Object">Object. Specifies localized strings used in the representation.</param>
		/// <returns type="String">String. A localized string representation of this Recurrence object.</returns>
	}
};
MindFusion.Scheduling.Recurrence.__class = true;

MindFusion.Scheduling.RecurrenceEnd = {
	/// <summary>Specifies when to stop repeating recurring events.</summary>
	/// <field name="EndDate">The recurrence ends at a specified date.</field>
	/// <field name="Never">Never stop repeating events.</field>
	/// <field name="NumOccurrences">Stop repeating events after a specified number of occurrences.</field>
	EndDate: 2,
	Never: 0,
	NumOccurrences: 1
}
MindFusion.Scheduling.RecurrenceEnd.__enum = true;

MindFusion.Scheduling.RecurrencePattern = {
	/// <summary>Specifies the interval at which recurring events occur.</summary>
	/// <field name="ByTimeInterval">Repeats an event over a specified time interval.</field>
	/// <field name="Daily">Repeats an event every day.</field>
	/// <field name="Monthly">Repeats an event every month.</field>
	/// <field name="Weekly">Repeats an event every week.</field>
	/// <field name="Yearly">Repeats an event every year.</field>
	ByTimeInterval: 4,
	Daily: 0,
	Monthly: 2,
	Weekly: 1,
	Yearly: 3
}
MindFusion.Scheduling.RecurrencePattern.__enum = true;

MindFusion.Scheduling.RecurrenceState = {
	/// <summary>Specifies the recurrence state of items.</summary>
	/// <field name="Exception">Specifies an exception of a recurring event.</field>
	/// <field name="Master">Specifies a recurring event.</field>
	/// <field name="None">Specifies an one-time non-recurring event.</field>
	/// <field name="Occurrence">Specifies a single occurrence of a recurring event.</field>
	Exception: 2,
	Master: 3,
	None: 0,
	Occurrence: 1
}
MindFusion.Scheduling.RecurrenceState.__enum = true;

MindFusion.Scheduling.Reminder.prototype = {
	clone: function() {
		/// <summary>Returns an exact copy of this Reminder object.</summary>
		/// <returns type="Reminder">Reminder. The newly created Reminder object.</returns>
	},
	fromJson: function(json) {
		/// <summary>Deserializes this reminder from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the reminder content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the reminder's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the reminder content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the reminder's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this reminder into a JSON string.</summary>
		/// <returns type="String">String. A string containing the reminder's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Reminder.__class = true;

MindFusion.Scheduling.ReminderType = {
	/// <summary>Specifies the type of a reminder.</summary>
	/// <field name="Exact">Trigger the reminder at the exact time specified in its Date property.Note: Recurring items cannot have exact reminders.</field>
	/// <field name="Leading">Trigger the reminder at the specified TimeInterval before the item's scheduled start time.Note: Tasks cannot have leading reminders.</field>
	Exact: 0,
	Leading: 1
}
MindFusion.Scheduling.ReminderType.__enum = true;

MindFusion.Scheduling.Resource.prototype = {
	fromJson: function(json) {
		/// <summary>Deserializes this resource from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the resource content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the resource's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the resource content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the resource's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this resource into a JSON string.</summary>
		/// <returns type="String">String. A string containing the resource's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Resource.__class = true;

MindFusion.Scheduling.ResourceViewSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.ResourceViewSettings.__class = true;

MindFusion.Scheduling.ResourceViewTimeline = {
	/// <summary>Specifies the type of a timeline in a Resource view.</summary>
	/// <field name="Bottom">Indicates the bottom timeline.</field>
	/// <field name="Middle">Indicates the middle timeline.</field>
	/// <field name="Top">Indicates the top timeline.</field>
	Bottom: 2,
	Middle: 1,
	Top: 0
}
MindFusion.Scheduling.ResourceViewTimeline.__enum = true;

MindFusion.Scheduling.Schedule.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes the diagram from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromXmlDocument: function(document) {
		/// <summary>Loads schedule data from specified XML Document.</summary>
		/// <param name="document" type="Document">Document. A DOM Document object containing XML-serialized schedule data.</param>
	},
	getAllItems: function(startTime, endTime, resource) {
		/// <summary>Retrieves all events, including recurrent item instances, scheduled to occur in the specified time interval.</summary>
		/// <param name="startTime" type="DateTime">DateTime. Time interval start.</param>
		/// <param name="endTime" type="DateTime" optional="true">Optional. DateTime. Time interval end.</param>
		/// <param name="resource" type="Resource" optional="true">Optional. Resource. A resource that must be related to the event.</param>
		/// <returns type="List">List. The list of events scheduled to occur in the specified period.</returns>
	},
	getItemById: function(id, occurrenceIndex) {
		/// <summary>Gets the item with the specified id.</summary>
		/// <param name="id" type="String">String. The id of the item.</param>
		/// <param name="occurrenceIndex" type="Number" optional="true">Optional. Number. The occurrence index of the item.</param>
		/// <returns type="Item">Item. The item; null if no item with the specified id has been found.</returns>
	},
	getMasterById: function(id) {
		/// <summary>In a recurrence, gets the recurrence master item with the specified id.</summary>
		/// <param name="id" type="String">String. The id of the master item.</param>
		/// <returns type="Item">Item. The item; null if no master item with the specified id has been found.</returns>
	},
	getResourceById: function(id) {
		/// <summary>Returns a resource from a schedule resource collection by a specified id.</summary>
		/// <param name="id" type="String">String. The id of the resource.</param>
		/// <returns type="Resource">Resource. The resource object if found, null otherwise.</returns>
	},
	loadFromXml: function(fileUrl, onLoad, onError) {
		/// <summary>Loads the schedule from an XML file.</summary>
		/// <param name="fileUrl" type="String">String. The URL of an XML file where the data should be read from.</param>
		/// <param name="onLoad" type="function" optional="true">Optional. function. A callback that should be invoked if the file is loaded successfully.</param>
		/// <param name="onError" type="function" optional="true">Optional. function. A callback that should be invoked if the file could not be downloaded.</param>
	},
	saveToXml: function(url) {
		/// <summary>Saves the schedule to an XML file.</summary>
		/// <param name="url" type="String">String. A URL specifying where the schedule's XML should be posted to.</param>
	},
	toJson: function() {
		/// <summary>Serializes the schedule into a JSON string.</summary>
		/// <returns type="String">String. A string containing the schedule's JSON representation.</returns>
	},
	toXmlDocument: function() {
		/// <summary>Saves the schedule into an XML Document.</summary>
		/// <returns type="Document">Document. A DOM Document object containing XML-serialized schedule contents.</returns>
	}
};
MindFusion.Scheduling.Schedule.__class = true;

MindFusion.Scheduling.Selection.prototype = {
	clear: function() {
		/// <summary>Clears the selection.</summary>
	},
	getRange: function() {
		/// <summary>Gets the selection range.</summary>
		/// <returns type="TimeRange">TimeRange. The selected time range.</returns>
	},
	isEmpty: function() {
		/// <summary>Checks if the selection is empty.</summary>
		/// <returns type="Boolean">Boolean. true if the selection is empty; otherwise false.</returns>
	},
	setRange: function(start, end, resource) {
		/// <summary>Sets the selection range.</summary>
		/// <param name="start" type="DateTime">DateTime. The start time of the selection.</param>
		/// <param name="end" type="DateTime" optional="true">Optional. DateTime. The end time of the selection.</param>
		/// <param name="resource" type="Resource" optional="true">Optional. Resource. The associated resource.</param>
	}
};
MindFusion.Scheduling.Selection.__class = true;

MindFusion.Scheduling.SelectionEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.SelectionEventArgs.__class = true;

MindFusion.Scheduling.Task.prototype = {
	fromJson: function(json) {
		/// <summary>Deserializes this task from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	loadFromXml: function(element, context) {
		/// <summary>Loads the task content from an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that contains the task's serialized content.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(element, context) {
		/// <summary>Saves the task content into an XML element.</summary>
		/// <param name="element" type="Element">Element. An XML DOM element that will contain the task's data.</param>
		/// <param name="context" type="XmlPersistContext">XmlPersistContext. An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	toJson: function() {
		/// <summary>Serializes this task into a JSON string.</summary>
		/// <returns type="String">String. A string containing the task's JSON representation.</returns>
	}
};
MindFusion.Scheduling.Task.__class = true;

MindFusion.Scheduling.TaskEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Scheduling.TaskEventArgs.__class = true;

MindFusion.Scheduling.TaskPriority = {
	/// <summary>Specifies the priority of a task.</summary>
	/// <field name="High">Indicates high task priority.</field>
	/// <field name="Low">Indicates low task priority.</field>
	/// <field name="Normal">Indicates normal task priority.</field>
	High: 2,
	Low: 0,
	Normal: 1
}
MindFusion.Scheduling.TaskPriority.__enum = true;

MindFusion.Scheduling.TaskStatus = {
	/// <summary>Specifies status values for a task.</summary>
	/// <field name="Completed">Indicates a completed task.</field>
	/// <field name="Deferred">Indicates a deferred task.</field>
	/// <field name="InProgress">Indicates a task in progress.</field>
	/// <field name="NotStarted">Indicates that the task has not started yet.</field>
	/// <field name="WaitingOther">Indicates a task that depends on another task.</field>
	Completed: 2,
	Deferred: 4,
	InProgress: 1,
	NotStarted: 0,
	WaitingOther: 3
}
MindFusion.Scheduling.TaskStatus.__enum = true;

MindFusion.Scheduling.TimelineSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.TimelineSettings.__class = true;

MindFusion.Scheduling.TimeRange.prototype = {
	contains: function(range) {
		/// <summary>Checks if the current range contains the specified range.</summary>
		/// <param name="range" type="TimeRange">TimeRange. The range of DateTime values to check.</param>
		/// <returns type="Boolean">Boolean. true if the current range contains the specified range; otherwise false.</returns>
	},
	equals: function(range) {
		/// <summary>Checks if the specified range contains the same date-time as the current instance.</summary>
		/// <param name="range" type="TimeRange">TimeRange. The range of DateTime values to check.</param>
		/// <returns type="Boolean">Boolean. true if the ranges are equal; otherwise false.</returns>
	},
	intersects: function(range) {
		/// <summary>Checks if the current range intersects with the specified range.</summary>
		/// <param name="range" type="TimeRange">TimeRange. The range of DateTime values to check.</param>
		/// <returns type="Boolean">Boolean. true if the current range intersects with the specified range; otherwise false.</returns>
	},
	sameEnd: function(range) {
		/// <summary>Checks if the current range ends at the same time as the specified range.</summary>
		/// <param name="range" type="TimeRange">TimeRange. The range of DateTime values to compare to.</param>
		/// <returns type="Boolean">Boolean. true if the current range ends at the same time with the specified range; otherwise false.</returns>
	},
	sameStart: function(range) {
		/// <summary>Checks if the current range starts at the same time as the specified range.</summary>
		/// <param name="range" type="TimeRange">TimeRange. The range of DateTime values to compare to.</param>
		/// <returns type="Boolean">Boolean. true if the current range starts at the same time with the specified range; otherwise false.</returns>
	}
};
MindFusion.Scheduling.TimeRange.__class = true;

MindFusion.Scheduling.TimeSpan.prototype = {
	add: function(timespan) {
		/// <summary>Returns a new TimeSpan object whose value is the sum of the specified TimeSpan object and this instance.</summary>
		/// <param name="timespan" type="TimeSpan">TimeSpan. The TimeSpan object to add.</param>
		/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
	},
	clone: function() {
		/// <summary>Creates a copy of the time span.</summary>
		/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
	},
	equals: function(timespan) {
		/// <summary>Checks if the time span object represents the same time value as the current instance.</summary>
		/// <param name="timespan" type="TimeSpan">TimeSpan. The timespan to check.</param>
		/// <returns type="Boolean">Boolean. True if the time spans represent the same time value, otherwise false.</returns>
	},
	subtract: function(timespan) {
		/// <summary>Returns a new TimeSpan object whose value is the difference between the specified TimeSpan object and this instance.</summary>
		/// <param name="timespan" type="TimeSpan">TimeSpan. The TimeSpan object to subtract.</param>
		/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
	}
};
MindFusion.Scheduling.TimeSpan.__class = true;

MindFusion.Scheduling.TimeSpan.fromDays = function(days) {
	/// <summary>Returns a TimeSpan that represents a specified number of days.</summary>
	/// <param name="days" type="Number">Number. The number of days.</param>
	/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
};
MindFusion.Scheduling.TimeSpan.fromHours = function(hours) {
	/// <summary>Returns a TimeSpan that represents a specified number of hours.</summary>
	/// <param name="hours" type="Number">Number. The number of hours.</param>
	/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
};
MindFusion.Scheduling.TimeSpan.fromMilliseconds = function(milliseconds) {
	/// <summary>Returns a TimeSpan that represents a specified number of milliseconds.</summary>
	/// <param name="milliseconds" type="Number">Number. The number of milliseconds.</param>
	/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
};
MindFusion.Scheduling.TimeSpan.fromMinutes = function(minutes) {
	/// <summary>Returns a TimeSpan that represents a specified number of minutes.</summary>
	/// <param name="minutes" type="Number">Number. The number of minutes.</param>
	/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
};
MindFusion.Scheduling.TimeSpan.fromSeconds = function(seconds) {
	/// <summary>Returns a TimeSpan that represents a specified number of seconds.</summary>
	/// <param name="seconds" type="Number">Number. The number of seconds.</param>
	/// <returns type="TimeSpan">TimeSpan. The resulting time span.</returns>
};

MindFusion.Scheduling.TimetableSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.TimetableSettings.__class = true;

MindFusion.Scheduling.TimeUnit = {
	/// <summary>Specifies a time resolution.</summary>
	/// <field name="Day">Specifies days.</field>
	/// <field name="Hour">Specifies hours.</field>
	/// <field name="Minute">Specifies minutes.</field>
	/// <field name="Month">Specifies months.</field>
	/// <field name="Second">Specifies seconds.</field>
	/// <field name="Week">Specifies weeks.</field>
	/// <field name="Year">Specifies years.</field>
	Day: 3,
	Hour: 2,
	Minute: 1,
	Month: 5,
	Second: 0,
	Week: 4,
	Year: 6
}
MindFusion.Scheduling.TimeUnit.__enum = true;

MindFusion.Scheduling.VerticalHeaderStyle = {
	/// <summary>Specifies the appearance of a vertical header in the calendar.</summary>
	/// <field name="Left">The header is displayed to the left side of the calendar.</field>
	/// <field name="None">The header is not displayed.</field>
	/// <field name="Right">The header is displayed to the right side of the calendar.</field>
	Left: 1,
	None: 0,
	Right: 2
}
MindFusion.Scheduling.VerticalHeaderStyle.__enum = true;

MindFusion.Scheduling.ViewCell.prototype = {
};
MindFusion.Scheduling.ViewCell.__class = true;

MindFusion.Scheduling.WeekRangeSettings.prototype = {
	copyFrom: function(settings) {
		/// <summary>Copies property values from another object.</summary>
		/// <param name="settings" type="Object">Object. An object containing property values.</param>
	}
};
MindFusion.Scheduling.WeekRangeSettings.__class = true;

MindFusion.Scheduling.WeekRangeViewStyle = {
	/// <summary>Specifies whether there are multiple weeks displayed in WeekRange view.</summary>
	/// <field name="SingleWeek">The calendar view displays a single week at a time.</field>
	/// <field name="WeekPerRow">The calendar view displays several weeks at a time.</field>
	SingleWeek: 1,
	WeekPerRow: 0
}
MindFusion.Scheduling.WeekRangeViewStyle.__enum = true;

MindFusion.Scheduling.YearlyRecurrence = {
	/// <summary>Specifies types of yearly recurrence patterns.</summary>
	/// <field name="ByDayType">The event occurs on a specific type of day of the specified week and month of the year.</field>
	/// <field name="SpecificDate">The event occurs on a specific date of the year.</field>
	ByDayType: 1,
	SpecificDate: 0
}
MindFusion.Scheduling.YearlyRecurrence.__enum = true;

MindFusion.UI.CancelEventArgs.prototype = {
};
MindFusion.UI.CancelEventArgs.__class = true;

MindFusion.UI.ConfirmDialog.prototype = {
	draw: function() {
		/// <summary>Dialog.draw override.</summary>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	autoSize: function() {
		/// <summary>Resizes the window to fit its contents. Inherited from Window.</summary>
	},
	center: function(rect) {
		/// <summary>Positions the window in the center of its host element or specified rect. Inherited from Window.</summary>
		/// <param name="rect" type="Rect" optional="true">Optional. Rect. The rect to center in.</param>
	},
	close: function() {
		/// <summary>Closes the window. Inherited from Window.</summary>
	},
	doClose: function() {
		/// <summary>Closes the window without raising events. Inherited from Window.</summary>
	},
	doOpen: function() {
		/// <summary>Opens the window without raising events. Inherited from Window.</summary>
	},
	maximize: function() {
		/// <summary>Maximizes the window. Inherited from Window.</summary>
	},
	minimize: function() {
		/// <summary>Minimizes the window. Inherited from Window.</summary>
	},
	open: function() {
		/// <summary>Shows the window. Inherited from Window.</summary>
	},
	pin: function() {
		/// <summary>Pins the window. Pinned windows cannot be moved or resized. Inherited from Window.</summary>
	},
	refresh: function() {
		/// <summary>Reloads the window iframe. Inherited from Window.</summary>
	},
	restore: function() {
		/// <summary>Restores the window to a normal state. Inherited from Window.</summary>
	},
	unpin: function() {
		/// <summary>Unpins the window. Inherited from Window.</summary>
	},
	updateBounds: function(autoSize) {
		/// <summary>Updates window dimensions after applying changes to DOM elements. Inherited from Window.</summary>
		/// <param name="autoSize" type="Boolean" optional="true">Optional. Boolean. True to autosize the window, otherwise false.</param>
	}
};
MindFusion.UI.ConfirmDialog.__class = true;

MindFusion.UI.Container.prototype = {
	attach: function() {
		/// <summary>Control.attach override.</summary>
	},
	bringToFront: function(window) {
		/// <summary>Brings a child window to the front, effectively making it topmost and active.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The window to bring to front.</param>
	},
	detach: function() {
		/// <summary>Control.detach override.</summary>
	},
	dispose: function() {
		/// <summary>Control.dispose override.</summary>
	},
	fit: function(window) {
		/// <summary>Ensures that a child window fits into content bounds.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The child window to check.</param>
	},
	sendToBack: function(window) {
		/// <summary>Sends a child window to the back.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The window to send to back.</param>
	},
	draw: function() {
		/// <summary>Draws the control. Inherited from Control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	}
};
MindFusion.UI.Container.__class = true;

MindFusion.UI.Control.prototype = {
	attach: function() {
		/// <summary>Attach control event handlers.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control.</summary>
	},
	draw: function() {
		/// <summary>Draws the control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction.</summary>
	}
};
MindFusion.UI.Control.__class = true;

MindFusion.UI.ControlModifiedEventArgs.prototype = {
};
MindFusion.UI.ControlModifiedEventArgs.__class = true;

MindFusion.UI.ControlModifyingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.UI.ControlModifyingEventArgs.__class = true;

MindFusion.UI.ControlState = {
	/// <summary>Specifies a control state.</summary>
	/// <field name="Loaded">The control is loaded and ready for interaction.</field>
	/// <field name="Unloaded">The control is unloaded.</field>
	Loaded: 0,
	Unloaded: 1
}
MindFusion.UI.ControlState.__enum = true;

MindFusion.UI.Dialog.prototype = {
	attach: function() {
		/// <summary>Window.attach override.</summary>
	},
	detach: function() {
		/// <summary>Window.detach override.</summary>
	},
	draw: function() {
		/// <summary>Window.draw override.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	autoSize: function() {
		/// <summary>Resizes the window to fit its contents. Inherited from Window.</summary>
	},
	center: function(rect) {
		/// <summary>Positions the window in the center of its host element or specified rect. Inherited from Window.</summary>
		/// <param name="rect" type="Rect" optional="true">Optional. Rect. The rect to center in.</param>
	},
	close: function() {
		/// <summary>Closes the window. Inherited from Window.</summary>
	},
	doClose: function() {
		/// <summary>Closes the window without raising events. Inherited from Window.</summary>
	},
	doOpen: function() {
		/// <summary>Opens the window without raising events. Inherited from Window.</summary>
	},
	maximize: function() {
		/// <summary>Maximizes the window. Inherited from Window.</summary>
	},
	minimize: function() {
		/// <summary>Minimizes the window. Inherited from Window.</summary>
	},
	open: function() {
		/// <summary>Shows the window. Inherited from Window.</summary>
	},
	pin: function() {
		/// <summary>Pins the window. Pinned windows cannot be moved or resized. Inherited from Window.</summary>
	},
	refresh: function() {
		/// <summary>Reloads the window iframe. Inherited from Window.</summary>
	},
	restore: function() {
		/// <summary>Restores the window to a normal state. Inherited from Window.</summary>
	},
	unpin: function() {
		/// <summary>Unpins the window. Inherited from Window.</summary>
	},
	updateBounds: function(autoSize) {
		/// <summary>Updates window dimensions after applying changes to DOM elements. Inherited from Window.</summary>
		/// <param name="autoSize" type="Boolean" optional="true">Optional. Boolean. True to autosize the window, otherwise false.</param>
	}
};
MindFusion.UI.Dialog.__class = true;

MindFusion.UI.Dialogs.prototype = {
};
MindFusion.UI.Dialogs.__class = true;

MindFusion.UI.Dialogs.showConfirmDialog = function(title, message, callback, parentElement, theme) {
	/// <summary>Shows a confirm dialog, which displays a message and OK and Cancel buttons.</summary>
	/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
	/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
	/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.The dialog's modalResult will be passed as a parameter to the callback function.</param>
	/// <param name="parentElement" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
	/// <param name="theme" type="String" optional="true">Optional. String. The theme of the dialog.</param>
};
MindFusion.UI.Dialogs.showInfoDialog = function(title, message, callback, parentElement, theme) {
	/// <summary>Shows an info dialog, which displays a message and an OK button.</summary>
	/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
	/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
	/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.</param>
	/// <param name="parentElement" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
	/// <param name="theme" type="String" optional="true">Optional. String. The theme of the dialog.</param>
};
MindFusion.UI.Dialogs.showInputDialog = function(title, message, callback, parentElement, input, property, theme) {
	/// <summary>Shows an input dialog, which displays a message, a custom input control and OK and Cancel buttons.</summary>
	/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
	/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
	/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.The dialog's modalResult will be passed as the first, and the specified property value of the input control will be passed as the second parameter to the callback function.</param>
	/// <param name="parentElement" type="HTMLElement" optional="true">Optional. HTMLElement. The Dom element to append the dialog to.If the parameter is not specified, the dialog will be appended to document.body.</param>
	/// <param name="input" type="HTMLElement" optional="true">Optional. HTMLElement. The input control to show in the dialog. If the parameter is not specified, an empty HTML text input will be displayed.</param>
	/// <param name="property" type="String" optional="true">Optional. String. The name of the property of the input control, whose value will be passed as the second argument to the callback function.If the parameter is not specified, the value property will be used.</param>
	/// <param name="theme" type="String" optional="true">Optional. String. The theme of the dialog.</param>
};

MindFusion.UI.Dictionary.prototype = {
	contains: function(key) {
		/// <summary>Determines whether the dictionary contains a specific key.</summary>
		/// <param name="key" type="Object">Object. The key to locate in the dictionary.</param>
		/// <returns type="Boolean">Boolean. true if the element exists in the collection, otherwise false.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object" optional="true">Optional. Object. The invokation context.</param>
	},
	get: function(key) {
		/// <summary>Gets the value associated with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key whose value to get.</param>
	},
	remove: function(key) {
		/// <summary>Removes the element with the specified key from the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key of the element to remove.</param>
	},
	set: function(key, value) {
		/// <summary>Associates the specified value with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key to associate the value with.</param>
		/// <param name="value" type="Object">Object. The value to associate.</param>
	}
};
MindFusion.UI.Dictionary.__class = true;

MindFusion.UI.DragDropEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.UI.DragDropEventArgs.__class = true;

MindFusion.UI.EmptyEventArgs.prototype = {
};
MindFusion.UI.EmptyEventArgs.__class = true;

MindFusion.UI.EventArgs.prototype = {
};
MindFusion.UI.EventArgs.__class = true;

MindFusion.UI.EventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event.</summary>
		/// <param name="handler" type="function">function. The handler function.</param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event.</summary>
		/// <param name="sender" type="Object">Object. The source of the event.</param>
		/// <param name="args" type="Object">Object. An object, containing event data.</param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event.</summary>
		/// <param name="handler" type="function">function. The handler function.</param>
	}
};
MindFusion.UI.EventDispatcher.__class = true;

MindFusion.UI.IEnumerable.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection.</summary>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection.</summary>
		/// <returns type="IEnumerable">IEnumerable. A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection.</summary>
		/// <param name="item" type="Object">Object. The object to check for.</param>
		/// <returns type="Boolean">Boolean. True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection.</summary>
		/// <param name="destination" type="IEnumerable">IEnumerable. The destination collection.</param>
		/// <param name="length" type="Number">Number. The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. Number. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. Number. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements.</summary>
		/// <returns type="Number">Number. The number of elements.</returns>
	},
	first: function() {
		/// <summary>Returns the first element in the collection.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection.</summary>
		/// <param name="obj" type="Object">Object. The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. Number. The starting index to search from.</param>
		/// <returns type="Number">Number. The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <returns type="Object">Object. The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection.</returns>
	},
	last: function() {
		/// <summary>Returns the last element in the collection.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns the maximum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection.</summary>
		/// <param name="item" type="Object">Object. The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index.</summary>
		/// <param name="index" type="Number">Number. The starting index of the range.</param>
		/// <param name="count" type="Number">Number. The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array.</summary>
		/// <param name="compareFn" type="function" optional="true">Optional. function. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that are obtained by invoking a transform function on each element.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection.</summary>
		/// <returns type="Array">Array. The array.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.UI.IEnumerable.__class = true;

MindFusion.UI.InfoDialog.prototype = {
	draw: function() {
		/// <summary>Dialog.draw override.</summary>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	autoSize: function() {
		/// <summary>Resizes the window to fit its contents. Inherited from Window.</summary>
	},
	center: function(rect) {
		/// <summary>Positions the window in the center of its host element or specified rect. Inherited from Window.</summary>
		/// <param name="rect" type="Rect" optional="true">Optional. Rect. The rect to center in.</param>
	},
	close: function() {
		/// <summary>Closes the window. Inherited from Window.</summary>
	},
	doClose: function() {
		/// <summary>Closes the window without raising events. Inherited from Window.</summary>
	},
	doOpen: function() {
		/// <summary>Opens the window without raising events. Inherited from Window.</summary>
	},
	maximize: function() {
		/// <summary>Maximizes the window. Inherited from Window.</summary>
	},
	minimize: function() {
		/// <summary>Minimizes the window. Inherited from Window.</summary>
	},
	open: function() {
		/// <summary>Shows the window. Inherited from Window.</summary>
	},
	pin: function() {
		/// <summary>Pins the window. Pinned windows cannot be moved or resized. Inherited from Window.</summary>
	},
	refresh: function() {
		/// <summary>Reloads the window iframe. Inherited from Window.</summary>
	},
	restore: function() {
		/// <summary>Restores the window to a normal state. Inherited from Window.</summary>
	},
	unpin: function() {
		/// <summary>Unpins the window. Inherited from Window.</summary>
	},
	updateBounds: function(autoSize) {
		/// <summary>Updates window dimensions after applying changes to DOM elements. Inherited from Window.</summary>
		/// <param name="autoSize" type="Boolean" optional="true">Optional. Boolean. True to autosize the window, otherwise false.</param>
	}
};
MindFusion.UI.InfoDialog.__class = true;

MindFusion.UI.InputDialog.prototype = {
	attach: function() {
		/// <summary>Dialog.attach override.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	draw: function() {
		/// <summary>Draws the control. Inherited from Control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	autoSize: function() {
		/// <summary>Resizes the window to fit its contents. Inherited from Window.</summary>
	},
	center: function(rect) {
		/// <summary>Positions the window in the center of its host element or specified rect. Inherited from Window.</summary>
		/// <param name="rect" type="Rect" optional="true">Optional. Rect. The rect to center in.</param>
	},
	close: function() {
		/// <summary>Closes the window. Inherited from Window.</summary>
	},
	doClose: function() {
		/// <summary>Closes the window without raising events. Inherited from Window.</summary>
	},
	doOpen: function() {
		/// <summary>Opens the window without raising events. Inherited from Window.</summary>
	},
	maximize: function() {
		/// <summary>Maximizes the window. Inherited from Window.</summary>
	},
	minimize: function() {
		/// <summary>Minimizes the window. Inherited from Window.</summary>
	},
	open: function() {
		/// <summary>Shows the window. Inherited from Window.</summary>
	},
	pin: function() {
		/// <summary>Pins the window. Pinned windows cannot be moved or resized. Inherited from Window.</summary>
	},
	refresh: function() {
		/// <summary>Reloads the window iframe. Inherited from Window.</summary>
	},
	restore: function() {
		/// <summary>Restores the window to a normal state. Inherited from Window.</summary>
	},
	unpin: function() {
		/// <summary>Unpins the window. Inherited from Window.</summary>
	},
	updateBounds: function(autoSize) {
		/// <summary>Updates window dimensions after applying changes to DOM elements. Inherited from Window.</summary>
		/// <param name="autoSize" type="Boolean" optional="true">Optional. Boolean. True to autosize the window, otherwise false.</param>
	}
};
MindFusion.UI.InputDialog.__class = true;

MindFusion.UI.InteractionEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.UI.InteractionEventArgs.__class = true;

MindFusion.UI.InteractionType = {
	/// <summary>Specifies a type of interaction.</summary>
	/// <field name="Drag">Indicates drag interaction.</field>
	/// <field name="Resize">Indicates resize interaction.</field>
	Drag: 0,
	Resize: 1
}
MindFusion.UI.InteractionType.__enum = true;

MindFusion.UI.ItemEventArgs.prototype = {
};
MindFusion.UI.ItemEventArgs.__class = true;

MindFusion.UI.List.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection. Inherited from IEnumerable.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <param name="item" type="T">The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The starting index of the range.</param>
		/// <param name="count" type="Number">The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.UI.List.__class = true;

MindFusion.UI.ListContainer.prototype = {
	attach: function() {
		/// <summary>Control.attach override.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	detach: function() {
		/// <summary>Control.detach override.</summary>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads items from a data object.</summary>
		/// <param name="data" type="Object">Object. The object containing the items data.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	draw: function() {
		/// <summary>Draws the control. Inherited from Control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	}
};
MindFusion.UI.ListContainer.__class = true;

MindFusion.UI.ListItem.prototype = {
	draw: function() {
		/// <summary>Draws the item.</summary>
		/// <returns type="HTMLElement">HTMLElement. The item DOM element.</returns>
	}
};
MindFusion.UI.ListItem.__class = true;

MindFusion.UI.ListView.prototype = {
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string. Inherited from ListContainer.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads items from a data object. Inherited from ListContainer.</summary>
		/// <param name="data" type="Object">Object. The object containing the items data.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	}
};
MindFusion.UI.ListView.__class = true;

MindFusion.UI.Menu.prototype = {
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads the menu items from a data object.</summary>
		/// <param name="data" type="Object">Object. The object containing the menu data.</param>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	}
};
MindFusion.UI.Menu.__class = true;

MindFusion.UI.MenuItem.prototype = {
	draw: function() {
		/// <summary>TreeNode.draw override.</summary>
	}
};
MindFusion.UI.MenuItem.__class = true;

MindFusion.UI.ModalResult = {
	/// <summary>Represents the return value of a modal dialog.</summary>
	/// <field name="Cancel">The dialog was closed using the Cancel button.</field>
	/// <field name="None">Default value.</field>
	/// <field name="OK">The dialog was closed using the OK button.</field>
	Cancel: 2,
	None: 0,
	OK: 1
}
MindFusion.UI.ModalResult.__enum = true;

MindFusion.UI.NotifyCollectionChangedAction.prototype = {
};
MindFusion.UI.NotifyCollectionChangedAction.__class = true;

MindFusion.UI.NotifyCollectionChangedEventArgs.prototype = {
};
MindFusion.UI.NotifyCollectionChangedEventArgs.__class = true;

MindFusion.UI.NotifyCollectionChangingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.UI.NotifyCollectionChangingEventArgs.__class = true;

MindFusion.UI.ObservableCollection.prototype = {
	add: function(item) {
		/// <summary>Adds an item to the collection.</summary>
		/// <param name="item" type="Object">Object. The item to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	insert: function(index, item) {
		/// <summary>Adds an item to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	remove: function(item) {
		/// <summary>Deletes an item from the collection.</summary>
		/// <param name="item" type="Object">Object. The item to remove.</param>
	},
	removeAt: function(itemIndex) {
		/// <summary>Delete the item at the specified index.</summary>
		/// <param name="itemIndex" type="Number">Number. The index to remove at.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Deletes a range of items from the collection.</summary>
		/// <param name="index" type="Number">Number. The starting index of the range to remove.</param>
		/// <param name="count" type="Number">Number. The length of the range to remove.</param>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.UI.ObservableCollection.__class = true;

MindFusion.UI.Orientation = {
	/// <summary>Specifies orientation.</summary>
	/// <field name="Horizontal">Indicates a horizontal orientation.</field>
	/// <field name="Vertical">Indicates a vertical orientation.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.UI.Orientation.__enum = true;

MindFusion.UI.PropertyEventArgs.prototype = {
};
MindFusion.UI.PropertyEventArgs.__class = true;

MindFusion.UI.SelectedItemChangedEventArgs.prototype = {
};
MindFusion.UI.SelectedItemChangedEventArgs.__class = true;

MindFusion.UI.SelectedItemChangingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.UI.SelectedItemChangingEventArgs.__class = true;

MindFusion.UI.TabControl.prototype = {
	attach: function() {
		/// <summary>ListContainer.attach override.</summary>
	},
	deselectItem: function(item) {
		/// <summary>ListContainer.deselectItem override.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	detach: function() {
		/// <summary>ListContainer.detach override.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	selectItem: function(item) {
		/// <summary>ListContainer.selectItem override.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string. Inherited from ListContainer.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads items from a data object. Inherited from ListContainer.</summary>
		/// <param name="data" type="Object">Object. The object containing the items data.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	}
};
MindFusion.UI.TabControl.__class = true;

MindFusion.UI.TabPage.prototype = {
	draw: function() {
		/// <summary>ListItem.draw override.</summary>
	}
};
MindFusion.UI.TabPage.__class = true;

MindFusion.UI.TabStrip.prototype = {
	draw: function() {
		/// <summary>ToolStrip.draw override.</summary>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string. Inherited from ListContainer.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads items from a data object. Inherited from ListContainer.</summary>
		/// <param name="data" type="Object">Object. The object containing the items data.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	},
	collapse: function() {
		/// <summary>Collapses the toolstrip. Inherited from ToolStrip.</summary>
	},
	expand: function() {
		/// <summary>Expands the toolstrip. Inherited from ToolStrip.</summary>
	}
};
MindFusion.UI.TabStrip.__class = true;

MindFusion.UI.TemplatedItem.prototype = {
};
MindFusion.UI.TemplatedItem.__class = true;

MindFusion.UI.ToggleMode = {
	/// <summary>Specifies how expand/collapse of tree nodes will be triggered.</summary>
	/// <field name="HeaderClick">Indicates that expand/collapse will be triggered by a click on the node header.</field>
	/// <field name="IconClick">Indicates that expand/collapse will be triggered by a click on the +/- icon in the node header.</field>
	HeaderClick: 0,
	IconClick: 1
}
MindFusion.UI.ToggleMode.__enum = true;

MindFusion.UI.ToolStrip.prototype = {
	attach: function() {
		/// <summary>ListContainer.attach override.</summary>
	},
	collapse: function() {
		/// <summary>Collapses the toolstrip.</summary>
	},
	detach: function() {
		/// <summary>ListContainer.detach override.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	expand: function() {
		/// <summary>Expands the toolstrip.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string. Inherited from ListContainer.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads items from a data object. Inherited from ListContainer.</summary>
		/// <param name="data" type="Object">Object. The object containing the items data.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	}
};
MindFusion.UI.ToolStrip.__class = true;

MindFusion.UI.ToolStripItem.prototype = {
	draw: function() {
		/// <summary>ListItem.draw override.</summary>
	}
};
MindFusion.UI.ToolStripItem.__class = true;

MindFusion.UI.ToolStripItemType = {
	/// <summary>Specifies how a toolStrip item is displayed.</summary>
	/// <field name="Default">An empty item.</field>
	/// <field name="Icon">The item displays an image.</field>
	/// <field name="Label">The item displays a label.</field>
	/// <field name="Separator">The item displays a separator bar.</field>
	Default: 0,
	Icon: 3,
	Label: 2,
	Separator: 1
}
MindFusion.UI.ToolStripItemType.__enum = true;

MindFusion.UI.Tooltip.prototype = {
	attach: function() {
		/// <summary>Control.attach override.</summary>
	},
	detach: function() {
		/// <summary>Control.detach override.</summary>
	},
	doHide: function() {
		/// <summary>Hides the tooltip without raising events.</summary>
	},
	doShow: function() {
		/// <summary>Shows the tooltip without raising events.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	hide: function() {
		/// <summary>Hides the tooltip.</summary>
	},
	render: function() {
		/// <summary>Control.render override.</summary>
	},
	show: function(position) {
		/// <summary>Shows the tooltip.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point" optional="true">Optional. MindFusion.Drawing.Point. The point at which to display the tooltip if its position is set to TooltipPosition.Cursor.</param>
	},
	toggle: function() {
		/// <summary>Toggles the tooltip's visibility.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	}
};
MindFusion.UI.Tooltip.__class = true;

MindFusion.UI.TooltipPosition = {
	/// <summary>Specifies the position of a tooltip relative to its target element.</summary>
	/// <field name="Bottom">Indicates that the tooltip will be shown below the target element.</field>
	/// <field name="Center">Indicates that the tooltip will be shown at the center of the target element.</field>
	/// <field name="Cursor">Indicates that the tooltip will be shown at the position of the mouse cursor.</field>
	/// <field name="Left">Indicates that the tooltip will be shown at the left side of the target element.</field>
	/// <field name="Right">Indicates that the tooltip will be shown at the right side of the target element.</field>
	/// <field name="Top">Indicates that the tooltip will be shown above the target element.</field>
	Bottom: 3,
	Center: 4,
	Cursor: 5,
	Left: 0,
	Right: 1,
	Top: 2
}
MindFusion.UI.TooltipPosition.__enum = true;

MindFusion.UI.TooltipTrigger = {
	/// <summary>Specifies the event, which shows the tooltip.</summary>
	/// <field name="Click">Indicates that the tooltip will be shown when the target element is clicked.</field>
	/// <field name="Focus">Indicates that the tooltip will be shown when the target element is focused.</field>
	/// <field name="Hover">Indicates that the tooltip will be shown when the target element is hovered.</field>
	/// <field name="None">Indicates that the tooltip display will be triggered manually.</field>
	Click: 2,
	Focus: 1,
	Hover: 0,
	None: -1
}
MindFusion.UI.TooltipTrigger.__enum = true;

MindFusion.UI.TreeNode.prototype = {
	draw: function() {
		/// <summary>ListItem.draw override.</summary>
	}
};
MindFusion.UI.TreeNode.__class = true;

MindFusion.UI.TreeView.prototype = {
	deselectNode: function(node, deselectChildren) {
		/// <summary>Deselects a tree node.</summary>
		/// <param name="node" type="TreeNode">TreeNode. The node to deselect.</param>
		/// <param name="deselectChildren" type="Boolean" optional="true">Optional. Boolean. True to deselect all of the node's children, otherwise false.</param>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	fromJson: function(json) {
		/// <summary>Deserializes items from a JSON string.</summary>
		/// <param name="json" type="String">String. A string created by the toJson method.</param>
	},
	fromObject: function(data) {
		/// <summary>Loads the tree view items from a data object.</summary>
		/// <param name="data" type="Object">Object. The object containing the tree view data.</param>
	},
	selectNode: function(node, selectChildren) {
		/// <summary>Selects a tree node.</summary>
		/// <param name="node" type="TreeNode">TreeNode. The node to select.</param>
		/// <param name="selectChildren" type="Boolean" optional="true">Optional. Boolean. True to select all of the node's children, otherwise false.</param>
	},
	attach: function() {
		/// <summary>Attach control event handlers. Inherited from Control.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers. Inherited from Control.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	},
	deselectItem: function(item) {
		/// <summary>Deselects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to deselect.</param>
	},
	getItemAt: function(point) {
		/// <summary>Gets the item at the specified point. Inherited from ListContainer.</summary>
		/// <param name="point" type="Point">Point. The point to check.</param>
		/// <returns type="ListItem">ListItem. The item at the specified point.</returns>
	},
	raiseItemDragEnd: function() {
		/// <summary>Raises the itemDragEnd event. Inherited from ListContainer.</summary>
	},
	selectItem: function(item) {
		/// <summary>Selects an item. Inherited from ListContainer.</summary>
		/// <param name="item" type="ListItem">ListItem. The item to select.</param>
	},
	toJson: function() {
		/// <summary>Serializes items to a JSON string. Inherited from ListContainer.</summary>
		/// <returns type="String">String. The serialized JSON.</returns>
	}
};
MindFusion.UI.TreeView.__class = true;

MindFusion.UI.Unit.prototype = {
	toString: function() {
		/// <summary>Returns a string representation of this Unit.</summary>
		/// <returns type="String">String. The string representation.</returns>
	}
};
MindFusion.UI.Unit.__class = true;

MindFusion.UI.Unit.empty = function() {
	/// <summary>Creates an empty Unit instance.</summary>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};
MindFusion.UI.Unit.percentage = function(value) {
	/// <summary>Creates a Unit instance with the specified value and UnitType.Percent.</summary>
	/// <param name="value" type="Number">Number. The value of the unit.</param>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};
MindFusion.UI.Unit.pixel = function(value) {
	/// <summary>Creates a Unit instance with the specified value and UnitType.Pixel.</summary>
	/// <param name="value" type="Number">Number. The value of the unit.</param>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};

MindFusion.UI.UnitType = {
	/// <summary>Specifies a unit of measurement.</summary>
	/// <field name="Percent">The measurement is a percentage relative to the parent element.</field>
	/// <field name="Pixel">The measurement is in pixels.</field>
	Percent: 2,
	Pixel: 1
}
MindFusion.UI.UnitType.__enum = true;

MindFusion.UI.Window.prototype = {
	attach: function() {
		/// <summary>WindowBase.attach override.</summary>
	},
	autoSize: function() {
		/// <summary>Resizes the window to fit its contents.</summary>
	},
	center: function(rect) {
		/// <summary>Positions the window in the center of its host element or specified rect.</summary>
		/// <param name="rect" type="Rect" optional="true">Optional. Rect. The rect to center in.</param>
	},
	close: function() {
		/// <summary>Closes the window.</summary>
	},
	detach: function() {
		/// <summary>WindowBase.detach override.</summary>
	},
	dispose: function() {
		/// <summary>Control.dispose override.</summary>
	},
	doClose: function() {
		/// <summary>Closes the window without raising events.</summary>
	},
	doOpen: function() {
		/// <summary>Opens the window without raising events.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	maximize: function() {
		/// <summary>Maximizes the window.</summary>
	},
	minimize: function() {
		/// <summary>Minimizes the window.</summary>
	},
	open: function() {
		/// <summary>Shows the window.</summary>
	},
	pin: function() {
		/// <summary>Pins the window. Pinned windows cannot be moved or resized.</summary>
	},
	refresh: function() {
		/// <summary>Reloads the window iframe.</summary>
	},
	restore: function() {
		/// <summary>Restores the window to a normal state.</summary>
	},
	unpin: function() {
		/// <summary>Unpins the window.</summary>
	},
	updateBounds: function(autoSize) {
		/// <summary>Updates window dimensions after applying changes to DOM elements.</summary>
		/// <param name="autoSize" type="Boolean" optional="true">Optional. Boolean. True to autosize the window, otherwise false.</param>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	}
};
MindFusion.UI.Window.__class = true;

MindFusion.UI.WindowBase.prototype = {
	attach: function() {
		/// <summary>Control.attach override.</summary>
	},
	detach: function() {
		/// <summary>Control.detach override.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	draw: function() {
		/// <summary>Draws the control. Inherited from Control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	}
};
MindFusion.UI.WindowBase.__class = true;

MindFusion.UI.WindowHost.prototype = {
	attach: function() {
		/// <summary>Container.attach override.</summary>
	},
	bringToFront: function(window) {
		/// <summary>Brings a child window to the front, effectively making it topmost and active.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The window to bring to front.</param>
	},
	closeAll: function() {
		/// <summary>Closes all open child windows.</summary>
	},
	detach: function() {
		/// <summary>Container.detach override.</summary>
	},
	dispose: function() {
		/// <summary>Container.dispose override.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	fit: function(window) {
		/// <summary>Ensures that a child window fits into content bounds.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The child window to check.</param>
	},
	minimizeAll: function() {
		/// <summary>Minimizes all child windows.</summary>
	},
	openAll: function() {
		/// <summary>Opens all closed child windows.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction.</summary>
	},
	restoreAll: function() {
		/// <summary>Restores all minimized and maximized child windows.</summary>
	},
	sendToBack: function(window) {
		/// <summary>Sends a child window to the back.</summary>
		/// <param name="window" type="WindowBase">WindowBase. The window to send to back.</param>
	},
	showConfirmDialog: function(title, message, callback) {
		/// <summary>Shows a confirmation dialog.</summary>
		/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
		/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
		/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.The dialog's modalResult will be passed as a parameter to the callback function.</param>
	},
	showInfoDialog: function(title, message, callback) {
		/// <summary>Shows an info dialog.</summary>
		/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
		/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
		/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.</param>
	},
	showInputDialog: function(title, message, callback, input, property) {
		/// <summary>Shows an input dialog.</summary>
		/// <param name="title" type="String" optional="true">Optional. String. The text to display as a dialog title.</param>
		/// <param name="message" type="String" optional="true">Optional. String. The message to display as the dialog text.</param>
		/// <param name="callback" type="function" optional="true">Optional. function. The callback function to invoke when the dialog is closed.The dialog's modalResult will be passed as the first, and the specified property value of the input control will be passed as the second parameter to the callback function.</param>
		/// <param name="input" type="HTMLElement" optional="true">Optional. HTMLElement. The input control to show in the dialog. If the parameter is not specified, an empty HTML text input will be displayed.</param>
		/// <param name="property" type="String" optional="true">Optional. String. The name of the property of the input control, whose value will be passed as the second argument to the callback function.If the parameter is not specified, the value property will be used.</param>
	}
};
MindFusion.UI.WindowHost.__class = true;

MindFusion.UI.WindowState = {
	/// <summary>Specifies how a window is displayed.</summary>
	/// <field name="Maximized">Indicates maximized state.</field>
	/// <field name="Minimized">Indicates minimized state.</field>
	/// <field name="Normal">Indicates normal state.</field>
	Maximized: 2,
	Minimized: 1,
	Normal: 0
}
MindFusion.UI.WindowState.__enum = true;

MindFusion.Diagramming.Lanes.Cell.prototype = {
	getStyle: function() {
		/// <summary>Gets the style of the cell.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the style of this cell.</returns>
	},
	getText: function() {
		/// <summary>Gets the text of the cell.</summary>
		/// <returns type="String">A string specifying the text of the cell.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Deserializes the cell from the specified XML element</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Serializes the cell matrix to the specified XML element</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setStyle: function(value) {
		/// <summary>Sets the style of the cell.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the style of this cell.</param>
	},
	setText: function(value) {
		/// <summary>Sets the text of the cell.</summary>
		/// <param name="value" type="String">A string specifying the text of the cell.</param>
	}
};
MindFusion.Diagramming.Lanes.Cell.__class = true;


MindFusion.Diagramming.Lanes.Events.invalidated = function() {
	/// <summary>Raised when the grid structure is changed.</summary>
};

MindFusion.Diagramming.Lanes.Grid.prototype = {
	addColumnHeader: function(header, parent, i) {
		/// <summary>Adds the specified header to the grid as a new column header.</summary>
		/// <param name="header" type="MindFusion.Diagramming.Lanes.Header">The Header object to add.</param>
		/// <param name="parent" type="MindFusion.Diagramming.Lanes.Header" optional="true">Optional. The parent header to add to, or null, to add the new header as a root column.</param>
		/// <param name="i" type="Number" optional="true">Optional. The index at which the header was added in the collection.</param>
	},
	addRowHeader: function(header, parent, i) {
		/// <summary>Adds the specified header to the grid as a new row header.</summary>
		/// <param name="header" type="MindFusion.Diagramming.Lanes.Header">The Header object to add.</param>
		/// <param name="parent" type="MindFusion.Diagramming.Lanes.Header" optional="true">Optional. The parent header to add to, or null, to add the new header as a root row.</param>
		/// <param name="i" type="Number" optional="true">Optional. The index at which the header was added in the collection.</param>
	},
	findColumn: function(title) {
		/// <summary>Finds the first column whose header caption matches the specified string.</summary>
		/// <param name="title" type="String">A string containing the header title to look for.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Header">Returns the first column Header that has the specified caption.</returns>
	},
	findRow: function(title) {
		/// <summary>Finds the first row whose header caption matches the specified string.</summary>
		/// <param name="title" type="String">A string containing the header title to look for.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Header">Returns the first row Header that has the specified caption.</returns>
	},
	get: function(column, row) {
		/// <summary>Gets the cell or the cluster of cells corresponding to the specified row and column.</summary>
		/// <param name="column" type="Number | MindFusion.Diagramming.Lanes.Header">A Header object or a cell index.</param>
		/// <param name="row" type="Number | MindFusion.Diagramming.Lanes.Header">A Header object or a cell index.</param>
	},
	getAllowInplaceEdit: function() {
		/// <summary>Gets a value indicating whether grid cells' text can be in-place edited.</summary>
		/// <returns type="Boolean">true if grid cells' text can be in-place edited, otherwise false.</returns>
	},
	getAllowResizeHeaders: function() {
		/// <summary>Gets a value indicating whether users can resize the headers of the grid interactively.</summary>
		/// <returns type="Boolean">true if grid headers can resized interactively, otherwise false.</returns>
	},
	getCellBounds: function(cell) {
		/// <summary>Returns the bounding rectangle of the specified cell.</summary>
		/// <param name="cell" type="MindFusion.Diagramming.Lanes.Cell">An Cell object representing a cell or a group of cells in the grid.</param>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance representing the rectangle that bounds the specified cell or group of cells.</returns>
	},
	getCellColumn: function(cell) {
		/// <summary>Returns the column index of the specified cell.</summary>
		/// <param name="cell" type="MindFusion.Diagramming.Lanes.Cell">A Cell object representing a single cell in the grid.</param>
		/// <returns type="Number">The index of the column that contains cell; -1 if cell is not found or refers to a group of cells.</returns>
	},
	getCellFromPoint: function(point, cellBounds) {
		/// <summary>Gets the cell located at the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance specifying a point within the grid.</param>
		/// <param name="cellBounds" type="Object">An object that receives the coordinates of the found cell in its cellBounds field.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Cell">A Cell object identifying the found cell, or null if there is no cell located at the specified point.</returns>
	},
	getCellRow: function(cell) {
		/// <summary>Returns the row index of the specified cell.</summary>
		/// <param name="cell" type="MindFusion.Diagramming.Lanes.Cell">A Cell object representing a single cell in the grid.</param>
		/// <returns type="Number">The index of the row that contains cell; -1 if cell is not found or refers to a group of cells.</returns>
	},
	getColumn: function(index) {
		/// <summary>Returns the column header with the specified index from the bottommost column header level.</summary>
		/// <param name="index" type="Number">A number specifying the column index.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Header">A Header object representing the column at the specified index.</returns>
	},
	getColumnCount: function() {
		/// <summary>Gets the number of columns in the grid.</summary>
		/// <returns type="Number">The number of columns.</returns>
	},
	getColumnDepth: function() {
		/// <summary>Gets the number of levels of the column headers.</summary>
		/// <returns type="Number">A number representing the column depth.</returns>
	},
	getColumnHeaderBounds: function() {
		/// <summary>Returns the bounding rectangle of all column headers.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect that bounds all column headers.</returns>
	},
	getColumnHeaders: function() {
		/// <summary>Gets the collection with the topmost column headers.</summary>
		/// <returns type="Array">An array containing the topmost column headers.</returns>
	},
	getColumnHeadersHeights: function() {
		/// <summary>Gets an array with float values specifying the heights of individual column levels.</summary>
		/// <returns type="Array">An array of numbers representing the heights of the various header levels.</returns>
	},
	getColumnIndex: function(column) {
		/// <summary>Returns the 0-based index of the specified column. Only works for bottommost headers. If the specified column is a group header, returns -1.</summary>
		/// <param name="column" type="MindFusion.Diagramming.Lanes.Header">A Header instance that represents a grid column.</param>
		/// <returns type="Number">The index of column, or -1 if the specified header represents a row or a group of child columns.</returns>
	},
	getHeaderBounds: function(header, includeSubHeaders) {
		/// <summary>Returns the bounding rectangle of the specified header.</summary>
		/// <param name="header" type="MindFusion.Diagramming.Lanes.Header">The Header object whose coordinates to return.</param>
		/// <param name="includeSubHeaders" type="Boolean">true to include the coordinates of the child headers in the returned rectangle; otherwise, false.</param>
		/// <returns type="MindFusion.Drawing.Rect">A Rect that bounds the specified header, and optionally its child headers.</returns>
	},
	getHeaderFromPoint: function(point, headerBounds, scrollPosition) {
		/// <summary>Gets the Header that is located at the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance specifying a point within the grid.</param>
		/// <param name="headerBounds" type="Object">An object that receives the coordinates of the found header in its headerBounds field.</param>
		/// <param name="scrollPosition" type="MindFusion.Drawing.Point">When the headers are hooked this parameter should provide information about the current scroll position in the view.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Header">The found Header object, or null if there is no header located at the specified point.</returns>
	},
	getHeadersOnTop: function() {
		/// <summary>Gets a value indicating whether lane headers appear at the top of the z-order above all other items.</summary>
		/// <returns type="Boolean">true to always display the headers above the items; otherwise, false.</returns>
	},
	getHookHeaders: function() {
		/// <summary>Gets a value indicating whether headers will be anchored to the corresponding side (that is, the column header anchored to the top side and the row header anchored to the left side).</summary>
		/// <returns type="Boolean">true to anchor the headers; otherwise, false.</returns>
	},
	getLeftMargin: function() {
		/// <summary>Gets the offset of the lane grid from the left side of the document bounds.</summary>
		/// <returns type="Number">A number representing the left margin.</returns>
	},
	getMinHeaderSize: function() {
		/// <summary>Gets the minimum size of a header.</summary>
		/// <returns type="Number">A number representing the minimum size for headers in the grid.</returns>
	},
	getRow: function(index) {
		/// <summary>Returns the row header with the specified index from the bottommost row header level.</summary>
		/// <param name="index" type="Number">A number specifying the row index.</param>
		/// <returns type="MindFusion.Diagramming.Lanes.Header">A Header object representing the row at the specified index.</returns>
	},
	getRowCount: function() {
		/// <summary>Gets the number of rows in the grid.</summary>
		/// <returns type="Number">The number of rows.</returns>
	},
	getRowDepth: function() {
		/// <summary>Gets the number of levels of the row headers.</summary>
		/// <returns type="Number">A number representing the row depth.</returns>
	},
	getRowHeaderBounds: function() {
		/// <summary>Returns the bounding rectangle of all row headers.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect that bounds all row headers.</returns>
	},
	getRowHeaders: function() {
		/// <summary>Gets the collection with the topmost row headers.</summary>
		/// <returns type="Array">An array containing the topmost row headers.</returns>
	},
	getRowHeadersWidths: function() {
		/// <summary>Gets an array with float values specifying the widths of individual row levels.</summary>
		/// <returns type="Array">An array of numbers representing the widths of the various header levels.</returns>
	},
	getRowIndex: function(row) {
		/// <summary>Returns the 0-based index of the specified row. Only works for bottommost headers. If the specified row is a group header, returns -1;</summary>
		/// <param name="row" type="MindFusion.Diagramming.Lanes.Header">A Header instance that represents a grid row.</param>
		/// <returns type="Number">The index of row, or -1 if the specified header represents a column or a group of child rows.</returns>
	},
	getStyle: function() {
		/// <summary>Gets the default style of the grid.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.Style">A Style object representing the style of all grid elements, which do not have an explicitly assigned style.</returns>
	},
	getTopLeftAreaStyle: function() {
		/// <summary>Gets the style of the area above all row headers and to the left of all column headers.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the appearance of the top-left area.</returns>
	},
	getTopLeftAreaText: function() {
		/// <summary>Gets the text displayed in the top left area.</summary>
		/// <returns type="String">A string specifying the text.</returns>
	},
	getTopMargin: function() {
		/// <summary>Gets the offset of the lane grid from the top side of the document bounds.</summary>
		/// <returns type="Number">A number representing the top margin.</returns>
	},
	getTotalColumnHeight: function() {
		/// <summary>Gets the total height of all column headers.</summary>
		/// <returns type="Number">A number representing the height.</returns>
	},
	getTotalRowWidth: function() {
		/// <summary>Gets the total width of all row headers.</summary>
		/// <returns type="Number">A number representing the width.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Deserializes the lane grid from the specified XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the deserialization process and some helper deserialization methods.</param>
	},
	removeColumnHeader: function(header) {
		/// <summary>Removes the specified column header and all of its associated cells from the grid.</summary>
		/// <param name="header" type="MindFusion.Diagramming.Lanes.Header">The Header object to remove.</param>
	},
	removeRowHeader: function(header) {
		/// <summary>Removes the specified row header and all of its associated cells from the grid.</summary>
		/// <param name="header" type="MindFusion.Diagramming.Lanes.Header">The Header object to remove.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Serializes the lane grid to the specified XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setAllowInplaceEdit: function(value) {
		/// <summary>Sets a value indicating whether grid cells' text can be in-place edited.</summary>
		/// <param name="value" type="Boolean">true if grid cells' text can be in-place edited, otherwise false.</param>
	},
	setAllowResizeHeaders: function(value) {
		/// <summary>Sets a value indicating whether users can resize the headers of the grid interactively.</summary>
		/// <param name="value" type="Boolean">true if grid headers can resized interactively, otherwise false.</param>
	},
	setColumnCount: function(value) {
		/// <summary>Gets the number of columns in the grid.</summary>
		/// <param name="value" type="Number">The number of columns.</param>
	},
	setColumnHeadersHeights: function(value) {
		/// <summary>Sets an array with float values specifying the heights of individual column levels.</summary>
		/// <param name="value" type="Array">An array of numbers representing the heights of the various header levels.</param>
	},
	setHeadersOnTop: function(value) {
		/// <summary>Sets a value indicating whether lane headers appear at the top of the z-order above all other items.</summary>
		/// <param name="value" type="Boolean">true to always display the headers above the items; otherwise, false.</param>
	},
	setHookHeaders: function(value) {
		/// <summary>Sets a value indicating whether headers will be anchored to the corresponding side (that is, the column header anchored to the top side and the row header anchored to the left side).</summary>
		/// <param name="value" type="Boolean">true to anchor the headers; otherwise, false.</param>
	},
	setLeftMargin: function(value) {
		/// <summary>Sets the offset of the lane grid from the left side of the document bounds.</summary>
		/// <param name="value" type="Number">A number representing the left margin.</param>
	},
	setMinHeaderSize: function(value) {
		/// <summary>Sets the minimum size of a header.</summary>
		/// <param name="value" type="Number">A number representing the minimum size for headers in the grid.</param>
	},
	setRowCount: function(value) {
		/// <summary>Sets the number of rows in the grid.</summary>
		/// <param name="value" type="Number">The number of rows.</param>
	},
	setRowHeadersWidths: function(value) {
		/// <summary>Sets an array with float values specifying the widths of individual row levels.</summary>
		/// <param name="value" type="Array">An array of numbers representing the widths of the various header levels.</param>
	},
	setTopLeftAreaStyle: function(value) {
		/// <summary>Sets the style of the area above all row headers and to the left of all column headers.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the appearance of the top-left area.</param>
	},
	setTopLeftAreaText: function(value) {
		/// <summary>Sets the text displayed in the top left area.</summary>
		/// <param name="value" type="String">A string specifying the text.</param>
	},
	setTopMargin: function(value) {
		/// <summary>Sets the offset of the lane grid from the top side of the document bounds.</summary>
		/// <param name="value" type="Number">A number representing the top margin.</param>
	}
};
MindFusion.Diagramming.Lanes.Grid.__class = true;

MindFusion.Diagramming.Lanes.Header.prototype = {
	getHeight: function() {
		/// <summary>Gets the height of this header.</summary>
		/// <returns type="Number">A number specifying the header height.</returns>
	},
	getResizeType: function() {
		/// <summary>Gets how a row or a column is resized relatively to its parent.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.ResizeType">One of the ResizeType enumeration values.</returns>
	},
	getRotateTitle: function() {
		/// <summary>Gets a value indicating whether to rotate the header caption at 90 degree.</summary>
		/// <returns type="Boolean">true if the title should be rotated; otherwise, false.</returns>
	},
	getStyle: function() {
		/// <summary>Gets the style of this header.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the appearance of the header.</returns>
	},
	getSubHeaders: function() {
		/// <summary>Gets a collection of the subheaders of this header.</summary>
		/// <returns type="Array">An array containing the subheaders.</returns>
	},
	getTitle: function() {
		/// <summary>Gets the header caption.</summary>
		/// <returns type="String">A string containing the caption text.</returns>
	},
	getWidth: function() {
		/// <summary>Gets the width of this header.</summary>
		/// <returns type="Number">A number specifying the header width.</returns>
	},
	isColumnHeader: function() {
		/// <summary>Gets a value indicating whether this header is a column header.</summary>
		/// <returns type="Boolean">true if the header is a column header; otherwise, false.</returns>
	},
	isRowHeader: function() {
		/// <summary>Gets a value indicating whether this header is a row header.</summary>
		/// <returns type="Boolean">true if the header is a row header; otherwise, false.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Loads the lane header from the specified XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Serializes the lane header to the specified XML element</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setHeight: function(value) {
		/// <summary>Sets the height of this header.</summary>
		/// <param name="value" type="Number">A number specifying the header height.</param>
	},
	setResizeType: function(value) {
		/// <summary>Sets how a row or a column is resized relatively to its parent.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Lanes.ResizeType">One of the ResizeType enumeration values.</param>
	},
	setRotateTitle: function(value) {
		/// <summary>Sets a value indicating whether to rotate the header caption at 90 degree.</summary>
		/// <param name="value" type="Boolean">true if the title should be rotated; otherwise, false.</param>
	},
	setStyle: function(value) {
		/// <summary>Gets the style of this header.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Lanes.Style">A Style object that specifies the appearance of the header.</param>
	},
	setTitle: function(value) {
		/// <summary>Sets the header caption.</summary>
		/// <param name="value" type="String">A string containing the caption text.</param>
	},
	setWidth: function(value) {
		/// <summary>Sets the width of this header.</summary>
		/// <param name="value" type="Number">A number specifying the header width.</param>
	}
};
MindFusion.Diagramming.Lanes.Header.__class = true;

MindFusion.Diagramming.Lanes.ResizeType = {
	/// <summary>Specifies how to resize child columns and rows in the lanes grid when their parent column or row is resized.</summary>
	/// <field name="Fixed">The header's size (width or height) is fixed and does not change when its parent header is being resized unless all its siblings have fixed size too.</field>
	/// <field name="Proportional">The header resizes in proportion to its parent header.</field>
	Fixed: 0,
	Proportional: 1
}
MindFusion.Diagramming.Lanes.ResizeType.__enum = true;

MindFusion.Diagramming.Lanes.Style.prototype = {
	getBackgroundBrush: function() {
		/// <summary>Gets the background brush of this style.</summary>
		/// <returns type="Object">A brush object specifying the background brush.</returns>
	},
	getBottomBorderPen: function() {
		/// <summary>Gets the color used to stoke the bottom border of elements with this style.</summary>
		/// <returns type="String">A string value identifying the color.</returns>
	},
	getBottomBorderThickness: function() {
		/// <summary>Gets the width of the bottom border of elements with this style.</summary>
		/// <returns type="Number">A number identifying the width.</returns>
	},
	getFontName: function() {
		/// <summary>Gets the name of the font used to draw texts with this style.</summary>
		/// <returns type="String">A string value identifying the font name.</returns>
	},
	getFontSize: function() {
		/// <summary>Gets the size of the font used to draw texts with this style.</summary>
		/// <returns type="Number">A number identifying the font size.</returns>
	},
	getLeftBorderPen: function() {
		/// <summary>Gets the color used to stoke the left border of elements with this style.</summary>
		/// <returns type="String">A string value identifying the color.</returns>
	},
	getLeftBorderThickness: function() {
		/// <summary>Gets the width of the left border of elements with this style.</summary>
		/// <returns type="Number">A number identifying the width.</returns>
	},
	getLineAlignment: function() {
		/// <summary>Gets a value indicating how to vertically align texts drawn with this style.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	getRightBorderPen: function() {
		/// <summary>Gets the color used to stoke the right border of elements with this style.</summary>
		/// <returns type="String">A string value identifying the color.</returns>
	},
	getRightBorderThickness: function() {
		/// <summary>Gets the width of the right border of elements with this style.</summary>
		/// <returns type="Number">A number identifying the width.</returns>
	},
	getTextAlignment: function() {
		/// <summary>Gets a value indicating how to horizontally align texts drawn with this style.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets the color used to draw texts with this style.</summary>
		/// <returns type="String">A string value identifying the text color.</returns>
	},
	getTopBorderPen: function() {
		/// <summary>Gets the color used to stoke the top border of elements with this style.</summary>
		/// <returns type="String">A string value identifying the color.</returns>
	},
	getTopBorderThickness: function() {
		/// <summary>Gets the width of the top border of elements with this style.</summary>
		/// <returns type="Number">A number identifying the width.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Loads the style from the specified XML element</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Serializes the lane style to the specified XML element</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setBackgroundBrush: function(value) {
		/// <summary>Sets the background brush of this style.</summary>
		/// <param name="value" type="Object">A brush object specifying the background brush.</param>
	},
	setBottomBorderPen: function(value) {
		/// <summary>Sets the color used to stoke the bottom border of elements with this style.</summary>
		/// <param name="value" type="String">A string value identifying the color.</param>
	},
	setBottomBorderThickness: function(value) {
		/// <summary>Sets the width of the bottom border of elements with this style.</summary>
		/// <param name="value" type="Number">A number identifying the width.</param>
	},
	setFontName: function(value) {
		/// <summary>Sets the name of the font used to draw texts with this style.</summary>
		/// <param name="value" type="String">A string value identifying the font name.</param>
	},
	setFontSize: function(value) {
		/// <summary>Sets the size of the font used to draw texts with this style.</summary>
		/// <param name="value" type="Number">A number identifying the font size.</param>
	},
	setLeftBorderPen: function(value) {
		/// <summary>Sets the color used to stoke the left border of elements with this style.</summary>
		/// <param name="value" type="String">A string value identifying the color.</param>
	},
	setLeftBorderThickness: function(value) {
		/// <summary>Sets the width of the left border of elements with this style.</summary>
		/// <param name="value" type="Number">A number identifying the width.</param>
	},
	setLineAlignment: function(value) {
		/// <summary>Sets a value indicating how to vertically align texts drawn with this style.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	},
	setRightBorderPen: function(value) {
		/// <summary>Sets the color used to stoke the right border of elements with this style.</summary>
		/// <param name="value" type="String">A string value identifying the color.</param>
	},
	setRightBorderThickness: function(value) {
		/// <summary>Sets the width of the right border of elements with this style.</summary>
		/// <param name="value" type="Number">A number identifying the width.</param>
	},
	setTextAlignment: function(value) {
		/// <summary>Sets a value indicating how to horizontally align texts drawn with this style.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets the color used to draw texts with this style.</summary>
		/// <param name="value" type="String">A string value identifying the text color.</param>
	},
	setTopBorderPen: function(value) {
		/// <summary>Sets the color used to stoke the top border of elements with this style.</summary>
		/// <param name="value" type="String">A string value identifying the color.</param>
	},
	setTopBorderThickness: function(value) {
		/// <summary>Sets the width of the top border of elements with this style.</summary>
		/// <param name="value" type="Number">A number identifying the width.</param>
	}
};
MindFusion.Diagramming.Lanes.Style.__class = true;

MindFusion.Diagramming.Action = {
	/// <summary>Specifies the possible actions a user can carry out on diagram items.</summary>
	/// <field name="Create">Draw a new item.</field>
	/// <field name="Modify">Modify an existing item.</field>
	/// <field name="None">Do not perform any action.</field>
	/// <field name="Split">Split a link's segment.</field>
	Create: 0,
	Modify: 1,
	None: 2,
	Split: 3
}
MindFusion.Diagramming.Action.__enum = true;

MindFusion.Diagramming.AddItemCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.AddItemCommand.__class = true;

MindFusion.Diagramming.AdjustmentHandles = {
	/// <summary>Identifies the distinct selection handles of a node.</summary>
	/// <field name="All">All selection handles are enabled and can be used to modify the node.</field>
	/// <field name="Move">The center selection handle is enabled and can be used to move the node.</field>
	/// <field name="None">Specifies that none of the selection handles can be used to modify the node.</field>
	/// <field name="ResizeBottomCenter">The bottom-center handle is enabled and can be used to resize the node vertically.</field>
	/// <field name="ResizeBottomLeft">The bottom-left handle is enabled and can be used to resize the node.</field>
	/// <field name="ResizeBottomRight">The bottom-right handle is enabled and can be used to resize the node.</field>
	/// <field name="ResizeMiddleLeft">The middle-left handle is enabled and can be used to resize the node horizontally.</field>
	/// <field name="ResizeMiddleRight">The middle-right handle is enabled and can be used to resize the node horizontally.</field>
	/// <field name="ResizeTopCenter">The top-center handle is enabled and can be used to resize the node vertically.</field>
	/// <field name="ResizeTopLeft">The top-left handle is enabled and can be used to resize the node.</field>
	/// <field name="ResizeTopRight">The top-right handle is enabled and can be used to resize the node.</field>
	/// <field name="Rotate">The rotation handle is enabled and can be used to rotate the node.</field>
	All: 0,
	Move: 1,
	None: 2,
	ResizeBottomCenter: 3,
	ResizeBottomLeft: 4,
	ResizeBottomRight: 5,
	ResizeMiddleLeft: 6,
	ResizeMiddleRight: 7,
	ResizeTopCenter: 8,
	ResizeTopLeft: 9,
	ResizeTopRight: 10,
	Rotate: 11
}
MindFusion.Diagramming.AdjustmentHandles.__enum = true;

MindFusion.Diagramming.AeroEffect.prototype = {
	getInnerOutlineColor: function() {
		/// <summary>Gets the color of the inner outline.</summary>
		/// <returns type="String">A string specifying the color name or hexadecimal value. The default value is "white".</returns>
	},
	getOpacity: function() {
		/// <summary>Gets the opacity to apply to the node's background.</summary>
		/// <returns type="Number">A floating point value between 0 and 1.</returns>
	},
	getShadeColor: function() {
		/// <summary>Gets the color of the shade.</summary>
		/// <returns type="String">A string specifying the color name or hexadecimal value. The default value is "black".</returns>
	},
	setInnerOutlineColor: function(value) {
		/// <summary>Sets the color of the inner outline.</summary>
		/// <param name="value" type="String">A string specifying the color name or hexadecimal value. The default value is "white".</param>
	},
	setOpacity: function(value) {
		/// <summary>Sets the opacity to apply to the node's background.</summary>
		/// <param name="value" type="Number">A floating point value between 0 and 1.</param>
	},
	setShadeColor: function(value) {
		/// <summary>Sets the color of the shade.</summary>
		/// <param name="value" type="String">A string specifying the color name or hexadecimal value. The default value is "black".</param>
	}
};
MindFusion.Diagramming.AeroEffect.__class = true;

MindFusion.Diagramming.Alignment = {
	/// <summary>Specifies the alignment of text relative to its layout rectangle.</summary>
	/// <field name="Center">The text is drawn in the center of the layout rectangle.</field>
	/// <field name="Far">The text is drawn in the far corner of the layout rectangle.</field>
	/// <field name="Near">The text is drawn in the near corner of the layout rectangle.</field>
	Center: 0,
	Far: 1,
	Near: 2
}
MindFusion.Diagramming.Alignment.__enum = true;

MindFusion.Diagramming.allowMultipleSelection.prototype = {
};
MindFusion.Diagramming.allowMultipleSelection.__class = true;

MindFusion.Diagramming.AnchorPattern.prototype = {
	getId: function() {
		/// <summary>Gets the AnchorPattern unique identifier.</summary>
		/// <returns type="String">The AnchorPattern id.</returns>
	},
	getPoints: function() {
		/// <summary>Gets a collection of the anchor points in this pattern.</summary>
		/// <returns type="Array">A collection of the anchor points in this pattern.</returns>
	},
	setPoints: function(value) {
		/// <summary>Sets the collection of the anchor points in this pattern to the specified value.</summary>
		/// <param name="value" type="Array">A collection of anchor points.</param>
	}
};
MindFusion.Diagramming.AnchorPattern.__class = true;

MindFusion.Diagramming.AnchorPattern.fromId = function(id) {
	/// <summary>Returns a reference to the anchor pattern with the specified string identifier.</summary>
	/// <param name="id" type="String">A string identifying an AnchorPattern instance.</param>
	/// <returns type="MindFusion.Diagramming.AnchorPattern">The AnchorPattern object whose Id is equal to the id parameter.</returns>
};


MindFusion.Diagramming.AnchorPattern.decision1In3Out = function() {
	/// <summary>Gets the predefined anchor pattern decision1In3Out.</summary>
};


MindFusion.Diagramming.AnchorPattern.decision2In2Out = function() {
	/// <summary>Gets the predefined anchor pattern decision2In2Out.</summary>
};


MindFusion.Diagramming.AnchorPattern.leftInRightOut = function() {
	/// <summary>Gets the predefined anchor pattern leftInRightOut.</summary>
};


MindFusion.Diagramming.AnchorPattern.topInBottomOut = function() {
	/// <summary>Gets the predefined anchor pattern topInBottomOut.</summary>
};

MindFusion.Diagramming.AnchorPoint.prototype = {
	getAllowIncoming: function() {
		/// <summary>Gets a value indicating whether incoming links can be connected to this point.</summary>
		/// <returns type="Boolean">true if incoming links can be connected to this point; otherwise, false.</returns>
	},
	getAllowOutgoing: function() {
		/// <summary>Gets a value indicating whether the anchor point accepts outgoing connections.</summary>
		/// <returns type="Boolean">true if the anchor point accepts outgoing connections; otherwise, false.</returns>
	},
	getColor: function() {
		/// <summary>Gets the color of the anchor point mark.</summary>
		/// <returns type="String">The color of the anchor point mark.</returns>
	},
	getColumn: function() {
		/// <summary>Gets the column index of a cell with which the anchor point is associated.</summary>
		/// <returns type="Number">The column index of a cell with which the anchor point is associated.</returns>
	},
	getMarkStyle: function() {
		/// <summary>Gets the appearance of the anchor point mark.</summary>
		/// <returns type="MindFusion.Diagramming.MarkStyle">One of the MarkStyle Enumeration values.</returns>
	},
	getSize: function() {
		/// <summary>Gets the size of the anchor point mark.</summary>
		/// <returns type="Number">The size.</returns>
	},
	getTag: function() {
		/// <summary>Gets a user-defined data associated with the anchor point.</summary>
		/// <returns type="Object">The user-defined data associated with the anchor point.</returns>
	},
	getToolTip: function() {
		/// <summary>Gets a tooltip text that should be displayed when the mouse hovers over an anchor point mark.</summary>
	},
	getX: function() {
		/// <summary>Gets the horizontal position of the anchor point expressed as percent of a node's width.</summary>
		/// <returns type="Number">The horizontal position of the anchor point expressed as percent of a node's width.</returns>
	},
	getY: function() {
		/// <summary>Gets the vertical position of the anchor point expressed as percent of a node's height.</summary>
		/// <returns type="Number">The vertical position of the anchor point expressed as percent of a node's height.</returns>
	},
	setAllowIncoming: function(value) {
		/// <summary>Sets a value indicating whether incoming links can be connected to this point.</summary>
		/// <param name="value" type="Boolean">true if incoming links can be connected to this point; otherwise, false.</param>
	},
	setAllowOutgoing: function(value) {
		/// <summary>Sets a value indicating whether the anchor point accepts outgoing connections.</summary>
		/// <param name="value" type="Boolean">true if the anchor point accepts outgoing connections; otherwise, false.</param>
	},
	setColor: function(value) {
		/// <summary>Sets the color of the anchor point mark.</summary>
		/// <param name="value" type="String">The color of the anchor point mark.</param>
	},
	setColumn: function(value) {
		/// <summary>Sets the column index of a cell with which the anchor point is associated.</summary>
		/// <param name="value" type="Number">The column index of a cell with which the anchor point is associated.</param>
	},
	setMarkStyle: function(value) {
		/// <summary>Sets the appearance of the anchor point mark.</summary>
		/// <param name="value" type="MindFusion.Diagramming.MarkStyle">One of the MarkStyle Enumeration values.</param>
	},
	setSize: function(value) {
		/// <summary>Sets the size of the anchor point mark.</summary>
		/// <param name="value" type="Number">The size.</param>
	},
	setTag: function(value) {
		/// <summary>Sets a user-defined data associated with the anchor point.</summary>
		/// <param name="value" type="Object">The user-defined data associated with the anchor point.</param>
	},
	setToolTip: function(value) {
		/// <summary>Sets a tooltip text that should be displayed when the mouse hovers over an anchor point mark.</summary>
		/// <param name="value" type="void"></param>
	},
	setX: function(value) {
		/// <summary>Sets the horizontal position of the anchor point expressed as percent of a node's width.</summary>
		/// <param name="value" type="Number">The horizontal position of the anchor point expressed as percent of a node's width.</param>
	},
	setY: function(value) {
		/// <summary>Sets the vertical position of the anchor point expressed as percent of a node's height.</summary>
		/// <param name="value" type="Number">The vertical position of the anchor point expressed as percent of a node's height.</param>
	}
};
MindFusion.Diagramming.AnchorPoint.__class = true;

MindFusion.Diagramming.AutoResize = {
	/// <summary>Defines in which directions automatic resizing can enlarge the diagram scrollable area.</summary>
	/// <field name="AllDirections">Enlarge the diagram area in any direction if an item is moved outside the boundaries.</field>
	/// <field name="None">Do not enlarge the diagram area automatically.</field>
	/// <field name="RightAndDown">Enlarge the diagram area to the right and down if an item is moved outside the boundaries in these directions.</field>
	AllDirections: 0,
	None: 1,
	RightAndDown: 2
}
MindFusion.Diagramming.AutoResize.__enum = true;

MindFusion.Diagramming.Behavior = {
	/// <summary>Defines values that specify how the component responds to actions performed by the user.</summary>
	/// <field name="Custom">Drawing with the mouse creates instances of the type assigned to CustomNodeType.</field>
	/// <field name="DoNothing">The control ignores users actions with the mouse, but raises the appropriate mouse events. This mode allows applications to implement their own mouse-drawing behavior, disabling the default response to users actions.</field>
	/// <field name="DrawContainers">Drawing with the mouse creates ContainerNode instances.</field>
	/// <field name="DrawFreeForms">Drawing with the mouse creates FreeFormNode instances.</field>
	/// <field name="DrawFreeShapes">Points from user input are shown using a FreeFormNode instance. Once the user finishes drawing, the FreeFormNode is replaced by a ShapeNode with a matching shape from Diagram.FreeFormTargets list.</field>
	/// <field name="DrawLinks">Drawing started over a node creates a DiagramLink. Otherwise a lasso rectangle is displayed allowing the selection of items.</field>
	/// <field name="DrawShapes">Drawing with the mouse creates ShapeNode instances.</field>
	/// <field name="DrawSvgNodes">Drawing with the mouse creates SvgNode instances.</field>
	/// <field name="DrawTables">Drawing with the mouse creates TableNode instances.</field>
	/// <field name="LinkContainers">Drawing over empty document area creates a ContainerNode instance. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="LinkFreeForms">Drawing over empty document area creates a FreeFormNode instance. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="LinkFreeShapes">Points from user input are shown using a FreeFormNode instance. Once the user finishes drawing, the FreeFormNode is replaced by a ShapeNode with a matching shape from Diagram.FreeFormTargets list. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="LinkShapes">A mode that is suitable for creating flowcharts and process diagrams. Drawing over empty document area creates a ShapeNode instance. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="LinkSvgNodes">Drawing over empty document area creates an SvgNode instance. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="LinkTables">A mode that is suitable for creating entity-relationship diagrams. Drawing over empty document area creates a TableNode instance. Drawing started over a node creates a DiagramLink.</field>
	/// <field name="Modify">Objects can be selected and modified. New objects cannot be created.</field>
	/// <field name="Pan">Dragging with depressed mouse button pans the view.</field>
	/// <field name="SelectOnly">Allow only selection of existing items. Modifying them or drawing new ones is disabled.</field>
	Custom: 0,
	DoNothing: 1,
	DrawContainers: 2,
	DrawFreeForms: 3,
	DrawFreeShapes: 4,
	DrawLinks: 5,
	DrawShapes: 6,
	DrawSvgNodes: 7,
	DrawTables: 8,
	LinkContainers: 9,
	LinkFreeForms: 10,
	LinkFreeShapes: 11,
	LinkShapes: 12,
	LinkSvgNodes: 13,
	LinkTables: 14,
	Modify: 15,
	Pan: 16,
	SelectOnly: 17
}
MindFusion.Diagramming.Behavior.__enum = true;

MindFusion.Diagramming.BehaviorBase.prototype = {
	createController: function(state) {
		/// <summary>Creates a controller appropriate for current context and pointer position.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.BehaviorBase.__class = true;

MindFusion.Diagramming.Border.prototype = {
};
MindFusion.Diagramming.Border.__class = true;

MindFusion.Diagramming.brush.prototype = {
};
MindFusion.Diagramming.brush.__class = true;

MindFusion.Diagramming.Cell.prototype = {
	getBrush: function() {
		/// <summary>Gets the object that specifies how to paint the interior of this cell.</summary>
		/// <returns type="Object">An object specifying the fill of the cell.</returns>
	},
	getColumnSpan: function() {
		/// <summary>Gets the number of columns spanned by this cell.</summary>
		/// <returns type="Number">An integer value specifying the number of spanned columns.</returns>
	},
	getFont: function() {
		/// <summary>Gets the font used to render this cell's text.</summary>
		/// <returns type="MindFusion.Drawing.Font">A Font instance.</returns>
	},
	getRowSpan: function() {
		/// <summary>Gets the number of rows spanned by this cell.</summary>
		/// <returns type="Number">An integer value specifying the number of spanned rows.</returns>
	},
	getTag: function() {
		/// <summary>Gets the tag of the cell.</summary>
		/// <returns type="Object">The tag.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets a string specifying the color of the text of this cell.</summary>
		/// <returns type="String">A string value identifying the color of the text.</returns>
	},
	getTooltip: function() {
		/// <summary>Gets the tooltip text that should be displayed when the mouse hovers over this table cell.</summary>
		/// <returns type="String">A string containing the tooltip text.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Loads the cell's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the cell's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the cell's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the cell's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of this cell.</summary>
		/// <param name="value" type="Object" optional="true">Optional. A Brush object specifying the fill of the cell.</param>
	},
	setColumnSpan: function(value) {
		/// <summary>Sets the number of columns spanned by this cell.</summary>
		/// <param name="value" type="Number">An integer value specifying the number of spanned columns.</param>
	},
	setFont: function(value) {
		/// <summary>Sets the font used to render this cell's text.</summary>
		/// <param name="value" type="MindFusion.Drawing.Font">A Font instance.</param>
	},
	setRowSpan: function(value) {
		/// <summary>Sets the number of rows spanned by this cell.</summary>
		/// <param name="value" type="Number">An integer value specifying the number of spanned rows.</param>
	},
	setTag: function(value) {
		/// <summary>Lets you set any object as a tag for this cell.</summary>
		/// <param name="value" type="Object">The tag of the cell.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets a string specifying the color of the text of this cell.</summary>
		/// <param name="value" type="String">A string value identifying the color of the text.</param>
	},
	setTooltip: function(value) {
		/// <summary>Sets the tooltip text that should be displayed when the mouse hovers over this table cell.</summary>
		/// <param name="value" type="String">A string containing the tooltip text.</param>
	}
};
MindFusion.Diagramming.Cell.__class = true;

MindFusion.Diagramming.CellEventArgs.prototype = {
	getCancel: function() {
		/// <summary>Gets a value indicating whether to allow the current operation.</summary>
		/// <returns type="Boolean">true to cancel the operation; otherwise, false.</returns>
	},
	getCell: function() {
		/// <summary>Gets the cell related to the event.</summary>
		/// <returns type="MindFusion.Diagramming.Cell">A Cell instance.</returns>
	},
	getContext: function() {
		/// <summary>Gets the canvas rendering context.</summary>
		/// <returns type="CanvasRenderingContext2D">A rendering context used to draw on the Canvas element.</returns>
	},
	getHandled: function() {
		/// <summary>Gets a value indicating whether the event has been handled.</summary>
	},
	getMouseButton: function() {
		/// <summary>Gets which mouse button has been pressed.</summary>
		/// <returns type="Number">An integer mouse button id.</returns>
	},
	getNewText: function() {
		/// <summary>Gets the text that has just been entered by the user.</summary>
		/// <returns type="String">A string specifying the new text of the cell.</returns>
	},
	getOldText: function() {
		/// <summary>Gets the text that had been displayed in the cell before the user edited it.</summary>
		/// <returns type="String">A string specifying the old text of the cell.</returns>
	},
	setCancel: function(value) {
		/// <summary>Sets a value indicating whether to allow the current operation.</summary>
		/// <param name="value" type="Boolean">true to cancel the operation; otherwise, false.</param>
	},
	setHandled: function(value) {
		/// <summary>Sets a value indicating whether the event has been handled.</summary>
		/// <param name="value" type="Boolean">true to indicate that the event has been handled; otherwise, false.</param>
	}
};
MindFusion.Diagramming.CellEventArgs.__class = true;

MindFusion.Diagramming.CellFrameStyle = {
	/// <summary>Specifies the style of the cells' frame lines.</summary>
	/// <field name="None">Table cells have no border.</field>
	/// <field name="Simple">The border of table cells is simple line.</field>
	/// <field name="System3D">The border has 3D look.</field>
	None: 0,
	Simple: 1,
	System3D: 2
}
MindFusion.Diagramming.CellFrameStyle.__enum = true;

MindFusion.Diagramming.CellValidationEventArgs.prototype = {
	cancelDrag: function() {
		/// <summary>Cancels the resize of the node's row or column.</summary>
	}
};
MindFusion.Diagramming.CellValidationEventArgs.__class = true;

MindFusion.Diagramming.ChangeItemCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.ChangeItemCommand.__class = true;

MindFusion.Diagramming.ColumnStyle = {
	/// <summary>Specifies how table columns' width is set.</summary>
	/// <field name="AutoWidth">The columns' width changes when the table is resized.</field>
	/// <field name="FixedWidth">The columns has fixed, unchangeable width.</field>
	AutoWidth: 0,
	FixedWidth: 1
}
MindFusion.Diagramming.ColumnStyle.__enum = true;

MindFusion.Diagramming.Command.prototype = {
	execute: function() {
		/// <summary>Carries out an action that changes the diagram or a diagram item.</summary>
	},
	redo: function() {
		/// <summary>Repeats an action that has been undone.</summary>
	},
	undo: function() {
		/// <summary>Undoes an action, restoring the diagram to the state it was in before carrying out the action.</summary>
	}
};
MindFusion.Diagramming.Command.__class = true;

MindFusion.Diagramming.ComponentEventArgs.prototype = {
	getComponent: function() {
		/// <summary>Gets the component for which the event was raised.</summary>
		/// <returns type="MindFusion.Drawing.Component">An instance of the Component class.</returns>
	}
};
MindFusion.Diagramming.ComponentEventArgs.__class = true;

MindFusion.Diagramming.CompositeCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	getCommands: function() {
		/// <summary>Gets a list containing the child Command objects.</summary>
		/// <returns type="Array">The list of child Command objects.</returns>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.CompositeCommand.__class = true;

MindFusion.Diagramming.CompositeNode.prototype = {
	getComponent: function(name) {
		/// <summary>Returns the component created for the template element with specified name.</summary>
		/// <param name="name" type="String">A string specifying the value of the name attribute in node's template.</param>
		/// <returns type="MindFusion.Drawing.Component">The component created for specified element in the template.</returns>
	},
	loadTemplate: function(jsonTemplate) {
		/// <summary>Load a JSON template defining node's appearance.</summary>
		/// <param name="jsonTemplate" type="Object">A JavaScript object literal containing template of node's component hierarchy.</param>
	}
};
MindFusion.Diagramming.CompositeNode.__class = true;

MindFusion.Diagramming.CompositeNode.classFromTemplate = function(className, jsonTemplate) {
	/// <summary>Generates a node class whose appearance and properties are defined using JSON template.</summary>
	/// <param name="className" type="String">Fully qualified name of the class to generate.</param>
	/// <param name="jsonTemplate" type="Object">A JavaScript object literal containing template of node's component hierarchy.</param>
	/// <returns type="Function">A constructor function that creates instances of the new class.</returns>
};

MindFusion.Diagramming.ConnectionPoint.prototype = {
	addLinkToNode: function() {
		/// <summary>Adds the link associated with this connection point to the associated node.</summary>
	},
	getEndPoint: function() {
		/// <summary>Calculates the coordinates of this connection point expressed in document coordinates.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point that represents the coordinate.</returns>
	},
	getInitialPoint: function() {
		/// <summary>Returns a point (usually the center of the bounding rectangle) contained within the associated node.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point contained within the node.</returns>
	},
	getIntersection: function(point1, point2) {
		/// <summary>Calculates the intersection point between the specified line segment and the contour of the node associated with this connection point.</summary>
		/// <param name="point1" type="MindFusion.Drawing.Point">The first point of the segment.</param>
		/// <param name="point2" type="MindFusion.Drawing.Point">The second point of the segment.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point object representing the intersection point.</returns>
	},
	getNearestAnchorPoint: function(point) {
		/// <summary>Returns the nearest anchor point pertinent to this connection.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance specifying location in the diagram.</param>
		/// <returns type="AnchorPointDetails">An AnchorPointDetails specifying the anchor point properties.</returns>
	},
	getNearestBorderPoint: function(point) {
		/// <summary>Returns the nearest point lying on the node border.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance specifying location in the diagram.</param>
		/// <returns type="AnchorPointDetails">An AnchorPointDetails specifying the anchor point properties.</returns>
	},
	getNodeRect: function() {
		/// <summary>Returns the bounding rectangle of the node associated with this connection point.</summary>
		/// <returns type="MindFusion.Drawing.Rect">rect The bounding rectangle of the node.</returns>
	},
	linkChanges: function(item, point) {
		/// <summary>Checks whether the link would change if attached to the specified node at the specified point.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">A DiagramItem under the mouse cursor.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">A point where the link will be connected.</param>
		/// <returns type="Boolean">true if the link would connect to a different entity if dropped at the specified location; otherwise, false.</returns>
	},
	nodesIntersect: function(connectionPoint) {
		/// <summary>Checks whether the node associated with the current connection point and the node associated with the specified connection point intersect.</summary>
		/// <param name="connectionPoint" type="MindFusion.Diagramming.ConnectionPoint">A ConnectionPoint instance.</param>
		/// <returns type="Boolean">true if the node associated with the current connection point and the node associated with the specified connection point intersect; otherwise, false.</returns>
	},
	removeLinkFromNode: function() {
		/// <summary>Removes the link associated with this connection point from the associated node.</summary>
	},
	saveEndRelative: function(ctrRelative) {
		/// <summary>Updates the coordinates of the connection point represented by this link, relative to the bounding rectangle of the associated node.</summary>
		/// <param name="ctrRelative" type="Boolean" optional="true">Optional. </param>
	}
};
MindFusion.Diagramming.ConnectionPoint.__class = true;

MindFusion.Diagramming.ConnectionStyle = {
	/// <summary>Specifies whether links should connect to a node or its rows.</summary>
	/// <field name="Node">Links should connect to the table node when drawn interactively.</field>
	/// <field name="Rows">Links should connect to one of the table's rows when drawn interactively.</field>
	Node: 0,
	Rows: 1
}
MindFusion.Diagramming.ConnectionStyle.__enum = true;

MindFusion.Diagramming.ContainerNode.prototype = {
	add: function(node) {
		/// <summary>Adds a node to this container.</summary>
		/// <param name="node" type="MindFusion.Diagramming.DiagramNode">The node that should be added to the container.</param>
	},
	arrange: function(layout) {
		/// <summary>Arranges the container's children with the given layout.</summary>
		/// <param name="layout" type="Object">The layout algorithm to apply.</param>
	},
	arrangeAnimated: function(layout, duration, animationType, easingType) {
		/// <summary>Arranges the container's children with the given layout, and animates items moving to their new positions.</summary>
		/// <param name="layout" type="Object">The layout algorithm to apply.</param>
		/// <param name="duration" type="Number" optional="true">Optional. An integer, specifying the duration of the animation in milliseconds.</param>
		/// <param name="animationType" type="MindFusion.Animations.AnimationType" optional="true">Optional. A member of the AnimationType enumeration, specifying the animation type to use.</param>
		/// <param name="easingType" type="MindFusion.Animations.EasingType" optional="true">Optional. A member of the EasingType enumeration, specifying the type of easing function to apply to the animation.</param>
	},
	containsPoint: function(point) {
		/// <summary>Checks if the TableNode contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The Point to check.</param>
		/// <returns type="Boolean">true if the point is within the bounds of this node; otherwise, false.</returns>
	},
	containsRecursively: function(node) {
		/// <summary>Determines whether the specified node is contained within this container, either directly or inside child containers.</summary>
		/// <param name="node" type="MindFusion.Diagramming.DiagramNode"></param>
		/// <returns type="Boolean">true if the specified node is inside the container, otherwise false.</returns>
	},
	getAllowAddChildren: function() {
		/// <summary>Gets a value indicating whether users are allowed to add child nodes to the container.</summary>
		/// <returns type="Boolean">true if child nodes can be added interactively; otherwise false.</returns>
	},
	getAllowRemoveChildren: function() {
		/// <summary>Gets a value indicating whether users are allowed to remove child nodes from the container.</summary>
		/// <returns type="Boolean">true if child nodes can be removed interactively; otherwise false.</returns>
	},
	getCaptionBackBrush: function() {
		/// <summary>Gets the object that specifies how to fill the caption bar.</summary>
		/// <returns type="Object">An object specifying the fill of the caption bar.</returns>
	},
	getCaptionHeight: function() {
		/// <summary>Gets the height of the container's caption area.</summary>
		/// <returns type="Number">A number specifying the height of the container caption. The default value is 6.</returns>
	},
	getChildren: function() {
		/// <summary>Gets the child nodes of this container.</summary>
		/// <returns type="Array">An array containing the child nodes of this container.</returns>
	},
	getClipChildren: function() {
		/// <summary>Gets a value indicating whether child items should be clipped by container boundaries.</summary>
		/// <returns type="Boolean">true if child items are clipped; otherwise, false.</returns>
	},
	getContentPath: function() {
		/// <summary>Creates a path corresponding to the content area rectangle, excluding caption bar.</summary>
		/// <returns type="MindFusion.Drawing.Path"></returns>
	},
	getEnableStyledText: function() {
		/// <summary>Gets a value indicating whether styled caption text rendering is enabled.</summary>
		/// <returns type="Boolean">true to parse the node's caption text in order to find formatting tags; or false otherwise.</returns>
	},
	getFoldable: function() {
		/// <summary>Gets a value indicating whether users are allowed to fold the container.</summary>
		/// <returns type="Boolean">true if the container can be folded; otherwise false.</returns>
	},
	getFolded: function() {
		/// <summary>Gets a value indicating whether the container is folded.</summary>
		/// <returns type="Boolean">true if the container is folded; otherwise false.</returns>
	},
	getFoldIconSize: function() {
		/// <summary>Gets a value indicating the size of the fold/unfold icon.</summary>
		/// <returns type="Number">The size of the icon.</returns>
	},
	getOutline: function() {
		/// <summary>Gets an array of points that define the outline of this node shape.</summary>
		/// <returns type="Array">An array with the points.</returns>
	},
	getShape: function() {
		/// <summary>Gets the shape of the container's outline.</summary>
		/// <returns type="MindFusion.Diagramming.SimpleShape">A member of the SimpleShape enumeration.</returns>
	},
	getUnfoldedSize: function() {
		/// <summary>Gets the size of the container in unfolded state.</summary>
		/// <returns type="Size">The size of the container in unfolded state.</returns>
	},
	hitTest: function(point, threshold, onlyNodes, onlyInteractive) {
		/// <summary>Returns the diagram item that contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point value specifying the logical coordinates of a diagram point.</param>
		/// <param name="threshold" type="Number" optional="true">Optional. Specifies the size of the area around the item outlines where the point is still considered inside the item.</param>
		/// <param name="onlyNodes" type="Boolean">true to exclude child links from the search.</param>
		/// <param name="onlyInteractive" type="Boolean">true to exclude locked items from the search.</param>
		/// <returns type="MindFusion.Diagramming.DiagramItem">The item that contains the specified point.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this ContainerNode instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramNode.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	onRemove: function() {
		/// <summary>DiagramItem.onRemove override.</summary>
	},
	remove: function(node) {
		/// <summary>Removes a node from this container.</summary>
		/// <param name="node" type="MindFusion.Diagramming.DiagramNode">The node that should be removed from the container.</param>
	},
	resizeToFitChildren: function(allowShrink, margin) {
		/// <summary>Resizes the container making it big enough to contain its child nodes.</summary>
		/// <param name="allowShrink" type="Boolean"></param>
		/// <param name="margin" type="Number"></param>
	},
	resizeToFitText: function(fit, fixPosition, foldBtnWidth) {
		/// <summary>Makes the container node caption big enough to display its text without clipping.</summary>
		/// <param name="fit" type="MindFusion.Diagramming.FitSize">One of the FitSize enumeration values.</param>
		/// <param name="fixPosition" type="Boolean" optional="true">Optional. Fix the position of the container to the original location. The default is false.</param>
		/// <param name="foldBtnWidth" type="Number" optional="true">Optional. The width of the folder button, if it's not provided, the value from FoldIconSize is used.</param>
		/// <returns type="Boolean">true if the caption is resized successfully; otherwise, false.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the node's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setAllowAddChildren: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to add child nodes to the container.</summary>
		/// <param name="value" type="Boolean">true if child nodes can be added interactively; otherwise false.</param>
	},
	setAllowRemoveChildren: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to remove child nodes from the container.</summary>
		/// <param name="value" type="Boolean">true if child nodes can be removed interactively; otherwise false.</param>
	},
	setCaptionBackBrush: function(value) {
		/// <summary>Sets an object that specifies how to fill the caption bar.</summary>
		/// <param name="value" type="Object">A Brush object specifying the fill of the caption bar.</param>
	},
	setCaptionHeight: function(value) {
		/// <summary>Sets the height of the container's caption area.</summary>
		/// <param name="value" type="Number">A number specifying the height of the container caption. The default value is 6.</param>
	},
	setClipChildren: function(value) {
		/// <summary>Sets a value indicating whether child items should be clipped by container boundaries.</summary>
		/// <param name="value" type="Boolean">true to clip child items; otherwise, false. The default value is true.</param>
	},
	setEnableStyledText: function(value) {
		/// <summary>Sets a value indicating whether styled caption text rendering is enabled.</summary>
		/// <param name="value" type="Boolean">true to parse the node's caption text in order to find formatting tags; or false otherwise.</param>
	},
	setFoldable: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to fold the container.</summary>
		/// <param name="value" type="Boolean">true if the container can be folded; otherwise false.</param>
	},
	setFolded: function(value) {
		/// <summary>Folds or unfolds the container.</summary>
		/// <param name="value" type="Boolean">true to fold the container; false to unfold it.</param>
	},
	setFoldIconSize: function(value) {
		/// <summary>Sets a value indicating the size of the fold/unfold icon.</summary>
		/// <param name="value" type="Number">The size of the icon.</param>
	},
	setShape: function(value) {
		/// <summary>Sets the shape of the container's outline.</summary>
		/// <param name="value" type="MindFusion.Diagramming.SimpleShape">A member of the SimpleShape enumeration.</param>
	},
	visitNodes: function(point, visitNode, relatedItem) {
		/// <summary>Visits the diagram nodes in reverse Z order.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point"></param>
		/// <param name="visitNode" type="Function"></param>
		/// <param name="relatedItem" type="MindFusion.Diagramming.DiagramItem"></param>
	},
};
MindFusion.Diagramming.ContainerNode.__class = true;

MindFusion.Diagramming.ContainerNode.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new ContainerNode instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.CreateLinkController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	drawInteraction: function(context) {
		/// <summary>SinglePointerController.drawInteraction override.</summary>
		/// <param name="context" type="DrawingContext2D">The drawing context for diagram's underlying canvas.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>SinglePointerController.validate override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.CreateLinkController.__class = true;

MindFusion.Diagramming.CreateNodeController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	drawInteraction: function(context) {
		/// <summary>SinglePointerController.drawInteraction override.</summary>
		/// <param name="context" type="DrawingContext2D">The drawing context for diagram's underlying canvas.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>SinglePointerController.validate override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.CreateNodeController.__class = true;

MindFusion.Diagramming.CreateSelectionController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	drawInteraction: function(context) {
		/// <summary>SinglePointerController.drawInteraction override.</summary>
		/// <param name="context" type="DrawingContext2D">The drawing context for diagram's underlying canvas.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	}
};
MindFusion.Diagramming.CreateSelectionController.__class = true;

MindFusion.Diagramming.DelKeyAction = {
	/// <summary>Specifies the type of action performed when the user presses the DEL key.</summary>
	/// <field name="DeleteActiveItem">Indicates that only the ActiveItem is deleted.</field>
	/// <field name="DeleteSelectedItems">Indicates that all selected items are deleted.</field>
	/// <field name="None">Indicates that nothing happens.</field>
	DeleteActiveItem: 0,
	DeleteSelectedItems: 1,
	None: 2
}
MindFusion.Diagramming.DelKeyAction.__enum = true;

MindFusion.Diagramming.Diagram.prototype = {
	addEventListener: function(eventName, handler) {
		/// <summary>Registers a single event listener on the Diagram.</summary>
		/// <param name="eventName" type="String">The name of the event. See a list of supported events here.</param>
		/// <param name="handler" type="Method">Represents the method that will handle the event specified with eventName.</param>
	},
	addItem: function(item) {
		/// <summary>Adds an item to the Diagram.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The item to add.</param>
	},
	alignPointToGrid: function(point) {
		/// <summary>Returns a point of the alignment grid nearest to the one passed as an argument.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="MindFusion.Drawing.Point">A point from the alignment grid.</returns>
	},
	arrange: function(layout) {
		/// <summary>Arranges the diagram with the given layout.</summary>
		/// <param name="layout" type="Object">The layout algorithm to apply.</param>
	},
	arrangeAnimated: function(layout, duration, animationType, easingType) {
		/// <summary>Arranges the diagram using the given layout, and animates items moving to their new positions.</summary>
		/// <param name="layout" type="Object">The layout algorithm to apply.</param>
		/// <param name="duration" type="Number" optional="true">Optional. An integer, specifying the duration of the animation in milliseconds.</param>
		/// <param name="animationType" type="MindFusion.Animations.AnimationType" optional="true">Optional. A member of the AnimationType enumeration, specifying the animation type to use.</param>
		/// <param name="easingType" type="MindFusion.Animations.EasingType" optional="true">Optional. A member of the EasingType enumeration, specifying the type of easing function to apply to the animation.</param>
	},
	arrangeLinkLabels: function() {
		/// <summary>Rearranges link labels whose AutoArrange property is enabled.</summary>
	},
	beginEdit: function(item, point, editTarget) {
		/// <summary>Begins in-place editing of the specified object.</summary>
		/// <param name="item" type="InplaceEditable">The Diagram item whose text should be edited.</param>
		/// <param name="point" type="MindFusion.Drawing.Point" optional="true">Optional. A Point specifying where the in-place edit box should appear.</param>
		/// <param name="editTarget" type="MindFusion.Diagramming.Cell | MindFusion.Diagramming.LinkLabel" optional="true">Optional. The element to use as a target for the inplace edit.</param>
	},
	cancelCompositeOperation: function() {
		/// <summary>Stops recording undo/redo commands into a CompositeCommand and discards the records created so far.</summary>
	},
	clearAll: function() {
		/// <summary>Removes all items from the diagram.</summary>
	},
	commitCompositeOperation: function() {
		/// <summary>Stops recording undo/redo commands into a CompositeCommand and saves the composite in the history queue.</summary>
	},
	copyToClipboard: function(systemClipboard) {
		/// <summary>Copies the current selection of items to the clipboard.</summary>
		/// <param name="systemClipboard" type="Boolean" optional="true">Optional. true to copy to the system clipboard, or false otherwise. The default value is false.</param>
	},
	cutToClipboard: function(systemClipboard) {
		/// <summary>Cuts the currently selected items to the clipboard.</summary>
		/// <param name="systemClipboard" type="Boolean" optional="true">Optional. true to copy to the system clipboard, or false otherwise. The default value is false.</param>
	},
	dispose: function() {
		/// <summary>Overrides Component.Dispose</summary>
	},
	endEdit: function(accept) {
		/// <summary>Exits the in-place editing mode and either accepts or rejects the changes made to the item's text.</summary>
		/// <param name="accept" type="Boolean" optional="true">Optional. true to accept changes made to text; false to reject them.</param>
	},
	executeCommand: function(command) {
		/// <summary>Executes the specified command on this diagram.</summary>
		/// <param name="command" type="MindFusion.Diagramming.Command">The Command to execute.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes the diagram from a JSON string.</summary>
		/// <param name="json" type="String">A string created by the toJson method.</param>
	},
	fromXmlDocument: function(document) {
		/// <summary>Loads diagram contents from specified XML Document.</summary>
		/// <param name="document" type="Document">A DOM Document object containing XML-serialized diagram contents.</param>
	},
	getActiveItem: function() {
		/// <summary>Gets the active diagram element.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramItem">The active item; null if no item is active.</returns>
	},
	getAdjustmentHandlesSize: function() {
		/// <summary>Gets the size of adjustment handles that appear around selected items.</summary>
		/// <returns type="Number">A number specifying the size of selection handles. The default value is 2.</returns>
	},
	getAlignToGrid: function() {
		/// <summary>Gets a value indicating whether the diagram items should be aligned to a grid.</summary>
		/// <returns type="Boolean">true if the diagram items should be aligned to a grid; otherwise, false.</returns>
	},
	getAllowInplaceEdit: function() {
		/// <summary>Gets a value indicating whether in-place editing of the text of objects is enabled.</summary>
		/// <returns type="Boolean">true if in-place editing of the text of objects is enabled; otherwise, false.</returns>
	},
	getAllowMultipleResize: function() {
		/// <summary>Gets a value indicating whether multiple selected nodes can be resized simultaneously.</summary>
		/// <returns type="Boolean">true to let the user resize multiple selected nodes; otherwise, false.</returns>
	},
	getAllowSelfLoops: function() {
		/// <summary>Gets a value indicating whether users are allowed to draw reflexive links.</summary>
		/// <returns type="Boolean">true if reflexive links are allowed; otherwise, false.</returns>
	},
	getAllowUnconnectedLinks: function() {
		/// <summary>Gets a value indicating whether users are allowed to draw links that are not connected to any node.</summary>
		/// <returns type="Boolean">true to let the user draw unconnected links; otherwise, false.</returns>
	},
	getAutoArrangeAvoidContainers: function() {
		/// <summary>Gets a value indicating whether auto-arranged link labels should avoid containers.</summary>
		/// <returns type="Boolean">true to avoid containers, or false otherwise. The default value is true.</returns>
	},
	getAutoArrangeAvoidSegments: function() {
		/// <summary>Gets a value indicating whether auto-arranged link labels should avoid link segments.</summary>
		/// <returns type="Boolean">true to avoid link segments, or false otherwise. The default value is true.</returns>
	},
	getAutoCloseDistance: function() {
		/// <summary>Gets the maximum distance between first and last points of a FreeFormNodefor which the node's outline is closed automatically.</summary>
		/// <returns type="Number">A float value.</returns>
	},
	getAutoResize: function() {
		/// <summary>Gets a value indicating whether the document area should be resized automatically so it fits the diagram contents.</summary>
		/// <returns type="MindFusion.Diagramming.AutoResize">A member of the AutoResize enumeration indicating the auto resize method.</returns>
	},
	getAutoScroll: function() {
		/// <summary>Gets a value indicating whether auto scrolling of the document area is enabled.</summary>
		/// <returns type="Boolean">True if auto scrolling is enabled, otherwise false.</returns>
	},
	getAutoScrollAmount: function() {
		/// <summary>Gets the amount by which to auto-scroll the view when the mouse leaves the view boundaries while drawing.</summary>
		/// <returns type="Number">A number specifying the amount by which to auto-scroll.</returns>
	},
	getBackBrush: function() {
		/// <summary>Gets the object used for painting the diagram background.</summary>
		/// <returns type="Object">The object used for painting the background.</returns>
	},
	getBackgroundImageAlign: function() {
		/// <summary>Gets a value indicating how the background image is positioned.</summary>
		/// <returns type="MindFusion.Drawing.ImageAlign">One of the ImageAlign enumeration values.</returns>
	},
	getBackgroundImageContent: function() {
		/// <summary>Gets the Base64-encoded data of the background image.</summary>
		/// <returns type="String">The Base64-encoded data for the background image to be loaded.</returns>
	},
	getBackgroundImageUrl: function() {
		/// <summary>Gets the URL of the Image painted as diagram's background.</summary>
		/// <returns type="String">The URL of the Image painted as diagram's background.</returns>
	},
	getBehavior: function() {
		/// <summary>Gets a value indicating how the control responds to user actions.</summary>
		/// <returns type="MindFusion.Diagramming.Behavior">A member of the Behavior enumeration.</returns>
	},
	getContentBounds: function() {
		/// <summary>Returns the smallest rectangle that bounds all diagram items.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance specifying the smallest rectangle that bounds all diagram items.</returns>
	},
	getCrossingRadius: function() {
		/// <summary>Gets the radius length of decorations displayed at link intersection points.</summary>
		/// <returns type="Number">A number specifying the radius of the arcs drawn at link intersection points. The default value is 1.5.</returns>
	},
	getCustomLinkType: function() {
		/// <summary>Gets the type of a MindFusion.Diagramming.DiagramLink derived class whose instance should be created when a user starts drawing.</summary>
		/// <returns type="Object">The type.</returns>
	},
	getCustomNodeType: function() {
		/// <summary>Gets the type of a MindFusion.Diagramming.DiagramNode derived class whose instance should be created when a user starts drawing.</summary>
		/// <returns type="Object">The type.</returns>
	},
	getDefaultShape: function() {
		/// <summary>Gets the default shape of shape nodes.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">A Shape object.</returns>
	},
	getDelKeyAction: function() {
		/// <summary>Gets a value that specifies what action should be performed when the user hits the Del key.</summary>
		/// <returns type="MindFusion.Diagramming.DelKeyAction">A DelKeyAction Enumeration value.</returns>
	},
	getDirty: function() {
		/// <summary>Gets a value indicating whether the diagram has changed since loading it.</summary>
		/// <returns type="Boolean">A boolean value that indicates whether the diagram has changed.</returns>
	},
	getDynamicLinks: function() {
		/// <summary>Gets the default value for the Dynamic property of new links.</summary>
		/// <returns type="Boolean">true if dynamic links are enabled; otherwise, false. The default is false.</returns>
	},
	getEnabled: function() {
		/// <summary>Checks if mouse events are enabled.</summary>
		/// <returns type="Boolean">true if handling of mouse events is enabled; otherwise, false.</returns>
	},
	getExpandOnIncoming: function() {
		/// <summary>Gets a value indicating the link direction in which tree branches are expanded.</summary>
		/// <returns type="Boolean">true if trees are expanded in the direction of incoming links; otherwise, false.</returns>
	},
	getFactory: function() {
		/// <summary>Gets a Factory instance that lets you add programmatically new items to the diagram.</summary>
		/// <returns type="MindFusion.Diagramming.Factory">A Factory instance.</returns>
	},
	getFont: function() {
		/// <summary>Gets the font for text displayed by diagram items.</summary>
		/// <returns type="MindFusion.Drawing.Font">The font used for drawing text by diagram items.</returns>
	},
	getFreeFormAttractDistance: function() {
		/// <summary>Gets the radius around dragged free-form adjustment handlein which other points of FreeFormNode are modified too.</summary>
		/// <returns type="Number">A float value.</returns>
	},
	getFreeFormTargets: function() {
		/// <summary>Gets an array of Shape objects used to replace FreeFormNode instances withShapeNode ones when Behavior is set to LinkFreeShapes or DrawFreeShapes.</summary>
		/// <returns type="Array">An array of shape identifiers or Shape instances.</returns>
	},
	getGridColor: function() {
		/// <summary>Gets the color of the grid points.</summary>
		/// <returns type="String">The color of the grid points.</returns>
	},
	getGridOffsetX: function() {
		/// <summary>Gets the horizontal offset of the first point of the alignment grid.</summary>
		/// <returns type="Number">The horizontal offset of the first point of the alignment grid.</returns>
	},
	getGridOffsetY: function() {
		/// <summary>Gets the vertical offset of the first point of the alignment grid.</summary>
		/// <returns type="Number">The vertical offset of the first point of the alignment grid.</returns>
	},
	getGridPointSize: function() {
		/// <summary>Gets the size of shapes used to represent grid points.</summary>
		/// <returns type="Number">The size of shapes used to represent grid points.</returns>
	},
	getGridSizeX: function() {
		/// <summary>Gets the horizontal distance between adjacent grid points.</summary>
		/// <returns type="Number">The horizontal distance between adjacent grid points.</returns>
	},
	getGridSizeY: function() {
		/// <summary>Gets the vertical distance between adjacent grid points.</summary>
		/// <returns type="Number">The vertical distance between adjacent grid points.</returns>
	},
	getGridStyle: function() {
		/// <summary>Gets the visual style of the alignment grid.</summary>
		/// <returns type="MindFusion.Diagramming.GridStyle">One of the GridStyle Enumeration values.</returns>
	},
	getItemAt: function(point, onlyInteractive) {
		/// <summary>Finds and returns the topmost DiagramItem found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance identifying a diagram location.</param>
		/// <param name="onlyInteractive" type="Boolean" optional="true">Optional. true to return only items that can be interacted with; otherwise, false.</param>
		/// <returns type="MindFusion.Diagramming.DiagramItem">The topmost DiagramItem found at the given location or null if no DiagramItem has been found.</returns>
	},
	getItems: function() {
		/// <summary>Returns the array of all items in this diagram.</summary>
		/// <returns type="Array">Array of all DiagramItem instances in the diagram.</returns>
	},
	getItemsAt: function(point) {
		/// <summary>Finds and returns an array of the diagram items found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">instance identifying a location in the diagram.</param>
		/// <returns type="Array">Array of the DiagramItem-s found at the given location or null if no items have been found. The items are arranged according to their Z-index.</returns>
	},
	getLaneGrid: function() {
		/// <summary>Gets the lane grid.</summary>
		/// <returns type="MindFusion.Diagramming.Lanes.Grid">An instance of the Grid class.</returns>
	},
	getLeftButtonActions: function() {
		/// <summary>Gets a combination of flags that specify what actions can be performed via the left mouse button.</summary>
		/// <returns type="MindFusion.Diagramming.MouseButtonActions">A member of the MouseButtonActions enumeration.</returns>
	},
	getLinkAt: function(point) {
		/// <summary>Finds and returns the topmost DiagramLink found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance identifying a diagram location.</param>
		/// <returns type="MindFusion.Diagramming.DiagramLink">The topmost DiagramLink found at the given location or null if no DiagramLink has been found.</returns>
	},
	getLinkBaseShape: function() {
		/// <summary>Gets the shape displayed at the base of new links.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape.</returns>
	},
	getLinkBaseShapeSize: function() {
		/// <summary>Gets the default size of the base of new links.</summary>
		/// <returns type="Number">A number that specifies the size. The default is 5.</returns>
	},
	getLinkBrush: function() {
		/// <summary>Gets the default fill of links.</summary>
		/// <returns type="Object">An object identifying the fill of links.</returns>
	},
	getLinkCrossings: function() {
		/// <summary>Gets a value indicating how to render the intersection points where two links cross each other.</summary>
		/// <returns type="MindFusion.Diagramming.LinkCrossings">A member of the LinkCrossings enumeration. The default value is Straight.</returns>
	},
	getLinkHeadShape: function() {
		/// <summary>Gets the shape displayed as head of new links.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape. The default is Arrow.</returns>
	},
	getLinkHeadShapeSize: function() {
		/// <summary>Gets the default size of arrowheads.</summary>
		/// <returns type="Number">A number that measures the size. The default is 5.</returns>
	},
	getLinkHitDistance: function() {
		/// <summary>Gets a value specifying how far from a link a click is still considered a hit.</summary>
		/// <returns type="Number">A value specifying how far from a link a click is still considered a hit.</returns>
	},
	getLinkPen: function() {
		/// <summary>Gets the default stroke of links.</summary>
		/// <returns type="String">A string value specifying the stroke of links.</returns>
	},
	getLinkRouter: function() {
		/// <summary>Gets the object used to find paths for auto-routed links when diagram nodes are added or their positions change.</summary>
		/// <returns type="MindFusion.Diagramming.Router">An instance of Router-derived class.</returns>
	},
	getLinks: function() {
		/// <summary>Returns the array of all links in this diagram.</summary>
		/// <returns type="Array">Array of all DiagramLink instances in the diagram.</returns>
	},
	getLinksAt: function(point) {
		/// <summary>Finds and returns an array of all DiagramLinks found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">instance identifying a diagram location.</param>
		/// <returns type="Array">Array of the DiagramLinks found at the given location, or null ifno links have been found. The returned links are sorted according to their Z-index.</returns>
	},
	getLinkSegments: function() {
		/// <summary>Gets the default number of arrow segments.</summary>
		/// <returns type="Number">The default number of arrow segments.</returns>
	},
	getLinkShape: function() {
		/// <summary>Gets the initial shape assigned to new links.</summary>
		/// <returns type="MindFusion.Diagramming.LinkShape">One of the LinkShape enumeration values.</returns>
	},
	getLinkTextStyle: function() {
		/// <summary>Gets the default placement and orientation for links' text.</summary>
		/// <returns type="MindFusion.Diagramming.LinkTextStyle">One of the LinkTextStyle enumeration values.</returns>
	},
	getMagnifierEnabled: function() {
		/// <summary>Gets a value indicating whether the magnifier tool is currently enabled.</summary>
		/// <returns type="Boolean">true if the magnifier is enabled, otherwise false.</returns>
	},
	getMagnifierFactor: function() {
		/// <summary>Gets the zoom factor of the magnifier tool.</summary>
		/// <returns type="Number">A number specifying the zoom factor of the magnifier tool.</returns>
	},
	getMagnifierFrameColor: function() {
		/// <summary>Gets the color of the magnifier tool's frame.</summary>
		/// <returns type="String">The color of the magnifier tool's frame.</returns>
	},
	getMagnifierFrameThickness: function() {
		/// <summary>Gets the thickness of the magnifier frame.</summary>
		/// <returns type="Number">A number specifying the thickness of the magnifier frame.</returns>
	},
	getMagnifierHeight: function() {
		/// <summary>Gets the height of the magnifier tool.</summary>
		/// <returns type="Number">A number specifying the height of the magnifier tool.</returns>
	},
	getMagnifierSecondaryFrameColor: function() {
		/// <summary>Gets the color of the magnifier tool's secondary frame.</summary>
		/// <returns type="String">The color of the magnifier tool's secondary frame.</returns>
	},
	getMagnifierShading: function() {
		/// <summary>Gets a value indicating whether to enhance the effect of a magnifier lense by using a gradient shading.</summary>
		/// <returns type="Boolean">true if the shading is enabled, otherwise false.</returns>
	},
	getMagnifierShape: function() {
		/// <summary>Gets a reference to the geometric shape definition of the magnifier tool.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">The Shape of the magnifier tool.</returns>
	},
	getMagnifierWidth: function() {
		/// <summary>Gets the width of the magnifier tool.</summary>
		/// <returns type="Number">A number specifying the width of the magnifier tool.</returns>
	},
	getMiddleButtonActions: function() {
		/// <summary>Gets a combination of flags that specify what actions can be performed via the middle mouse button.</summary>
		/// <returns type="MindFusion.Diagramming.MouseButtonActions">A member of the MouseButtonActions enumeration.</returns>
	},
	getModificationStart: function() {
		/// <summary>Gets how users can start modifying diagram items.</summary>
		/// <returns type="MindFusion.Diagramming.ModificationStart">A member of the ModificationStart enumeration.</returns>
	},
	getModifierKeyActions: function() {
		/// <summary>Gets an object, which allows changing the function of keyboard modifier keys such as Ctrl and Alt.</summary>
		/// <returns type="MindFusion.Diagramming.ModifierKeyActions">An instance of the ModifierKeyActions class.</returns>
	},
	getNearestNode: function(point, maxDistance, ignored) {
		/// <summary>Returns the node nearest to the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A point in the diagram.</param>
		/// <param name="maxDistance" type="Number">The maximum distance from the point at which to look for nodes.</param>
		/// <param name="ignored" type="MindFusion.Diagramming.DiagramNode">A node that should be ignored.</param>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The DiagramNode nearest to the specified point.</returns>
	},
	getNodeAt: function(point, onlyInteractive) {
		/// <summary>Finds and returns the topmost DiagramNode found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance identifying a diagram location.</param>
		/// <param name="onlyInteractive" type="Boolean" optional="true">Optional. true to return only items that can be interacted with; otherwise, false.</param>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The topmost DiagramNode found at the given location or null if no DiagramNode has been found.</returns>
	},
	getNodeEffects: function() {
		/// <summary>Gets an array with all effects applied to the nodes of this diagram.</summary>
		/// <returns type="Array">An array with all node effects.</returns>
	},
	getNodes: function() {
		/// <summary>Returns the array of all nodes in this diagram.</summary>
		/// <returns type="Array">Array of all DiagramNode instances in the diagram.</returns>
	},
	getNodesAt: function(point) {
		/// <summary>Finds and returns an array of all DiagramNodes found at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">instance identifying a diagram location.</param>
		/// <returns type="Array">Array of the DiagramNodes found at the given location, or null ifno nodes have been found. The returned nodes are sorted according to their Z-index.</returns>
	},
	getNodesExpandable: function() {
		/// <summary>Gets a value indicating whether newly created nodes can be expanded.</summary>
		/// <returns type="Boolean">A boolean value assigned to the Expandable property of new nodes.</returns>
	},
	getRightButtonActions: function() {
		/// <summary>Gets a combination of flags that specify what actions can be performed via the right mouse button.</summary>
		/// <returns type="MindFusion.Diagramming.MouseButtonActions">A member of the MouseButtonActions enumeration.</returns>
	},
	getRoundedLinks: function() {
		/// <summary>Gets a value indicating whether the joints between segments of Polyline and Cascading links should be rounded.</summary>
		/// <returns type="Boolean">true to use rounded segment joints; otherwise, false. The default value is false.</returns>
	},
	getRoundedLinksRadius: function() {
		/// <summary>Gets the radius of joint arcs of rounded links' segments.</summary>
		/// <returns type="Number">A number specifying the radius length. The default value is 2.</returns>
	},
	getRouteLinks: function() {
		/// <summary>Gets a value indicating whether links should avoid nodes by going the shortest path from their origin to their destination without crossing any other nodes.</summary>
		/// <returns type="Boolean">true to route links; otherwise, false. The default is false.</returns>
	},
	getRouteMargin: function() {
		/// <summary>Gets the minimal distance between nodes and auto-routed links.</summary>
		/// <returns type="Number">A value specifying distance in the current MeasureUnit; default is 8.</returns>
	},
	getScrollX: function() {
		/// <summary>Gets the diagram's horizontal scroll position.</summary>
		/// <returns type="Number">A number specifying the horizontal scroll position in the current unit of measure.</returns>
	},
	getScrollY: function() {
		/// <summary>Gets the diagram's vertical scroll position.</summary>
		/// <returns type="Number">A number specifying the vertical scroll position in the current unit of measure.</returns>
	},
	getScrollZoneSize: function() {
		/// <summary>Gets the size of the auto scroll zone near the edges of the control.</summary>
		/// <returns type="Number">A number specifying the size of the auto scroll zone. The default value is 8.</returns>
	},
	getSelection: function() {
		/// <summary>Gets a Selection instance that represents the selection of items in this diagram.</summary>
		/// <returns type="MindFusion.Diagramming.Selection">An instance of the Selection class representing the current selection.</returns>
	},
	getShadowOffsetX: function() {
		/// <summary>Gets the horizontal offset of objects' shadows.</summary>
		/// <returns type="Number">A number specifying the shadow's horizontal offset.</returns>
	},
	getShadowOffsetY: function() {
		/// <summary>Gets the vertical offset of objects' shadows.</summary>
		/// <returns type="Number">A number specifying the shadow's vertical offset.</returns>
	},
	getShadowsStyle: function() {
		/// <summary>Gets the style for rendering shadows.</summary>
		/// <returns type="MindFusion.Diagramming.ShadowsStyle">A member of the ShadowsStyle enumeration.</returns>
	},
	getShapeBrush: function() {
		/// <summary>Gets the default fill of shape nodes.</summary>
		/// <returns type="Object">An object identifying the fill of shape nodes.</returns>
	},
	getShapeLibraryLocation: function() {
		/// <summary>Gets the location of a shape library file containing custom shape definitions.It can be set to a full URL of the file, or a relative file path.</summary>
		/// <returns type="String">The location of a shape library file containing custom shape definitions.</returns>
	},
	getShapePen: function() {
		/// <summary>Gets the default stroke of shape nodes.</summary>
		/// <returns type="String">A string value specifying the stroke of shape nodes.</returns>
	},
	getShowAnchors: function() {
		/// <summary>Gets a value indicating whether and when anchor point marks are displayed.</summary>
		/// <returns type="MindFusion.Diagramming.ShowAnchors">One of the ShowAnchors enumeration values.</returns>
	},
	getShowDisabledHandles: function() {
		/// <summary>Gets a value indicating whether adjustment handles are painted when they are disabled.</summary>
		/// <returns type="Boolean">true if disabled handles are displayed, or false otherwise. The default is true.</returns>
	},
	getShowGrid: function() {
		/// <summary>Gets a value indicating whether the alignment grid is visible.</summary>
		/// <returns type="Boolean">true if the alignment grid is visible; otherwise, false.</returns>
	},
	getShowLaneGrid: function() {
		/// <summary>Gets a value indicating whether the lane grid is visible.</summary>
		/// <returns type="Boolean">true if the lane grid is visible; otherwise, false.</returns>
	},
	getStyle: function() {
		/// <summary>Gets the style associated with this diagram.</summary>
		/// <returns type="MindFusion.Diagramming.Style">An instance of the Style class.</returns>
	},
	getTag: function() {
		/// <summary>Gets custom data associated with this diagram.</summary>
		/// <returns type="Object">The custom data.</returns>
	},
	getTheme: function() {
		/// <summary>Gets the theme associated with this diagram.</summary>
		/// <returns type="MindFusion.Diagramming.Theme">An instance of the Theme class.</returns>
	},
	getTooltipDelay: function() {
		/// <summary>Gets the delay before a tooltip is shown.</summary>
		/// <returns type="Number">The tooltip delay in milliseconds.</returns>
	},
	getUndoEnabled: function() {
		/// <summary>Gets a value indicating whether saving action records for later undo is enabled.</summary>
		/// <returns type="Boolean">true if undo is enabled, otherwise false.</returns>
	},
	getViewport: function() {
		/// <summary>Returns the visible portion of the diagram area.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance specifying the viewport coordinates.</returns>
	},
	getVirtualScroll: function() {
		/// <summary>Gets a value indicating whether virtual scroll mode is enabled.</summary>
		/// <returns type="Boolean">true if virtual scroll is enabled; otherwise, false.</returns>
	},
	initialize: function() {
		/// <summary>Overrides Component.Initialize</summary>
	},
	isItemInteractive: function(item) {
		/// <summary>Checks if the specified item can be modified interactively.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem to check.</param>
		/// <returns type="Boolean">true, if the item is currently visible and unlocked and it is not associated with a hidden or locked layer; otherwise, false.</returns>
	},
	isItemVisible: function(item) {
		/// <summary>Checks if the specified item is currently visible.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem to check.</param>
		/// <returns type="Boolean">true if the item's Visible property is set to true and the item is not associated with a hidden layer; otherwise, false.</returns>
	},
	loadFromString: function(str) {
		/// <summary>Loads diagram contents from specified XML or JSON string.</summary>
		/// <param name="str" type="String">A string containing the serialized diagram contents.</param>
	},
	loadFromXml: function(fileUrl, onLoad, onError) {
		/// <summary>Loads the diagram from an XML file.</summary>
		/// <param name="fileUrl" type="String">The URL of an XML file where the data should be read from.</param>
		/// <param name="onLoad" type="Function" optional="true">Optional. A callback that should be invoked if the file is loaded successfully.</param>
		/// <param name="onError" type="Function" optional="true">Optional. A callback that should be invoked if the file could not be downloaded.</param>
	},
	pasteFromClipboard: function(offsetX, offsetY, systemClipboard, unconnectedLinks) {
		/// <summary>Pastes diagram items from the clipboard.</summary>
		/// <param name="offsetX" type="Number">Horizontal offset of pasted items from their original positions.</param>
		/// <param name="offsetY" type="Number">Vertical offset of pasted items from their original positions.</param>
		/// <param name="systemClipboard" type="Boolean" optional="true">Optional. true to paste from the system clipboard, or false otherwise. The default value is false.</param>
		/// <param name="unconnectedLinks" type="Boolean" optional="true">Optional. true to allow pasting arrows whose origin or destination node has not been copied; otherwise, false. The default value is false.</param>
	},
	raiseClicked: function(item, mousePosition, mouseButton) {
		/// <summary>Raises an event which notifies that a Diagram item has been clicked.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The Diagram item.</param>
		/// <param name="mousePosition" type="MindFusion.Drawing.Point">The position of the mouse.</param>
		/// <param name="mouseButton" type="MouseButton">The mouse button, with which the item has been clicked.</param>
	},
	raiseCreated: function(item) {
		/// <summary>Raises an event which notifies that a Diagram item has been created.</summary>
		/// <param name="item" type="MindFusion.Diagramming.Node | MindFusion.Diagramming.Link">The diagram item that has been created.</param>
	},
	raiseDeleted: function(item) {
		/// <summary>Raises an event which notifies that a Diagram item has been deleted.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem that has been deleted.</param>
	},
	raiseDeselected: function(item) {
		/// <summary>Raises an event which notifies that a Diagram item has been deselected.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The Diagram item.</param>
	},
	raiseDoubleClicked: function(item, mousePosition, mouseButton) {
		/// <summary>Raises an event which notifies that a Diagram item has been double-clicked.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The Diagram item.</param>
		/// <param name="mousePosition" type="MindFusion.Drawing.Point">The position of the mouse.</param>
		/// <param name="mouseButton" type="MouseButton">The mouse button, with which the item has been clicked.</param>
	},
	raiseEvent: function(eventName, args) {
		/// <summary>Raises an event.</summary>
		/// <param name="eventName" type="String">The name of the event to raise.</param>
		/// <param name="args" type="EventArgs">An instance of type EventArgs that holds data for the event specified with eventName.</param>
	},
	raiseModified: function(item, mousePosition, adjustmentHandle) {
		/// <summary>Raises an event which notifies that a Diagram item has been modified.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem that has been modified.</param>
		/// <param name="mousePosition" type="MindFusion.Drawing.Point">The current mouse pointer position.</param>
		/// <param name="adjustmentHandle" type="Number">Identifies the handle used to modify the item.</param>
	},
	raisePasted: function(item) {
		/// <summary>Raises an event which notifies that a Diagram item has been pasted from clipboard.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The DiagramItem that has been pasted.</param>
	},
	raiseSelected: function(item) {
		/// <summary>Raises an event which notifies that a Diagram item has been selected.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The Diagram item.</param>
	},
	record: function() {
		/// <summary>Starts recording mouse and keyboard events for subsequent replay.</summary>
	},
	redo: function() {
		/// <summary>Executes again an action saved in the command history.</summary>
	},
	registerForSubmit: function(id) {
		/// <summary>Registers an onsubmit handler for the Diagram's parent html form to flush postback data.</summary>
		/// <param name="id" type="String">The id of the hidden field to flush the data to.</param>
	},
	removeEventListener: function(eventName, handler) {
		/// <summary>Removes a single event listener attached to the Diagram.</summary>
		/// <param name="eventName" type="String">The name of the event. See a list of supported events here.</param>
		/// <param name="handler" type="Method">Represents the method that handles the event specified with eventName.</param>
	},
	removeItem: function(item) {
		/// <summary>Removes the specified item from the Diagram.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The Diagram item to be removed.</param>
	},
	replay: function(recording, timer, savedState, timerInterval) {
		/// <summary>Replays a sequence of recorded mouse and keyboard events created by record and stopRecording methods.</summary>
		/// <param name="recording" type="Array">An array of event records returned by stopRecording.</param>
		/// <param name="timer" type="Boolean">true to replay records using a timer, preserving their original relative timing, or false to replay them immediately.</param>
		/// <param name="savedState" type="String" optional="true">Optional. A diagram JSON string that should be loaded before replaying recorded events.</param>
		/// <param name="timerInterval" type="Number" optional="true">Optional. A number of milliseconds to use as a constant interval instead of relative timing.</param>
	},
	resizeToFitItem: function(item) {
		/// <summary>Resize the document extents so that the specified item is contained within.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The item to be contained.</param>
	},
	resizeToFitItems: function(margin) {
		/// <summary>Resizes the document scrollable area so that it fits all diagram items.</summary>
		/// <param name="margin" type="Number"></param>
	},
	routeAllLinks: function() {
		/// <summary>Routes all links in the diagram in such a way they do not cross nodes.</summary>
	},
	saveToString: function(format) {
		/// <summary>Encodes the diagram contents into an XML or JSON string.</summary>
		/// <param name="format" type="SaveToStringFormat">A member of the SaveToStringFormat enumeration.</param>
		/// <returns type="String">A string containing the diagram's serialized representation.</returns>
	},
	saveToXml: function(url) {
		/// <summary>Saves the diagram to an XML file.</summary>
		/// <param name="url" type="String">A URL specifying where the diagram's XML should be posted to.</param>
	},
	scrollTo: function(x, y) {
		/// <summary>Scrolls the diagram to the specified point.</summary>
		/// <param name="x" type="Number">A number specifying the new horizontal scroll position in the current unit of measure.</param>
		/// <param name="y" type="Number">A number specifying the new vertical scroll position in the current unit of measure.</param>
	},
	setAdjustmentHandlesSize: function(value) {
		/// <summary>Sets the size of adjustment handles that appear around selected items.</summary>
		/// <param name="value" type="Number">A number specifying the size of selection handles.</param>
	},
	setAlignToGrid: function(value) {
		/// <summary>Sets a value indicating whether the diagram items should be aligned to a grid.</summary>
		/// <param name="value" type="Boolean">true if the diagram items should be aligned to a grid; otherwise, false.</param>
	},
	setAllowInplaceEdit: function(value) {
		/// <summary>Sets a value indicating whether in-place editing of the text of objects is enabled.</summary>
		/// <param name="value" type="Boolean">A bool value.</param>
	},
	setAllowMultipleResize: function(value) {
		/// <summary>Sets a value indicating whether multiple selected nodes can be resized simultaneously.</summary>
		/// <param name="value" type="Boolean">true to let the user resize multiple selected nodes; otherwise, false. The default value is false.</param>
	},
	setAllowSelfLoops: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to draw reflexive links.</summary>
		/// <param name="value" type="Boolean">A bool value.</param>
	},
	setAllowUnconnectedLinks: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to draw links that are not connected to any node.</summary>
		/// <param name="value" type="Boolean">true to let the user draw unconnected links; otherwise, false. The default value is false.</param>
	},
	setAutoArrangeAvoidContainers: function(value) {
		/// <summary>Sets a value indicating whether auto-arranged link labels should avoid containers.</summary>
		/// <param name="value" type="Boolean">true to avoid containers, or false otherwise.</param>
	},
	setAutoArrangeAvoidSegments: function(value) {
		/// <summary>Sets a value indicating whether auto-arranged link labels should avoid link segments.</summary>
		/// <param name="value" type="Boolean">true to avoid link segments, or false otherwise.</param>
	},
	setAutoCloseDistance: function(value) {
		/// <summary>Sets the maximum distance between first and last points of a FreeFormNodefor which the node's outline is closed automatically.</summary>
		/// <param name="value" type="Number">A float value.</param>
	},
	setAutoResize: function(value) {
		/// <summary>Sets a value indicating whether the document area should be resized automatically so it fits the diagram contents.</summary>
		/// <param name="value" type="MindFusion.Diagramming.AutoResize">A member of the AutoResize enumeration indicating the auto resize method.</param>
	},
	setAutoScroll: function(value) {
		/// <summary>Sets a value indicating whether auto scrolling of the document area is enabled.</summary>
		/// <param name="value" type="Boolean">True if auto scrolling is enabled, otherwise false.</param>
	},
	setAutoScrollAmount: function(value) {
		/// <summary>Sets the amount by which to auto-scroll the view when the mouse leaves the view boundaries while drawing.</summary>
		/// <param name="value" type="Number">A number specifying the amount by which to auto-scroll.</param>
	},
	setBackBrush: function(value) {
		/// <summary>Sets an object used for painting the diagram background.</summary>
		/// <param name="value" type="Object">The object used for painting the background.</param>
	},
	setBackgroundImageAlign: function(value) {
		/// <summary>Sets a value indicating how the background image is positioned.</summary>
		/// <param name="value" type="MindFusion.Drawing.ImageAlign">One of the ImageAlign enumeration values.</param>
	},
	setBackgroundImageContent: function(value) {
		/// <summary>Sets the Base64-encoded data of the background image.</summary>
		/// <param name="value" type="String">The Base64-encoded data for the background image to be loaded.</param>
	},
	setBackgroundImageUrl: function(value) {
		/// <summary>Sets the URL of the Image painted as diagram's background.</summary>
		/// <param name="value" type="String">The URL of the Image painted as diagram's background.</param>
	},
	setBehavior: function(value) {
		/// <summary>Sets a value indicating how the control responds to user actions.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Behavior">A member of the Behavior enumeration. The default is LinkShapes.</param>
	},
	setCrossingRadius: function(value) {
		/// <summary>Sets the radius length of decorations displayed at link intersection points.</summary>
		/// <param name="value" type="Number">A number specifying the radius of the arcs drawn at link intersection points.</param>
	},
	setCustomLinkType: function(value) {
		/// <summary>Sets the type of a MindFusion.Diagramming.DiagramLink derived class whose instance should be created when a user starts drawing.</summary>
		/// <param name="value" type="Object">The type.</param>
	},
	setCustomNodeType: function(value) {
		/// <summary>Sets the type of a MindFusion.Diagramming.DiagramNode derived class whose instance should be created when a user starts drawing.</summary>
		/// <param name="value" type="Object">The type.</param>
	},
	setDefaultShape: function(value) {
		/// <summary>Sets the default shape of shape nodes.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">A Shape instance or a string that identifies the Shape.</param>
	},
	setDelKeyAction: function(value) {
		/// <summary>Sets a value that specifies what action should be performed when the user hits the Del key.</summary>
		/// <param name="value" type="MindFusion.Diagramming.DelKeyAction">A DelKeyAction Enumeration value.</param>
	},
	setDirty: function(value) {
		/// <summary>Sets a value indicating whether the diagram has changed since loading it.</summary>
		/// <param name="value" type="Boolean">A boolean value that indicates whether the diagram has changed.</param>
	},
	setDynamicLinks: function(value) {
		/// <summary>Sets the default value for the Dynamic property of new links.</summary>
		/// <param name="value" type="Boolean">true if dynamic links should be enabled; otherwise, false.</param>
	},
	setEnabled: function(value) {
		/// <summary>Enables or disables handling of mouse events.</summary>
		/// <param name="value" type="Boolean">true if handling of mouse events is enabled; otherwise, false.</param>
	},
	setExpandOnIncoming: function(value) {
		/// <summary>Sets a value indicating the link direction in which tree branches are expanded.</summary>
		/// <param name="value" type="Boolean">true if trees are expanded in the direction of incoming links; otherwise, false. The default is false.</param>
	},
	setFont: function(value) {
		/// <summary>Sets the font for text displayed by diagram items.</summary>
		/// <param name="value" type="MindFusion.Drawing.Font">The font to set.</param>
	},
	setFreeFormAttractDistance: function(value) {
		/// <summary>Sets the radius around dragged free-form adjustment handlein which other points of FreeFormNode are modified too.</summary>
		/// <param name="value" type="Number">A float value.</param>
	},
	setFreeFormTargets: function(value) {
		/// <summary>Sets an array of Shape objects used to replace FreeFormNode instances withShapeNode ones when Behavior is set to LinkFreeShapes or DrawFreeShapes.</summary>
		/// <param name="value" type="Array">An array of shape identifiers or Shape instances.</param>
	},
	setGridColor: function(value) {
		/// <summary>Sets the color of the grid points.</summary>
		/// <param name="value" type="String">The color of the grid points.</param>
	},
	setGridOffsetX: function(value) {
		/// <summary>Sets the horizontal offset of the first point of the alignment grid.</summary>
		/// <param name="value" type="Number">The horizontal offset of the first point of the alignment grid.</param>
	},
	setGridOffsetY: function(value) {
		/// <summary>Sets the vertical offset of the first point of the alignment grid.</summary>
		/// <param name="value" type="Number">The vertical offset of the first point of the alignment grid.</param>
	},
	setGridPointSize: function(value) {
		/// <summary>Sets the size of shapes used to represent grid points.</summary>
		/// <param name="value" type="void"></param>
		/// <returns type="Number">value The size of shapes used to represent grid points.</returns>
	},
	setGridSizeX: function(value) {
		/// <summary>Sets the horizontal distance between adjacent grid points.</summary>
		/// <param name="value" type="Number">The horizontal distance between adjacent grid points.</param>
	},
	setGridSizeY: function(value) {
		/// <summary>Sets the vertical distance between adjacent grid points.</summary>
		/// <param name="value" type="Number">The vertical distance between adjacent grid points.</param>
	},
	setGridStyle: function(value) {
		/// <summary>Sets the visual style of the alignment grid.</summary>
		/// <param name="value" type="MindFusion.Diagramming.GridStyle">One of the GridStyle Enumeration values.</param>
	},
	setLinkBaseShape: function(value) {
		/// <summary>Sets the shape displayed at the base of new links.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape. The default is None.</param>
	},
	setLinkBaseShapeSize: function(value) {
		/// <summary>Sets the default size of the base shape of new links.</summary>
		/// <param name="value" type="Number">A number that specifies the size. The default is 5.</param>
	},
	setLinkBrush: function(value) {
		/// <summary>Sets the default fill of links.</summary>
		/// <param name="value" type="Object">An object identifying the fill of links.</param>
	},
	setLinkCrossings: function(value) {
		/// <summary>Sets a value indicating how to render the intersection points where two links cross each other.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LinkCrossings">A member of the LinkCrossings enumeration.</param>
	},
	setLinkHeadShape: function(value) {
		/// <summary>Sets the shape displayed as head of new links.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape. The default is Arrow.</param>
	},
	setLinkHeadShapeSize: function(value) {
		/// <summary>Sets the default size of arrowheads.</summary>
		/// <param name="value" type="Number">A number that measures the size. The default is 5.</param>
	},
	setLinkHitDistance: function(value) {
		/// <summary>Sets a value specifying how far from a link a click is still considered a hit.</summary>
		/// <param name="value" type="Number">A value specifying how far from a link a click is still considered a hit.</param>
	},
	setLinkPen: function(value) {
		/// <summary>Sets the default stroke of links.</summary>
		/// <param name="value" type="String">A string value specifying the stroke of links.</param>
	},
	setLinkRouter: function(value) {
		/// <summary>Sets the object used to find paths for auto-routed links when diagram nodes are added or their positions change.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Router">An instance of Router-derived class.</param>
	},
	setLinkSegments: function(value) {
		/// <summary>Sets the default number of arrow segments.</summary>
		/// <param name="value" type="Number">The default number of arrow segments.</param>
	},
	setLinkShape: function(value) {
		/// <summary>Sets the initial shape assigned to new links.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LinkShape">One of the LinkShape enumeration values.</param>
	},
	setLinkTextStyle: function(value) {
		/// <summary>Sets the default placement and orientation for links' text.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LinkTextStyle">One of the LinkTextStyle enumeration values.</param>
	},
	setMagnifierEnabled: function(value) {
		/// <summary>Sets a value indicating whether the magnifier tool is currently enabled.</summary>
		/// <param name="value" type="Boolean">true to enable the magnifier; otherwise, false. The default value is false.</param>
	},
	setMagnifierFactor: function(value) {
		/// <summary>Sets the zoom factor of the magnifier tool.</summary>
		/// <param name="value" type="Number">A number specifying the zoom factor of the magnifier tool.</param>
	},
	setMagnifierFrameColor: function(value) {
		/// <summary>Sets the color of the magnifier tool's frame.</summary>
		/// <param name="value" type="String">The color of the magnifier tool's frame.</param>
	},
	setMagnifierFrameThickness: function(value) {
		/// <summary>Sets the thickness of the magnifier frame.</summary>
		/// <param name="value" type="Number">A number specifying the thickness of the magnifier frame.</param>
	},
	setMagnifierHeight: function(value) {
		/// <summary>Sets the height of the magnifier tool.</summary>
		/// <param name="value" type="Number">A number specifying the height of the magnifier tool.</param>
	},
	setMagnifierSecondaryFrameColor: function(value) {
		/// <summary>Sets the color of the magnifier tool's secondary frame.</summary>
		/// <param name="value" type="String">The color of the magnifier tool's secondary frame.</param>
	},
	setMagnifierShading: function(value) {
		/// <summary>Sets a value indicating whether to enhance the effect of a magnifier lense by using a gradient shading.</summary>
		/// <param name="value" type="Boolean">true to enable the shading; otherwise, false. The default value is true.</param>
	},
	setMagnifierShape: function(value) {
		/// <summary>Sets a reference to the geometric shape definition of the magnifier tool.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">An instance of the Shape class.</param>
	},
	setMagnifierWidth: function(value) {
		/// <summary>Sets the width of the magnifier tool.</summary>
		/// <param name="value" type="Number">A number specifying the width of the magnifier tool.</param>
	},
	setMiddleButtonActions: function(value) {
		/// <summary>Sets a combination of flags that specify what actions can be performed via the middle mouse button.</summary>
		/// <param name="value" type="MindFusion.Diagramming.MouseButtonActions">A member of the MouseButtonActions enumeration.</param>
	},
	setModificationStart: function(value) {
		/// <summary>Sets how users can start modifying diagram items.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ModificationStart">A member of the ModificationStart enumeration. The default is SelectedOnly.</param>
	},
	setNodesExpandable: function(value) {
		/// <summary>Sets a value indicating whether newly created nodes can be collapsed and expanded by users.</summary>
		/// <param name="value" type="Boolean">A boolean value assigned to the Expandable property of new nodes. The default is false.</param>
	},
	setRightButtonActions: function(value) {
		/// <summary>Sets a combination of flags that specify what actions can be performed via the right mouse button.</summary>
		/// <param name="value" type="MindFusion.Diagramming.MouseButtonActions">A member of the MouseButtonActions enumeration.</param>
	},
	setRoundedLinks: function(value) {
		/// <summary>Sets a value indicating whether the joints between segments of Polyline and Cascading links should be rounded.</summary>
		/// <param name="value" type="Boolean">true to use rounded segment joints; otherwise, false.</param>
	},
	setRoundedLinksRadius: function(value) {
		/// <summary>Sets the radius of joint arcs of rounded links' segments.</summary>
		/// <param name="value" type="Number">A number specifying the radius length.</param>
	},
	setRouteLinks: function(value) {
		/// <summary>Sets a value indicating whether links should avoid nodes by going the shortest path from their origin to their destination without crossing any other nodes.</summary>
		/// <param name="value" type="Boolean">true to route links; otherwise, false. The default is false.</param>
	},
	setRouteMargin: function(value) {
		/// <summary>Sets the minimal distance between nodes and auto-routed links.</summary>
		/// <param name="value" type="Number">A value specifying distance in the current MeasureUnit; default is 8.</param>
	},
	setScroll: function(x, y) {
		/// <summary>IZoomTarget implementation</summary>
		/// <param name="x" type="void"></param>
		/// <param name="y" type="void"></param>
	},
	setScrollX: function(value) {
		/// <summary>Sets the diagram's horizontal scroll position.</summary>
		/// <param name="value" type="Number">A number specifying the new horizontal scroll position in the current unit of measure.</param>
	},
	setScrollY: function(value) {
		/// <summary>Sets the diagram's vertical scroll position.</summary>
		/// <param name="value" type="Number">A number specifying the new vertical scroll position in the current unit of measure.</param>
	},
	setScrollZoneSize: function(value) {
		/// <summary>Sets the size of the auto scroll zone near the edges of the control.</summary>
		/// <param name="value" type="Number">A number specifying the size of the auto scroll zone.</param>
	},
	setShadowOffsetX: function(value) {
		/// <summary>Sets the horizontal offset of objects' shadows.</summary>
		/// <param name="value" type="Number">A number specifying the shadow's horizontal offset.</param>
	},
	setShadowOffsetY: function(value) {
		/// <summary>Sets the vertical offset of objects' shadows.</summary>
		/// <param name="value" type="Number">A number specifying the shadow's vertical offset.</param>
	},
	setShadowsStyle: function(value) {
		/// <summary>Sets the style for rendering shadows.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ShadowsStyle">A member of the ShadowsStyle enumeration.</param>
	},
	setShapeBrush: function(value) {
		/// <summary>Sets the default fill of shape nodes.</summary>
		/// <param name="value" type="Object">An object identifying the fill of shape nodes.</param>
	},
	setShapeLibraryLocation: function(value) {
		/// <summary>Sets the location of a shape library file containing custom shape definitions.It can be set to a full URL of the file, or a relative file path.</summary>
		/// <param name="value" type="String">The location of a shape library file containing custom shape definitions.</param>
	},
	setShapePen: function(value) {
		/// <summary>Sets the default stroke of shape nodes.</summary>
		/// <param name="value" type="String">A string value specifying the stroke of shape nodes.</param>
	},
	setShowAnchors: function(value) {
		/// <summary>Sets a value indicating whether and when anchor point marks are displayed.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ShowAnchors">One of the ShowAnchors enumeration values.</param>
	},
	setShowDisabledHandles: function(value) {
		/// <summary>Sets a value indicating whether adjustment handles are painted when they are disabled.</summary>
		/// <param name="value" type="Boolean">true to display disabled manipulation handles; otherwise, false.</param>
	},
	setShowGrid: function(value) {
		/// <summary>Sets a value indicating whether the alignment grid is visible.</summary>
		/// <param name="value" type="Boolean">true if the alignment grid is visible; otherwise, false.</param>
	},
	setShowLaneGrid: function(value) {
		/// <summary>Sets a value indicating whether the lane grid is visible.</summary>
		/// <param name="value" type="Boolean">true if the lane grid is visible; otherwise, false.</param>
	},
	setStyle: function(value) {
		/// <summary>Sets the style associated with this diagram.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Style">An instance of the Style class.</param>
	},
	setTag: function(value) {
		/// <summary>Sets custom data associated with this diagram.</summary>
		/// <param name="value" type="Object">The custom data.</param>
	},
	setTheme: function(value) {
		/// <summary>Sets the theme associated with this diagram.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Theme">An instance of the Theme class.</param>
	},
	setTooltipDelay: function(value) {
		/// <summary>Sets the delay before a tooltip is shown.</summary>
		/// <param name="value" type="Number">The tooltip delay in milliseconds.</param>
	},
	setUndoEnabled: function(value) {
		/// <summary>Sets a value indicating whether saving action records for later undo is enabled.</summary>
		/// <param name="value" type="Boolean">true if undo is enabled, otherwise false.</param>
	},
	setVirtualScroll: function(value) {
		/// <summary>Enables or disables virtual scroll mode.</summary>
		/// <param name="value" type="Boolean">true to enable virtual scroll; otherwise, false.</param>
	},
	setZoomFactorPivot: function(zoomFactor, pivotPoint) {
		/// <summary>Sets the zoom factor, preserving the on-screen position of the specified diagram point.</summary>
		/// <param name="zoomFactor" type="Number">The new zoom factor.</param>
		/// <param name="pivotPoint" type="MindFusion.Drawing.Point">A Point instance specifying the zoom center.</param>
	},
	setZoomLevel: function(value) {
		/// <summary>IZoomTarget implementation.</summary>
		/// <param name="value" type="void"></param>
	},
	startCompositeOperation: function() {
		/// <summary>Starts recording undo/redo commands into a CompositeCommand.</summary>
	},
	stopRecording: function() {
		/// <summary>Stops recording mouse and keyboard events.</summary>
		/// <returns type="Array">An array of event records representing user's input.</returns>
	},
	toJson: function() {
		/// <summary>Serializes the diagram into a JSON string.</summary>
		/// <returns type="String">A string containing the diagram's JSON representation.</returns>
	},
	toXmlDocument: function() {
		/// <summary>Saves the diagram into an XML Document.</summary>
		/// <returns type="Document">A DOM Document object containing XML-serialized diagram contents.</returns>
	},
	undo: function() {
		/// <summary>Undoes an action saved in the command history.</summary>
	},
	zoomToFit: function() {
		/// <summary>Zooms the view to fit the document contents in the Diagram client area.</summary>
	},
	zoomToRect: function(rect) {
		/// <summary>Zooms and scrolls the view to fit the specified document rectangle in the Diagram's visible area.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">A Rect instance specifying the viewport position and size.</param>
	}
};
MindFusion.Diagramming.Diagram.__class = true;

MindFusion.Diagramming.Diagram.create = function(element) {
	/// <summary>Creates and initializes a new Diagram from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the diagram should be attached to.</param>
	/// <returns type="MindFusion.Diagramming.Diagram">A Diagram object that represents the newly created diagram.</returns>
};
MindFusion.Diagramming.Diagram.find = function(id, parent) {
	/// <summary>Returns the specified Diagram object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the diagram to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the diagram to find.</param>
	/// <returns type="MindFusion.Diagramming.Diagram">A Diagram object that contains the diagram requested by id, if found; otherwise, null.</returns>
};
MindFusion.Diagramming.Diagram.registerItemClass = function(itemClass, classId, classVersion) {
	/// <summary>Registers a diagram item class for serialization support.</summary>
	/// <param name="itemClass" type="Object">An object identifying the item class.</param>
	/// <param name="classId" type="String">A class identifier to use when saving and loading items of the specified type.</param>
	/// <param name="classVersion" type="Number">A revision number of the item's class serialization format.</param>
};

MindFusion.Diagramming.DiagramEventArgs.prototype = {
	getMouseButton: function() {
		/// <summary>Gets which mouse button has been pressed.</summary>
		/// <returns type="MouseButton">One of the MouseButton enumeration values.</returns>
	},
	getMousePosition: function() {
		/// <summary>Gets the current mouse pointer position.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point instance.</returns>
	}
};
MindFusion.Diagramming.DiagramEventArgs.__class = true;

MindFusion.Diagramming.DiagramItem.prototype = {
	addCanvasElements: function() {
		/// <summary>Derived classes must implement this method by adding their graphics primitives to the canvas.elements collection.</summary>
	},
	allowDrag: function(ist) {
		/// <summary>Invoked to validate the drag operation.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	containsPoint: function(point) {
		/// <summary>Determines whether this item contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <returns type="Boolean">true if this item contains the specified point; otherwise, false.</returns>
	},
	endDrag: function(ist) {
		/// <summary>Invoked when the user stops dragging this item.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes this item from a JSON string.</summary>
		/// <param name="json" type="String">A string created by the toJson method.</param>
	},
	getBrush: function() {
		/// <summary>Gets the object that specifies how to paint the interior of the DiagramItem.</summary>
		/// <returns type="Object">An object specifying the fill of the item.</returns>
	},
	getContainer: function() {
		/// <summary>Gets the parent container node of this item.</summary>
		/// <returns type="ContainerNode">The parent container node of this item.</returns>
	},
	getEffectiveBrush: function() {
		/// <summary>Gets the effective brush that should be used to paint this item.</summary>
		/// <returns type="Object">An object specifying the fill of this item.</returns>
	},
	getEffectiveFont: function() {
		/// <summary>Gets the effective font that should be used to render this item's text.</summary>
		/// <returns type="MindFusion.Drawing.Font">A Font instance.</returns>
	},
	getEffectiveFontName: function() {
		/// <summary>Gets the name of the effective font that should be used to render this item's text.</summary>
		/// <returns type="String">A string specifying the font name.</returns>
	},
	getEffectiveFontSize: function() {
		/// <summary>Gets the size of the effective font that should be used to render this item's text.</summary>
		/// <returns type="Number">A number specifying the font size.</returns>
	},
	getEffectiveFontStyle: function() {
		/// <summary>Gets the style of the effective font that should be used to render this item's text.</summary>
		/// <returns type="MindFusion.Drawing.FontStyle">A combination of FontStyle enumeration members.</returns>
	},
	getEffectiveShadowColor: function() {
		/// <summary>Gets the effective color that should be used to render this item's shadow.</summary>
		/// <returns type="String">A string specifying the item's shadow color.</returns>
	},
	getEffectiveStroke: function() {
		/// <summary>Gets the effective color that should be used to stroke this item.</summary>
		/// <returns type="String">A string specifying the item's stroke color.</returns>
	},
	getEffectiveStrokeDashStyle: function() {
		/// <summary>Gets the effective line dash pattern that should be applied when stroking this item.</summary>
		/// <returns type="MindFusion.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	getEffectiveStrokeThickness: function() {
		/// <summary>Gets the effective line thickness that should be applied when stroking this item.</summary>
		/// <returns type="Number">A number specifying the item's stroke thickness.</returns>
	},
	getEffectiveTextColor: function() {
		/// <summary>Gets the effective text color that should be used to render this item's text.</summary>
		/// <returns type="String">A string specifying the item's text color.</returns>
	},
	getEffectiveTextStroke: function() {
		/// <summary>Gets the effective text color that should be used to render this item's text outline.</summary>
		/// <returns type="String">A string specifying the item's text outline color.</returns>
	},
	getEffectiveTextStrokeThickness: function() {
		/// <summary>Gets the effective width of the text outline of this item.</summary>
		/// <returns type="Number">The width of the text outline of this item.</returns>
	},
	getFont: function() {
		/// <summary>Gets the font used to render this item's text.</summary>
		/// <returns type="MindFusion.Drawing.Font">A Font instance.</returns>
	},
	getGraphicsContent: function() {
		/// <summary>Returns the array with visual elements that areused to represent this item on the canvas.</summary>
		/// <returns type="Array">The collection of visual elements.</returns>
	},
	getHyperLink: function() {
		/// <summary>Gets the hyperlink associated with this diagram item.</summary>
		/// <returns type="String">The hyperlink.</returns>
	},
	getId: function() {
		/// <summary>Gets the id of the item.</summary>
		/// <returns type="Object">The id.</returns>
	},
	getIgnoreLayout: function() {
		/// <summary>Gets a value indicating whether the position of this item should not be changed by automatic layout methods.</summary>
		/// <returns type="Boolean">true if this item is not affected by automatic layouts; otherwise, false.</returns>
	},
	getLayoutTraits: function() {
		/// <summary>Gets an object containing properties of the node, used by some layout algorithms.</summary>
		/// <returns type="Object">An object containing the layout properties.</returns>
	},
	getLineAlignment: function() {
		/// <summary>Gets how the text should be vertically aligned inside the item's bounding rectangle.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	getLocked: function() {
		/// <summary>Gets a value indicating whether users are allowed to modify this item.</summary>
		/// <returns type="Boolean">true to prevent users from modifying the item, otherwise false.</returns>
	},
	getParent: function() {
		/// <summary>Gets the parent diagram.</summary>
		/// <returns type="MindFusion.Diagramming.Diagram">Gets the Diagram this DiagramItem belongs to.</returns>
	},
	getPen: function() {
		/// <summary>Gets an object used to paint the frame of the item.</summary>
		/// <returns type="String">A string value identifying the stroke of the item frame.</returns>
	},
	getRepaintBounds: function() {
		/// <summary>Gets the repaint region for this item, taking into account factors such as pen width, selection handles and shadow.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A rectangular region that should be repainted when this item is modified.</returns>
	},
	getSelected: function() {
		/// <summary>Gets a value indicating whether a diagram item is selected.</summary>
		/// <returns type="Boolean">true if the item is selected; otherwise, false.</returns>
	},
	getShadowColor: function() {
		/// <summary>Gets the color used to draw the shadow of this item.</summary>
		/// <returns type="String">A string specifying the shadow color.</returns>
	},
	getShadowOffsetX: function() {
		/// <summary>Gets the horizontal offset of the item's shadow.</summary>
		/// <returns type="Number">A number specifying the shadow's horizontal offset.</returns>
	},
	getShadowOffsetY: function() {
		/// <summary>Gets the vertical offset of the item's shadow.</summary>
		/// <returns type="Number">A number specifying the shadow's vertical offset.</returns>
	},
	getStroke: function() {
		/// <summary>Gets a string specifying the color used to stroke the item's frame.</summary>
		/// <returns type="String">A string value identifying the stroke color.</returns>
	},
	getStrokeDashStyle: function() {
		/// <summary>Gets the line dash pattern applied when stroking the item's frame.</summary>
		/// <returns type="MindFusion.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	getStrokeThickness: function() {
		/// <summary>Gets the line width applied when stroking the item's frame.</summary>
		/// <returns type="Number">A number identifying the stroke thickness.</returns>
	},
	getStyle: function() {
		/// <summary>Gets the style associated with this item.</summary>
		/// <returns type="MindFusion.Diagramming.Style">An instance of the Style class.</returns>
	},
	getTag: function() {
		/// <summary>Gets the tag of the item.</summary>
		/// <returns type="Object">The tag.</returns>
	},
	getText: function() {
		/// <summary>Gets the string containing the DiagramItem's text.</summary>
		/// <returns type="String">The string that contains the text.</returns>
	},
	getTextAlignment: function() {
		/// <summary>Gets how the text should be aligned inside the item's bounding rectangle.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets a string specifying the color of the text of this item.</summary>
		/// <returns type="String">A string value identifying the color of the text.</returns>
	},
	getTextComponent: function() {
		/// <summary>Gets the Text object instance that is used as a container for the item's text.</summary>
		/// <returns type="Text">The Text container.</returns>
	},
	getTextPadding: function() {
		/// <summary>Gets the spacing between the item boundaries and its text.</summary>
		/// <returns type="MindFusion.Drawing.Thickness">A Thickness instance specifying the size of padding space left around the text.</returns>
	},
	getTextStroke: function() {
		/// <summary>Gets a string specifying the color of the text outline of this item.</summary>
		/// <returns type="String">A string value identifying the color of the text outline.</returns>
	},
	getTextStrokeThickness: function() {
		/// <summary>Gets the width of the text outline of this item.</summary>
		/// <returns type="Number">The width of the text outline of this item.</returns>
	},
	getTooltip: function() {
		/// <summary>Gets the tooltip text that should be displayed when the mouse hovers over this item.</summary>
		/// <returns type="String">A string containing the tooltip text.</returns>
	},
	getVisible: function() {
		/// <summary>Gets a value indicating whether this item is visible.</summary>
		/// <returns type="Boolean">true if this item should be displayed; otherwise, false.</returns>
	},
	getWeight: function() {
		/// <summary>Gets a weight value used in layout and path-finding algorithms.</summary>
		/// <returns type="Number">A number specifying the weight of this item. The default value is 1.</returns>
	},
	getZIndex: function() {
		/// <summary>Gets the z-order position of the object.</summary>
		/// <returns type="Number">A number specifying the position of the diagram item within the z-order.</returns>
	},
	hitTest: function(point, threshold, onlyNodes, onlyInteractive) {
		/// <summary>Returns the diagram item that contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point value specifying the logical coordinates of a diagram point.</param>
		/// <param name="threshold" type="Number" optional="true">Optional. Specifies the size of the area around the item outlines where the point is still considered inside the item.</param>
		/// <param name="onlyNodes" type="Boolean" optional="true">Optional. true to exclude child links from the search.</param>
		/// <param name="onlyInteractive" type="Boolean" optional="true">Optional. true to exclude locked items from the search.</param>
		/// <returns type="MindFusion.Diagramming.DiagramItem">The item that contains the specified point.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Loads the item content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that contains the item's serialized content.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	onRemove: function() {
		/// <summary>Called when an item is removed from a Diagram, either by the user, programmatically or via undo / redo.</summary>
	},
	removeCanvasElements: function() {
		/// <summary>Derived classes must implement this method by removing their graphics primitives from the canvas.elements collection.</summary>
	},
	saveLocationState: function() {
		/// <summary>Saves the state of this diagram item.</summary>
		/// <returns type="DiagramLinkState">A DiagramLinkState instance.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the item content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of the DiagramItem.</summary>
		/// <param name="value" type="Object">A Brush object specifying the fill of the item.</param>
	},
	setFont: function(value) {
		/// <summary>Sets the font used to render this item's text.</summary>
		/// <param name="value" type="MindFusion.Drawing.Font">A Font instance.</param>
	},
	setHyperLink: function(value) {
		/// <summary>Sets the hyperlink associated with this diagram item.</summary>
		/// <param name="value" type="String">The hyperlink.</param>
	},
	setId: function(value) {
		/// <summary>Lets you set any object as an id for this item.</summary>
		/// <param name="value" type="Object">The id of the item.</param>
	},
	setIgnoreLayout: function(value) {
		/// <summary>Sets a value indicating whether the position of this item should not be changed by automatic layout methods.</summary>
		/// <param name="value" type="Boolean">true to prevent layouts from changing the position of this item; otherwise, false.</param>
	},
	setLineAlignment: function(value) {
		/// <summary>Sets how the text should be vertically aligned inside the item's bounding rectangle.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	},
	setLocked: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to modify this item.</summary>
		/// <param name="value" type="Boolean">true to prevent users from modifying the item, otherwise false.</param>
	},
	setPen: function(value) {
		/// <summary>Sets an object used to paint the frame of the item.</summary>
		/// <param name="value" type="Object">A Pen value identifying the stroke of the item frame.</param>
	},
	setSelected: function(value) {
		/// <summary>Sets a value indicating whether a diagram item is selected.</summary>
		/// <param name="value" type="Boolean">true if the item is selected; otherwise, false.</param>
	},
	setShadowColor: function(value) {
		/// <summary>Sets the color used to draw the shadow of this item.</summary>
		/// <param name="value" type="String">A string specifying the shadow color.</param>
	},
	setShadowOffsetX: function(value) {
		/// <summary>Sets the horizonal offset of the item's shadow.</summary>
		/// <param name="value" type="Number">A number specifying the shadow's horizontal offset.</param>
	},
	setShadowOffsetY: function(value) {
		/// <summary>Sets the vertical offset of the item's shadow.</summary>
		/// <param name="value" type="Number">A number specifying the shadow's vertical offset.</param>
	},
	setStroke: function(value) {
		/// <summary>Sets a string specifying the color used to stroke the item's frame.</summary>
		/// <param name="value" type="String">A string value identifying the stroke color.</param>
	},
	setStrokeDashStyle: function(value) {
		/// <summary>Sets the line dash pattern applied when stroking the item's frame.</summary>
		/// <param name="value" type="MindFusion.Drawing.DashStyle">A member of the DashStyle enumeration.</param>
	},
	setStrokeThickness: function(value) {
		/// <summary>Sets the line width applied when stroking the item's frame.</summary>
		/// <param name="value" type="Number">A number identifying the stroke thickness.</param>
	},
	setStyle: function(value) {
		/// <summary>Sets the style associated with this item.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Style">An instance of the Style class.</param>
	},
	setTag: function(value) {
		/// <summary>Lets you set any object as a tag for this item.</summary>
		/// <param name="value" type="Object">The tag of the item.</param>
	},
	setText: function(value) {
		/// <summary>Sets a string containing the DiagramItem's text.</summary>
		/// <param name="value" type="String">The string to set.</param>
	},
	setTextAlignment: function(value) {
		/// <summary>Sets how the text should be aligned inside the item's bounding rectangle.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets a string specifying the color of the text of this item.</summary>
		/// <param name="value" type="String">A string value identifying the color of the text.</param>
	},
	setTextPadding: function(value) {
		/// <summary>Sets the spacing between the item boundaries and its text.</summary>
		/// <param name="value" type="MindFusion.Drawing.Thickness">A Thickness instance specifying the size of padding space left around the text.</param>
	},
	setTextStroke: function(value) {
		/// <summary>Sets a string specifying the color of the text outline of this item.</summary>
		/// <param name="value" type="String">A string value identifying the color of the text outline.</param>
	},
	setTextStrokeThickness: function(value) {
		/// <summary>Sets the width of the text outline of this item.</summary>
		/// <param name="value" type="Number">The width of the text outline of this item.</param>
	},
	setTooltip: function(value) {
		/// <summary>Sets the tooltip text that should be displayed when the mouse hovers over this item.</summary>
		/// <param name="value" type="String">A string containing the tooltip text.</param>
	},
	setVisible: function(value) {
		/// <summary>Sets a value indicating whether this item is visible.</summary>
		/// <param name="value" type="Boolean">true to display this item; otherwise, false.</param>
	},
	setWeight: function(value) {
		/// <summary>Sets a weight value used in layout and path-finding algorithms.</summary>
		/// <param name="value" type="Number">A number specifying the weight of this item. The default value is 1.</param>
	},
	setZIndex: function(value) {
		/// <summary>Sets the z-order position of the object.</summary>
		/// <param name="value" type="Number">A number specifying the position of the diagram item within the z-order.</param>
	},
	startDrag: function(ist) {
		/// <summary>Invoked when the user starts dragging this item.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	toJson: function() {
		/// <summary>Serializes this item into a JSON string.</summary>
		/// <returns type="String">A string containing the item's JSON representation.</returns>
	},
	updateCanvasElements: function() {
		/// <summary>Derived classes must implement this method to update the item's visual elements.</summary>
	},
	updateDrag: function(ist) {
		/// <summary>Invoked while the user drags this item.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	}
};
MindFusion.Diagramming.DiagramItem.__class = true;

MindFusion.Diagramming.DiagramLink.prototype = {
	addLabel: function(text) {
		/// <summary>Adds a new label to this link.</summary>
		/// <param name="text" type="String">The label's text.</param>
		/// <returns type="MindFusion.Diagramming.LinkLabel">A LinkLabel instance.</returns>
	},
	allowDrag: function(ist) {
		/// <summary>DiagramItem.allowDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	containsPoint: function(point) {
		/// <summary>DiagramItem.containsPoint override.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <returns type="Boolean">true if the link contains the point; otherwise, false.</returns>
	},
	endDrag: function(ist) {
		/// <summary>DiagramItem.endDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	getAutoRoute: function() {
		/// <summary>Gets a value indicating whether a link should avoid nodes by going the shortest path from its origin to its destination without crossing any other nodes.</summary>
		/// <returns type="Boolean">true to route this link; otherwise, false.</returns>
	},
	getBaseBrush: function() {
		/// <summary>Gets an object that specifies how to paint the interior of the link's base shape.</summary>
		/// <returns type="Object">An object specifying the fill of the shape.</returns>
	},
	getBaseShape: function() {
		/// <summary>Gets the shape displayed at the beginning of this link.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape.</returns>
	},
	getBaseShapeSize: function() {
		/// <summary>Gets the size of the shape displayed at the beginning of this link.</summary>
		/// <returns type="Number">A number that represents the size of the arrowhead shape.</returns>
	},
	getControlPoints: function() {
		/// <summary>Gets a collection of the control points of this link.</summary>
		/// <returns type="Array">A collection of control points that specify the link's shape.</returns>
	},
	getDestination: function() {
		/// <summary>Gets the destination node of this link.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The node that is destination for the link.</returns>
	},
	getDestinationAnchor: function() {
		/// <summary>Gets the anchor point to which a link is connected at its destination.</summary>
		/// <returns type="Number">An integer value specifying the index of the destination anchor point.</returns>
	},
	getDynamic: function() {
		/// <summary>Gets a value indicating whether a link automatically adjusts its end points' positions in order to keep pointing to the centers of nodes that it connects.</summary>
		/// <returns type="Boolean">true if the link automatically adjusts its end points; otherwise, false.</returns>
	},
	getEndPoint: function() {
		/// <summary>Gets the last control point of this link.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point instance containing the control point coordinates.</returns>
	},
	getHeadBrush: function() {
		/// <summary>Gets an object that specifies how to paint the interior of the link's arrowhead shape.</summary>
		/// <returns type="Object">An object specifying the fill of the shape.</returns>
	},
	getHeadShape: function() {
		/// <summary>Gets the shape displayed at the end of this link.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape.</returns>
	},
	getHeadShapeSize: function() {
		/// <summary>Gets the size of the shape displayed at the end of this link.</summary>
		/// <returns type="Number">A number that represents the size of the arrowhead shape.</returns>
	},
	getHeadStroke: function() {
		/// <summary>Gets an object that specifies how to paint the outline of the link's arrowhead shape.</summary>
		/// <returns type="Object">An object specifying the outline of the shape.</returns>
	},
	getHeadStrokeDashStyle: function() {
		/// <summary>Gets an object that specifies the effective line dash pattern of the outline of the link's arrowhead shape.</summary>
		/// <returns type="MindFusion.Drawing.DashStyle">An object specifying the effective line dash pattern of the outline of the link's arrowhead shape.</returns>
	},
	getHeadStrokeThickness: function() {
		/// <summary>Gets an object that specifies the line thickness of the outline of the link's arrowhead shape.</summary>
		/// <returns type="Number">A number specifying the line thickness of the outline of the link's arrowhead shape.</returns>
	},
	getLength: function(segments) {
		/// <summary>Gets the length of the links</summary>
		/// <param name="segments" type="Array" optional="true">Optional. A list of points specifying the polyline segments.</param>
		/// <returns type="Number">The sum of the lengths of the line's segments.</returns>
	},
	getOrigin: function() {
		/// <summary>Gets the origin of the DiagramLink.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The node that is the origin of the link.</returns>
	},
	getOriginAnchor: function() {
		/// <summary>Gets the anchor point to which a link is connected at its origin.</summary>
		/// <returns type="Number">An integer value specifying the index of the origin anchor point.</returns>
	},
	getSegmentCount: function() {
		/// <summary>Gets the number of segments that form the link's geometry.</summary>
		/// <returns type="Number">An integer value specifying the number of segments of this link.</returns>
	},
	getShape: function() {
		/// <summary>Gets the type of link segments and how they are positioned one relatively to another.</summary>
		/// <returns type="MindFusion.Diagramming.LinkShape">One of the LinkShape Enumeration values.</returns>
	},
	getStartPoint: function() {
		/// <summary>Gets the first control point of this link.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point instance containing the control point coordinates.</returns>
	},
	getText: function() {
		/// <summary>Gets the string containing the DiagramItem's text.</summary>
		/// <returns type="String">The string that contains the text.</returns>
	},
	getTextAlignment: function() {
		/// <summary>Gets the link's text alignment.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">A member of the Alignment enumeration.</returns>
	},
	getTextStyle: function() {
		/// <summary>Gets the link's text placement and orientation.</summary>
		/// <returns type="MindFusion.Diagramming.LinkTextStyle">One of the LinkTextStyle enumeration values.</returns>
	},
	getTopLevel: function() {
		/// <summary>DiagramItem.getTopLevel override.</summary>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this DiagramLink instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	intersects: function(rect) {
		/// <summary>Checks whether the link contour intersects with the outline of the specified node.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The bounding rectangle of the specified node.</param>
		/// <returns type="Boolean"></returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramItem.LoadFromXml override. Loads the link's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	pointAlongLength: function(lengthFactor, segments) {
		/// <summary>Returns a point lying on a polyline that is positioned at a relative position along the polyline's length.</summary>
		/// <param name="lengthFactor" type="Number">A value from 0 to 1 specifying a portion of link's length.</param>
		/// <param name="segments" type="Array" optional="true">Optional. A list of points specifying the polyline segments.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point instance.</returns>
	},
	putEndPointsAtNodeBorders: function(action, routing) {
		/// <summary>Places the link's end points on the outline of its origin and destination nodes.</summary>
		/// <param name="action" type="MindFusion.Diagramming.Action"></param>
		/// <param name="routing" type="Boolean"></param>
	},
	removeLabel: function(label) {
		/// <summary>Removes the specified label from this link.</summary>
		/// <param name="label" type="MindFusion.Diagramming.LinkLabel">A LinkLabel instance.</param>
	},
	restoreLocationState: function(ist) {
		/// <summary>DiagramItem.restoreLocationState override.</summary>
		/// <param name="ist" type="DiagramLinkState">A DiagramLinkState instance.</param>
	},
	route: function(args) {
		/// <summary>Routes this link, regardless of whether the link's AutoRoute flag is enabled.</summary>
		/// <param name="args" type="Object"></param>
	},
	saveLocationState: function() {
		/// <summary>DiagramItem.saveLocationState override.</summary>
		/// <returns type="DiagramLinkState">A DiagramLinkState instance.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the item's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setAutoRoute: function(value) {
		/// <summary>Sets a value indicating whether a link should avoid nodes by going the shortest path from its origin to its destination without crossing any other nodes.</summary>
		/// <param name="value" type="Boolean">true to route this link; otherwise, false.</param>
	},
	setBaseBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of the link's base shape.</summary>
		/// <param name="value" type="Object">An object specifying the fill of the shape.</param>
	},
	setBaseShape: function(shape) {
		/// <summary>Sets the shape to display at the beginning of this link.</summary>
		/// <param name="shape" type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape.</param>
	},
	setBaseShapeSize: function(value) {
		/// <summary>Sets the size of the shape displayed at the beginning of this link.</summary>
		/// <param name="value" type="Number">A number that represents the size of the arrowhead shape.</param>
	},
	setControlPoints: function(value) {
		/// <summary>Sets a collection of the control points of this link.</summary>
		/// <param name="value" type="Array">A collection of control points that specify the link's shape.</param>
	},
	setDestination: function(destination) {
		/// <summary>Sets the destination node of this link.</summary>
		/// <param name="destination" type="MindFusion.Diagramming.DiagramNode">The node that will be destination for the link.</param>
	},
	setDestinationAnchor: function(index) {
		/// <summary>Sets the anchor point to which a link is connected at its destination.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of the destination anchor point.</param>
	},
	setDynamic: function(value) {
		/// <summary>Sets a value indicating whether a link automatically adjusts its end points' positions in order to keep pointing to the centers of nodes that it connects.</summary>
		/// <param name="value" type="Boolean">true to make the link automatically adjust its end points; otherwise, false.</param>
	},
	setEndPoint: function(value) {
		/// <summary>Sets the last control point of this link.</summary>
		/// <param name="value" type="MindFusion.Drawing.Point">A Point instance containing the control point coordinates.</param>
	},
	setHeadBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of the link's arrowhead shape.</summary>
		/// <param name="value" type="Object">An object specifying the fill of the shape.</param>
	},
	setHeadShape: function(value) {
		/// <summary>Sets the shape to display at the end of this link.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">A Shape instance that represents an arrowhead shape.</param>
	},
	setHeadShapeSize: function(value) {
		/// <summary>Sets the size of the shape displayed at the end of this link.</summary>
		/// <param name="value" type="Number">A number that represents the size of the arrowhead shape.</param>
	},
	setHeadStroke: function(value) {
		/// <summary>Sets an object that specifies how to paint the outline of the link's arrowhead shape.</summary>
		/// <param name="value" type="Object">An object specifying the outline of the shape.</param>
	},
	setHeadStrokeDashStyle: function(value) {
		/// <summary>Sets an object that specifies the effective line dash pattern of the outline of the link's arrowhead shape.</summary>
		/// <param name="value" type="MindFusion.Drawing.DashStyle">An object specifying the effective line dash pattern of the outline of the shape.</param>
	},
	setHeadStrokeThickness: function(value) {
		/// <summary>Sets a number that specifies the line thickness of the outline of the link's arrowhead shape.</summary>
		/// <param name="value" type="Number">A number specifying the line thickness of the outline of the shape.</param>
	},
	setOrigin: function(origin) {
		/// <summary>Sets the origin of the DiagramLink.</summary>
		/// <param name="origin" type="MindFusion.Diagramming.DiagramNode">The node that will be the origin of the link.</param>
	},
	setOriginAnchor: function(index) {
		/// <summary>Sets the anchor point to which a link is connected at its origin.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of the origin anchor point.</param>
	},
	setSegmentCount: function(value) {
		/// <summary>Sets the number of segments that form the link's geometry.</summary>
		/// <param name="value" type="Number">An integer value specifying the number of segments of this link.</param>
	},
	setShape: function(value) {
		/// <summary>Sets the type of link segments and how they are positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LinkShape">One of the LinkShape enumeration values.</param>
	},
	setStartPoint: function(value) {
		/// <summary>Sets the first control point of this link.</summary>
		/// <param name="value" type="MindFusion.Drawing.Point">A Point instance containing the control point coordinates.</param>
	},
	setText: function(value) {
		/// <summary>Sets a string containing the DiagramItem's text.</summary>
		/// <param name="value" type="String">The string to set.</param>
	},
	setTextAlignment: function(value) {
		/// <summary>Sets the link's text alignment.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">A member of the Alignment enumeration.</param>
	},
	setTextStyle: function(value) {
		/// <summary>Sets the link's text placement and orientation.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LinkTextStyle">One of the LinkTextStyle enumeration values.</param>
	},
	startDrag: function(ist) {
		/// <summary>DiagramItem.startDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	updateCanvasElements: function() {
		/// <summary>Updates the elements on the HTML Canvas.</summary>
	},
	updateDrag: function(ist) {
		/// <summary>DiagramItem.updateDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	updateFromPoints: function() {
		/// <summary>Updates the link's internal state after the link's control points have been changed.</summary>
	},
};
MindFusion.Diagramming.DiagramLink.__class = true;

MindFusion.Diagramming.DiagramLink.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new DiagramLink instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.DiagramNode.prototype = {
	acceptLinks: function(outgoing) {
		/// <summary>Determines whether the node can be connected with links of the specified type.</summary>
		/// <param name="outgoing" type="Boolean">true to check for outgoing links; otherwise, false.</param>
		/// <returns type="Boolean">true if the node accepts connections of the specified type; otherwise, false.</returns>
	},
	allowDrag: function(ist) {
		/// <summary>DiagramItem.allowDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	attach: function(subordinate) {
		/// <summary>Attaches the specified subordinate node to this node, so that when this node is moved, the subordinate follows it.</summary>
		/// <param name="subordinate" type="MindFusion.Diagramming.DiagramNode">A DiagramNode instance specifying the node that should be attached.</param>
	},
	attachTo: function(node) {
		/// <summary>Attaches this node to the specified master node so that when the master is moved, the attached node follows it.</summary>
		/// <param name="node" type="MindFusion.Diagramming.DiagramNode">A DiagramNode instance specifying the master node.</param>
	},
	containsPoint: function(point) {
		/// <summary>DiagramItem.containsPoint override.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <returns type="Boolean">true it this node contains the specified point; otherwise, false.</returns>
	},
	createConnectionPoint: function(link, point, incoming) {
		/// <summary>Creates a connection point between this node and the specified link at the specified point.</summary>
		/// <param name="link" type="MindFusion.Diagramming.DiagramLink">A DiagramLink that should be connected to this node.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">The point at which the link should be connected.</param>
		/// <param name="incoming" type="Boolean">true if link is an incoming link, otherwise, false.</param>
		/// <returns type="MindFusion.Diagramming.ConnectionPoint"></returns>
	},
	detach: function() {
		/// <summary>Detaches this node from its current master node.</summary>
	},
	endDrag: function(ist) {
		/// <summary>DiagramItem.endDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	getAllowIncomingLinks: function() {
		/// <summary>Gets a value indicating whether users are allowed to draw incoming links to this node.</summary>
		/// <returns type="Boolean">true if users are allowed to draw incoming links to this node; otherwise, false.</returns>
	},
	getAllowOutgoingLinks: function() {
		/// <summary>Sets a value indicating whether users are allowed to draw outgoing links to this node.</summary>
		/// <returns type="Boolean">true if users are allowed to draw outgoing links to this node; otherwise, false.</returns>
	},
	getAnchorPattern: function() {
		/// <summary>Gets the anchor points to which links are attached when connected to the node.</summary>
		/// <returns type="MindFusion.Diagramming.AnchorPattern">An AnchorPattern object that defines the anchor points for this node.</returns>
	},
	getAttachedNodes: function() {
		/// <summary>Returns the nodes attached to this node.</summary>
		/// <returns type="Array">An array of nodes attached to this node via the attach or attachTo methods.</returns>
	},
	getBounds: function() {
		/// <summary>Gets the rectangle that defines the position of the diagram node.</summary>
		/// <returns type="MindFusion.Drawing.Rect">The node's bounding rectangle.</returns>
	},
	getCenter: function() {
		/// <summary>Gets the center of this node's bounding rectangle.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point object representing the center point of this node.</returns>
	},
	getEffectiveEffects: function() {
		/// <summary>Gets the effects that should be applied to this item.</summary>
		/// <returns type="Array">An array with the effective node effects.</returns>
	},
	getEffects: function() {
		/// <summary>Gets an array with all effects applied to this node.</summary>
		/// <returns type="Array">An array with all node effects.</returns>
	},
	getEnabledHandles: function() {
		/// <summary>Gets the kinds of modifications that end-users are permitted to perform on the node.</summary>
		/// <returns type="MindFusion.Diagramming.AdjustmentHandles">A combination of the AdjustmentHandles enumeration members.</returns>
	},
	getExpandable: function() {
		/// <summary>Gets a value indicating whether users are allowed to expand or collapse the tree branch that starts at this node.</summary>
		/// <returns type="Boolean">true if users are allowed to expand/collapse the tree branch, otherwise false.</returns>
	},
	getExpanded: function() {
		/// <summary>Gets a value indicating whether the tree branch starting at this node is expanded.</summary>
		/// <returns type="Boolean">true if the branch starting at this node is expanded; otherwise, false.</returns>
	},
	getHandlesStyle: function() {
		/// <summary>Gets a value indicating how the node adjustment handles behave and what do they look like.</summary>
		/// <returns type="MindFusion.Diagramming.HandlesStyle">A member of the HandlesStyle enumeration. The default value is SquareHandles.</returns>
	},
	getIncomingLinks: function() {
		/// <summary>Gets the incoming links collection of this node.</summary>
		/// <returns type="Array">An array with the incoming DiagramLink-s.</returns>
	},
	getIntersection: function(point1, point2) {
		/// <summary>Calculates the intersection point between the segment defined by the specified point pair and the node's outline.</summary>
		/// <param name="point1" type="MindFusion.Drawing.Point">The first point of the segment.</param>
		/// <param name="point2" type="MindFusion.Drawing.Point">The second point of the segment.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point object representing the intersection point.</returns>
	},
	getMasterNode: function() {
		/// <summary>Returns the node to which this node is attached.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramNode">A DiagramNode reference specifying the node to which this node has been previously attached via the attach or attachTo method.</returns>
	},
	getObstacle: function() {
		/// <summary>Gets a value indicating whether this node is considered an obstacle by the link-routing algorithm.</summary>
		/// <returns type="Boolean">true if routed links look for a path going around this node; false lets links cross the node. The default value is true.</returns>
	},
	getOutgoingLinks: function() {
		/// <summary>Gets the outgoing links collection of this node.</summary>
		/// <returns type="Array">An array with the outgoing DiagramLink-s.</returns>
	},
	getOutline: function() {
		/// <summary>Gets the bounding rectangle of this node.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A rectangle.</returns>
	},
	getRotatedBounds: function() {
		/// <summary>Gets the bounding rectangle of this item when it is rotated.</summary>
		/// <returns type="MindFusion.Drawing.Rect">that bounds the rotated shape of the item.</returns>
	},
	getRotationAngle: function() {
		/// <summary>Gets the angle at which this node is rotated.</summary>
		/// <returns type="Number">A Number specifying the rotation angle. The default is 0.</returns>
	},
	getShowDeleteButton: function() {
		/// <summary>Gets a value indicating whether this node displays a delete button.</summary>
		/// <returns type="Boolean">true to display delete button for the node, or false otherwise.</returns>
	},
	getTopLevel: function() {
		/// <summary>DiagramItem.getTopLevel override.</summary>
		/// <returns type="Boolean"></returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramItem.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	raiseClicked: function(mousePosition, mouseButton) {
		/// <summary>Raises an event which notifies that a node has been clicked.</summary>
		/// <param name="mousePosition" type="MindFusion.Drawing.Point">The position of the mouse.</param>
		/// <param name="mouseButton" type="MouseButton">A value identifying the clicked mouse button.</param>
	},
	raiseDoubleClicked: function(mousePosition, mouseButton) {
		/// <summary>Raises an event which notifies that a node has been double-clicked.</summary>
		/// <param name="mousePosition" type="MindFusion.Drawing.Point">The position of the mouse.</param>
		/// <param name="mouseButton" type="MouseButton">A value identifying the clicked mouse button.</param>
	},
	removeCanvasElements: function() {
		/// <summary>DiagramItem.removeCanvasElements override.</summary>
	},
	restoreLocationState: function(ist) {
		/// <summary>DiagramItem.restoreLocationState override.</summary>
		/// <param name="ist" type="DiagramNodeState">A DiagramNodeState instance.</param>
	},
	saveLocationState: function() {
		/// <summary>DiagramItem.saveLocationState override.</summary>
		/// <returns type="DiagramNodeState">A DiagramNodeState instance.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the item content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setAllowIncomingLinks: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to draw incoming links to this node.</summary>
		/// <param name="value" type="Boolean">true to let users draw incoming links to this node; otherwise, false. The default is true.</param>
	},
	setAllowOutgoingLinks: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to draw outgoing links from this node.</summary>
		/// <param name="value" type="Boolean">true to let users draw outgoing links to this node; otherwise, false. The default is true.</param>
	},
	setAnchorPattern: function(value) {
		/// <summary>Sets the anchor points to which links are attached when connected to the node.</summary>
		/// <param name="value" type="MindFusion.Diagramming.AnchorPattern">An AnchorPattern object that definesthe anchor points for this node.</param>
	},
	setBounds: function(bounds, updateDependencies) {
		/// <summary>Sets the rectangle that defines the position of the diagram node.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect">The node's bounding rectangle.</param>
		/// <param name="updateDependencies" type="Boolean" optional="true">Optional. true if links and attachments must be updated too, or false otherwise.</param>
	},
	setEnabledHandles: function(value) {
		/// <summary>Sets the kinds of modifications that end-users are permitted to perform on the node.</summary>
		/// <param name="value" type="MindFusion.Diagramming.AdjustmentHandles">A combination of the AdjustmentHandles enumeration members. The default is AdjustmentHandles.All.</param>
	},
	setExpandable: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to expand or collapse the tree branch that starts at this node.</summary>
		/// <param name="value" type="Boolean">true to display expand/collapse button beside the node, otherwise false.</param>
	},
	setExpanded: function(value) {
		/// <summary>Expands or collapses the tree branch that starts at this node.</summary>
		/// <param name="value" type="Boolean">true if the branch starting at this node should be expanded; otherwise, false.</param>
	},
	setHandlesStyle: function(value) {
		/// <summary>Sets a value indicating how the node adjustment handles behave and what do they look like.</summary>
		/// <param name="value" type="MindFusion.Diagramming.HandlesStyle">A member of the HandlesStyle enumeration.</param>
	},
	setObstacle: function(value) {
		/// <summary>Sets a value indicating whether this node is considered an obstacle by the link-routing algorithm.</summary>
		/// <param name="value" type="Boolean">true makes routed links look for a path going around this node; false lets links cross the node. The default value is true.</param>
	},
	setRotationAngle: function(value) {
		/// <summary>Sets the angle at which this node is rotated.</summary>
		/// <param name="value" type="Number">A Number specifying the rotation angle. The default is 0.</param>
	},
	setShowDeleteButton: function(value) {
		/// <summary>Sets a value indicating whether this node displays a delete button.</summary>
		/// <param name="value" type="Boolean">true to display delete button for the node, or false otherwise.</param>
	},
	updateDrag: function(ist) {
		/// <summary>DiagramItem.updateDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	}
};
MindFusion.Diagramming.DiagramNode.__class = true;

MindFusion.Diagramming.DoNothingBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	},
	setMouseCursor: function(point, startInteraction) {
		/// <summary>BehaviorBase.setMouseCursor override.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point"></param>
		/// <param name="startInteraction" type="Object"></param>
	}
};
MindFusion.Diagramming.DoNothingBehavior.__class = true;

MindFusion.Diagramming.DrawLinksBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.DrawLinksBehavior.__class = true;

MindFusion.Diagramming.DrawNodesBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.DrawNodesBehavior.__class = true;

MindFusion.Diagramming.DummyNode.prototype = {
};
MindFusion.Diagramming.DummyNode.__class = true;

MindFusion.Diagramming.EffectPhase = {
	/// <summary>Specifies the rendering phase during which an effect application is requested.</summary>
	/// <field name="AfterFill">Indicates that the NodeEffect.apply method is invoked after the target node is filled.</field>
	/// <field name="AfterOutline">Indicates that the NodeEffect.apply method is invoked after the target node is stroked.</field>
	/// <field name="BeforeFill">Indicates that the NodeEffect.apply method is invoked before the target node is filled.</field>
	AfterFill: 0,
	AfterOutline: 1,
	BeforeFill: 2
}
MindFusion.Diagramming.EffectPhase.__enum = true;

MindFusion.Diagramming.Events.prototype = {
};
MindFusion.Diagramming.Events.__class = true;


MindFusion.Diagramming.Events.animatedLayoutCompleted = function() {
	/// <summary>Raised when an animated layout completes.</summary>
};


MindFusion.Diagramming.Events.cellTextEdited = function() {
	/// <summary>Raised when the user edits the text of a table cell. The event handlers get a CellEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.clicked = function() {
	/// <summary>Raised when the user clicks the diagram at a point where no items are located. Event handlers get a DiagramEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.containerChildAdded = function() {
	/// <summary>Raised when the user adds a node to a ContainerNode.</summary>
};


MindFusion.Diagramming.Events.containerChildAdding = function() {
	/// <summary>A validation event raised to let you prevent users from adding child nodes to a container.</summary>
};


MindFusion.Diagramming.Events.containerChildRemoved = function() {
	/// <summary>Raised when the user removes a node from a ContainerNode.</summary>
};


MindFusion.Diagramming.Events.containerChildRemoving = function() {
	/// <summary>A validation event raised to let you prevent users from removing child nodes from a container.</summary>
};


MindFusion.Diagramming.Events.containerFolded = function() {
	/// <summary>Raised when the user folds a container by clicking the arrow-up button in the container's caption area.</summary>
};


MindFusion.Diagramming.Events.containerUnfolded = function() {
	/// <summary>Raised when the user unfolds a container by clicking the arrow-down button in the container's caption area.</summary>
};


MindFusion.Diagramming.Events.controlLoaded = function() {
	/// <summary>Raised when the control is loaded.</summary>
};


MindFusion.Diagramming.Events.createEditControl = function() {
	/// <summary>Raised to let you create a custom inplace editor control. Event handlers get an InplaceEditEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.deserializeTag = function() {
	/// <summary>Raised when the Tag or Id of a diagram item must be deserialized from XML format.</summary>
};


MindFusion.Diagramming.Events.drawAdjustmentHandles = function() {
	/// <summary>Raised to draw custom adjustment handles.</summary>
};


MindFusion.Diagramming.Events.enterInplaceEditMode = function() {
	/// <summary>Raised when entering inplace-edit mode. Event handlers get an InplaceEditEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.headerResized = function() {
	/// <summary>Raised when the user finished resizing a header.</summary>
};


MindFusion.Diagramming.Events.headerStartResizing = function() {
	/// <summary>Raised when the user starts resizing a header.</summary>
};


MindFusion.Diagramming.Events.hitTestAdjustmentHandles = function() {
	/// <summary>Raised to hit-test custom adjustment handles.</summary>
};


MindFusion.Diagramming.Events.hyperlinkClicked = function() {
	/// <summary>Raised when the user clicks a hyperlink inside a node. Event handlers receive a NodeEventArgs instance containing data about this event.</summary>
};


MindFusion.Diagramming.Events.initializeLink = function() {
	/// <summary>Raised when the user starts drawing a new link, just after the DiagramLink instance is created.</summary>
};


MindFusion.Diagramming.Events.initializeNode = function() {
	/// <summary>Raised when the user starts drawing a new node, just after the DiagramNode instance is created.</summary>
};


MindFusion.Diagramming.Events.itemAdded = function() {
	/// <summary>Raised when an item is added to the diagram.</summary>
};


MindFusion.Diagramming.Events.itemRemoved = function() {
	/// <summary>Raised when an item is removed from the diagram.</summary>
};


MindFusion.Diagramming.Events.laneGridCellTextEdited = function() {
	/// <summary>Raised when the used edits the text of a grid cell. The event handlers get a CellEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.leaveInplaceEditMode = function() {
	/// <summary>Raised when leaving inplace-edit mode. Event handlers get an InplaceEditEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkClicked = function() {
	/// <summary>Raised when the user clicks a link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkCreated = function() {
	/// <summary>Raised when the user draws a new link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkCreating = function() {
	/// <summary>A validation event raised while the user is drawing a new link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkDeleted = function() {
	/// <summary>Raised when a link is deleted, either programmatically or by the user. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkDeleting = function() {
	/// <summary>Raised when the user tries to delete a link, this event lets you cancel the operation. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkDeselected = function() {
	/// <summary>Raised when a link is deselected, either programmatically or by the user. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkDoubleClicked = function() {
	/// <summary>Raised when the user double-clicks a link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkModified = function() {
	/// <summary>Raised when the user moves any control point of a link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkModifying = function() {
	/// <summary>A validation event raised while the user is modifying a link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkPasted = function() {
	/// <summary>Raised when a link has been pasted from the clipboard.</summary>
};


MindFusion.Diagramming.Events.linkPointed = function() {
	/// <summary>Raised when the mouse pointer hovers over a link. Event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkSelected = function() {
	/// <summary>Raised when a link is selected, either programmatically or by the user. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.linkTextEdited = function() {
	/// <summary>Raised when the user edits the text of a link. The event handlers get a LinkEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeClicked = function() {
	/// <summary>Raised when the user clicks a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeCreated = function() {
	/// <summary>Raised when the user draws a new node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeCreating = function() {
	/// <summary>A validation event raised while the user is drawing a new node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeDeleted = function() {
	/// <summary>Raised when a node is deleted, either programmatically or by the user. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeDeleting = function() {
	/// <summary>Raised when the user tries to delete a node, this event lets you cancel the operation. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeDeselected = function() {
	/// <summary>Raised when a node is deselected, either programmatically or by the user. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeDoubleClicked = function() {
	/// <summary>Raised when the user double-clicks a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeModified = function() {
	/// <summary>Raised when the user moves or resizes a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeModifying = function() {
	/// <summary>A validation event raised while the user is moving or resizing a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodePasted = function() {
	/// <summary>Raised when a node has been pasted from the clipboard.</summary>
};


MindFusion.Diagramming.Events.nodePointed = function() {
	/// <summary>Raised when the mouse pointer hovers over a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeSelected = function() {
	/// <summary>Raised when a node is selected, either programmatically or by the user. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.nodeTextEdited = function() {
	/// <summary>Raised when the user edits the text of a node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.repaint = function() {
	/// <summary>Raised when the diagram has been repainted.</summary>
};


MindFusion.Diagramming.Events.selectionModifying = function() {
	/// <summary>A validation event raised while the user is moving or resizing multiple items. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.serializeTag = function() {
	/// <summary>Raised when the Tag or Id of a diagram item must be serialized in XML format.</summary>
};


MindFusion.Diagramming.Events.sizeChanged = function() {
	/// <summary>Raised when the size of the diagram canvas has changed.</summary>
};


MindFusion.Diagramming.Events.tableColumnResized = function() {
	/// <summary>Raised when the user finishes resizing a column in a table.</summary>
};


MindFusion.Diagramming.Events.tableColumnResizing = function() {
	/// <summary>Raised when the user resizes a column in a table interactively.</summary>
};


MindFusion.Diagramming.Events.tableRowResized = function() {
	/// <summary>Raised when the user finishes resizing a row in a table.</summary>
};


MindFusion.Diagramming.Events.tableRowResizing = function() {
	/// <summary>Raised when the user resizes a row in a table interactively.</summary>
};


MindFusion.Diagramming.Events.treeCollapsed = function() {
	/// <summary>Raised when a user collapses a tree branch by clicking the [-] button of an Expandable node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};


MindFusion.Diagramming.Events.treeExpanded = function() {
	/// <summary>Raised when a user expands a tree branch by clicking the [+] button of an Expandable node. The event handlers get a NodeEventArgs instance that contains data about this event.</summary>
};

MindFusion.Diagramming.Factory.prototype = {
	createContainerNode: function(bounds, x, y, width, height) {
		/// <summary>Creates a new ContainerNode instance and adds it to the nodes collection of the underlying diagram.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. Specifies the bounding rectangle of the new node.</param>
		/// <param name="x" type="Number" optional="true">Optional. The x-coordinate of the upper-left corner of the new node.</param>
		/// <param name="y" type="Number" optional="true">Optional. The y-coordinate of the upper-left corner of the new node.</param>
		/// <param name="width" type="Number" optional="true">Optional. The width of the new node.</param>
		/// <param name="height" type="Number" optional="true">Optional. The height of the new node.</param>
		/// <returns type="MindFusion.Diagramming.ContainerNode">The newly created ContainerNode instance.</returns>
	},
	createDiagramLink: function(origin, destination) {
		/// <summary>Creates a new DiagramLink instance between the specified nodes and adds it to the links collection of the underlying diagram.</summary>
		/// <param name="origin" type="MindFusion.Diagramming.DiagramNode" optional="true">Optional. The origin node.</param>
		/// <param name="destination" type="MindFusion.Diagramming.DiagramNode" optional="true">Optional. The destination node.</param>
		/// <returns type="MindFusion.Diagramming.DiagramLink">The newly created DiagramLink instance.</returns>
	},
	createShapeNode: function(bounds, x, y, width, height) {
		/// <summary>Creates a new ShapeNode instance and adds it to the nodes collection of the underlying diagram.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. Sets the bounds of the shape to create.</param>
		/// <param name="x" type="Number" optional="true">Optional. The x-coordinate of the upper-left corner of the new node.</param>
		/// <param name="y" type="Number" optional="true">Optional. The y-coordinate of the upper-left corner of the new node.</param>
		/// <param name="width" type="Number" optional="true">Optional. The width of the new node.</param>
		/// <param name="height" type="Number" optional="true">Optional. The height of the new node.</param>
		/// <returns type="MindFusion.Diagramming.ShapeNode">The newly created ShapeNode instance.</returns>
	},
	createSvgNode: function(bounds, x, y, width, height) {
		/// <summary>Creates a new SvgNode instance and adds it to the nodes collection of the underlying diagram.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. Sets the bounds of the shape to create.</param>
		/// <param name="x" type="Number" optional="true">Optional. The x-coordinate of the upper-left corner of the new node.</param>
		/// <param name="y" type="Number" optional="true">Optional. The y-coordinate of the upper-left corner of the new node.</param>
		/// <param name="width" type="Number" optional="true">Optional. The width of the new node.</param>
		/// <param name="height" type="Number" optional="true">Optional. The height of the new node.</param>
		/// <returns type="MindFusion.Diagramming.SvgNode">The newly created SvgNode instance.</returns>
	},
	createTableNode: function(bounds, x, y, width, height) {
		/// <summary>Creates a new TableNode instance and adds it to the nodes collection of the underlying diagram.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. Specifies the bounding rectangle of the new node.</param>
		/// <param name="x" type="Number" optional="true">Optional. The x-coordinate of the upper-left corner of the new node.</param>
		/// <param name="y" type="Number" optional="true">Optional. The y-coordinate of the upper-left corner of the new node.</param>
		/// <param name="width" type="Number" optional="true">Optional. The width of the new node.</param>
		/// <param name="height" type="Number" optional="true">Optional. The height of the new node.</param>
		/// <returns type="MindFusion.Diagramming.TableNode">The newly created TableNode instance.</returns>
	}
};
MindFusion.Diagramming.Factory.__class = true;

MindFusion.Diagramming.FitSize = {
	/// <summary>Specifies how the ResizeToFitText method should resize a node.</summary>
	/// <field name="KeepHeight">The original node height should remain intact.</field>
	/// <field name="KeepRatio">Allow changing both the width and height of a node, but keep the original width/height ratio if possible.</field>
	/// <field name="KeepWidth">The original node width should remain intact.</field>
	KeepHeight: 0,
	KeepRatio: 1,
	KeepWidth: 2
}
MindFusion.Diagramming.FitSize.__enum = true;

MindFusion.Diagramming.FoldContainerCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.FoldContainerCommand.__class = true;

MindFusion.Diagramming.FreeFormNode.prototype = {
	containsPoint: function(point) {
		/// <summary>DiagramItem.containsPoint override.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <returns type="Boolean">true it this node contains the specified point; otherwise, false.</returns>
	},
	endDrag: function(ist) {
		/// <summary>DiagramNode.endDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	getClosed: function() {
		/// <summary>Gets if the node's shape is closed.</summary>
		/// <returns type="Boolean">true it this node has a closed shape, or false otherwise.</returns>
	},
	getOutline: function() {
		/// <summary>Gets the outline of this node.</summary>
		/// <returns type="Array">An array of points.</returns>
	},
	getPoints: function() {
		/// <summary>Gets the node's outline points.</summary>
		/// <returns type="Array">An array of MindFusion.Drawing.Point objects.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this FreeFormNode instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramNode.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	restoreLocationState: function(ist) {
		/// <summary>DiagramNode.restoreLocationState override.</summary>
		/// <param name="ist" type="DiagramNodeState">A DiagramNodeState instance.</param>
	},
	saveLocationState: function() {
		/// <summary>DiagramNode.saveLocationState override.</summary>
		/// <returns type="DiagramNodeState">A DiagramNodeState instance.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the node's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setClosed: function(value) {
		/// <summary>Sets if the node's shape is closed.</summary>
		/// <param name="value" type="Boolean">true it this node has a closed shape, or false otherwise.</param>
	},
	setPoints: function(value) {
		/// <summary>Sets the node's outline points.</summary>
		/// <param name="value" type="Array">An array of MindFusion.Drawing.Point objects.</param>
	},
	startDrag: function(ist) {
		/// <summary>DiagramNode.startDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	updateDrag: function(ist) {
		/// <summary>DiagramNode.updateDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	updateFromPoints: function(relations, path) {
		/// <summary>Updates the node's internal state after its points have changed.</summary>
		/// <param name="relations" type="void"></param>
		/// <param name="path" type="void"></param>
	},
};
MindFusion.Diagramming.FreeFormNode.__class = true;

MindFusion.Diagramming.FreeFormNode.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new FreeFormNode instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.getImage.prototype = {
};
MindFusion.Diagramming.getImage.__class = true;

MindFusion.Diagramming.getImageAlign.prototype = {
};
MindFusion.Diagramming.getImageAlign.__class = true;

MindFusion.Diagramming.getImageContent.prototype = {
};
MindFusion.Diagramming.getImageContent.__class = true;

MindFusion.Diagramming.getImageLocation.prototype = {
};
MindFusion.Diagramming.getImageLocation.__class = true;

MindFusion.Diagramming.getImagePadding.prototype = {
};
MindFusion.Diagramming.getImagePadding.__class = true;

MindFusion.Diagramming.getLineAlignment.prototype = {
};
MindFusion.Diagramming.getLineAlignment.__class = true;

MindFusion.Diagramming.getText.prototype = {
};
MindFusion.Diagramming.getText.__class = true;

MindFusion.Diagramming.getTextAlignment.prototype = {
};
MindFusion.Diagramming.getTextAlignment.__class = true;

MindFusion.Diagramming.GlassEffect.prototype = {
	getGlowColor: function() {
		/// <summary>Gets the color of the glow portion of the effect.</summary>
		/// <returns type="String">A string specifying the color name or hexadecimal value. The default value is "white".</returns>
	},
	getReflectionColor: function() {
		/// <summary>Gets the color of the reflection portion of the effect.</summary>
		/// <returns type="String">A string specifying the color name or hexadecimal value. The default value is "white".</returns>
	},
	getType: function() {
		/// <summary>Gets the type of the glass effect.</summary>
		/// <returns type="MindFusion.Diagramming.GlassEffectType">A member of the GlassEffectType enumeration. The default is Type1.</returns>
	},
	getUsePenAsGlow: function() {
		/// <summary>Gets a value indicating whether the glow portion of the effect should be painted with the stroke color of the respective node.</summary>
		/// <returns type="Boolean">true to ignore GlowColor and use the node's stroke color for the effect glow; otherwise, false.</returns>
	},
	setGlowColor: function(value) {
		/// <summary>Sets the color of the glow portion of the effect.</summary>
		/// <param name="value" type="String">A string specifying the color name or hexadecimal value. The default value is "white".</param>
	},
	setReflectionColor: function(value) {
		/// <summary>Sets the color of the reflection portion of the effect.</summary>
		/// <param name="value" type="String">A string specifying the color name or hexadecimal value. The default value is "white".</param>
	},
	setType: function(value) {
		/// <summary>Sets the type of the glass effect.</summary>
		/// <param name="value" type="MindFusion.Diagramming.GlassEffectType">A member of the GlassEffectType enumeration. The default is Type1.</param>
	},
	setUsePenAsGlow: function(value) {
		/// <summary>Sets a value indicating whether the glow portion of the effect should be painted with the stroke color of the respective node.</summary>
		/// <param name="value" type="Boolean">true to ignore GlowColor and use the node's stroke color for the effect glow; otherwise, false.</param>
	}
};
MindFusion.Diagramming.GlassEffect.__class = true;

MindFusion.Diagramming.GlassEffectType = {
	/// <summary>Specifies the type of a GlassEffect node effect.</summary>
	/// <field name="Type1">Indicates a glass effect with soft radial glow at the bottom and a sharp reflection at the top.</field>
	/// <field name="Type2">Indicates a glass effect with linear glow at the bottom and sharp reflection at the top.</field>
	/// <field name="Type3">Indicates a glass effect with radial glow at the bottom and smooth reflection and emphasized outline at the top.</field>
	/// <field name="Type4">Indicates a glass effect with sharp reflection at the top and soft glow at the left and right sides.</field>
	Type1: 0,
	Type2: 1,
	Type3: 2,
	Type4: 3
}
MindFusion.Diagramming.GlassEffectType.__enum = true;

MindFusion.Diagramming.GridColumn.prototype = {
	getLengthType: function() {
		/// <summary>Gets how GridPanel determines the width of this column.</summary>
		/// <returns type="MindFusion.Diagramming.LengthType">A member of the LengthType enumeration.</returns>
	},
	getWidth: function() {
		/// <summary>Gets fixed width for this column.</summary>
		/// <returns type="Number">A number specifying the column's width.</returns>
	},
	setLengthType: function(value) {
		/// <summary>Sets how GridPanel determines the width of this column.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LengthType">A member of the LengthType enumeration.</param>
	},
	setWidth: function(value) {
		/// <summary>Sets fixed width for this column.</summary>
		/// <param name="value" type="Number">A number specifying the column's width.</param>
	}
};
MindFusion.Diagramming.GridColumn.__class = true;

MindFusion.Diagramming.GridPanel.prototype = {
	getColumns: function() {
		/// <summary>Gets a list of GridColumn objects specifying column attributes.</summary>
		/// <returns type="Array">An array containing the grid columns.</returns>
	},
	getRows: function() {
		/// <summary>Gets a list of GridRow objects specifying row attributes.</summary>
		/// <returns type="Array">An array containing the grid rows.</returns>
	}
};
MindFusion.Diagramming.GridPanel.__class = true;

MindFusion.Diagramming.GridRouter.prototype = {
	getCrossingCost: function() {
		/// <summary>Gets a value added to the total cost of a route which causes a link to cross another link.</summary>
		/// <returns type="Number">A number specifying the crossing cost. The default is 4.</returns>
	},
	getGridSize: function() {
		/// <summary>Gets the size of the pieces of the routing grid.</summary>
		/// <returns type="Number">A number specifying the size of the pieces of the routing grid. The default is 4.</returns>
	},
	getLengthCost: function() {
		/// <summary>Gets a value added to the total cost of a route for each piece of the routing grid occupied by the route.</summary>
		/// <returns type="Number">A number specifying the length cost. The default is 2.</returns>
	},
	getNodeVicinityCost: function() {
		/// <summary>Gets a value added to the total cost of a route if the route passes too close to a node.</summary>
		/// <returns type="Number">A number specifying the node vicinity cost. The default is 2.</returns>
	},
	getNodeVicinitySize: function() {
		/// <summary>Gets the size of a buffer zone around a node for which routes get a penalty cost if they pass through it.</summary>
		/// <returns type="Number">A number specifying the size of the buffer area in which passing routes receive a penalty cost. The default is 12.</returns>
	},
	getTurnCost: function() {
		/// <summary>Gets a value added to the total cost of a route if the route passes too close to a node.</summary>
		/// <returns type="Number">A number specifying the node vicinity cost. The default is 2.</returns>
	},
	setCrossingCost: function(value) {
		/// <summary>Sets a value added to the total cost of a route which causes a link to cross another link.</summary>
		/// <param name="value" type="Number">A number specifying the crossing cost. The default is 4.</param>
	},
	setGridSize: function(value) {
		/// <summary>Sets the size of the pieces of the routing grid.</summary>
		/// <param name="value" type="Number">A number specifying the size of the pieces of the routing grid. The default is 4.</param>
	},
	setLengthCost: function(value) {
		/// <summary>Sets a value added to the total cost of a route for each piece of the routing grid occupied by the route.</summary>
		/// <param name="value" type="Number">A number specifying the length cost. The default is 2.</param>
	},
	setNodeVicinityCost: function(value) {
		/// <summary>Sets a value added to the total cost of a route if the route passes too close to a node.</summary>
		/// <param name="value" type="Number">A number specifying the node vicinity cost. The default is 2.</param>
	},
	setNodeVicinitySize: function(value) {
		/// <summary>Sets the size of a buffer zone around a node for which routes get a penalty cost if they pass through it.</summary>
		/// <param name="value" type="Number">A number specifying the size of the buffer area in which passing routes receive a penalty cost. The default is 12.</param>
	},
	setTurnCost: function(value) {
		/// <summary>Sets a value added to the total cost of a route if the route passes too close to a node.</summary>
		/// <param name="value" type="Number">A number specifying the node vicinity cost. The default is 2.</param>
	}
};
MindFusion.Diagramming.GridRouter.__class = true;

MindFusion.Diagramming.GridRow.prototype = {
	getHeight: function() {
		/// <summary>Gets fixed height for this row.</summary>
		/// <returns type="Number">A number specifying the rows's height.</returns>
	},
	getLengthType: function() {
		/// <summary>Gets how GridPanel determines the height of this row.</summary>
		/// <returns type="MindFusion.Diagramming.LengthType">A member of the LengthType enumeration.</returns>
	},
	setHeight: function(value) {
		/// <summary>Sets fixed height for this row.</summary>
		/// <param name="value" type="Number">A number specifying the rows's height.</param>
	},
	setLengthType: function(value) {
		/// <summary>Sets how GridPanel determines the height of this row.</summary>
		/// <param name="value" type="MindFusion.Diagramming.LengthType">A member of the LengthType enumeration.</param>
	}
};
MindFusion.Diagramming.GridRow.__class = true;

MindFusion.Diagramming.GridStyle = {
	/// <summary>Defines values that specify the visual style of the alignment grid.</summary>
	/// <field name="Crosses">The grid is painted as a matrix of crosses.</field>
	/// <field name="Lines">The grid is represented as a series of crossing horizontal and vertical lines.</field>
	/// <field name="Points">The grid is painted as a matrix of points.</field>
	Crosses: 0,
	Lines: 1,
	Points: 2
}
MindFusion.Diagramming.GridStyle.__enum = true;

MindFusion.Diagramming.HandlesStyle = {
	/// <summary>Enumerates possible visual styles for frames and handles drawn around selected nodes.</summary>
	/// <field name="Custom">The control raises the drawAdjustmentHandles and hitTestAdjustmentHandles events to let your application perform custom drawing and hit testing of selection handles.</field>
	/// <field name="DashFrame">If selected, a node is drawn with a dashed frame. The frame enables resizing the node. The center of the node allows moving it and the edge area enables creating links.</field>
	/// <field name="EasyMove">Any point of the interior of a node enables moving the node, except a small area in the center that allows creating links. Best used with ModificationStart set to AutoHandles.</field>
	/// <field name="HatchFrame">If selected, the item is drawn with hatched frame. Modifications can be done as with DashFrame.</field>
	/// <field name="HatchHandles">If selected, a node is drawn with both hatched frame and modification handles. The frame enable moving the node, and the handles enable resizing. Links are created from any point of the interior.</field>
	/// <field name="HatchHandles2">Looks like HatchHandles, but allows moving the node from the interior area. Links are created from the points near the edge.</field>
	/// <field name="HatchHandles3">Behaves like HatchHandles2, but paints the selection frame using a denser brush pattern.</field>
	/// <field name="Invisible">There is no visible difference between selected and unselected node.</field>
	/// <field name="InvisibleMove">There aren't any selection handles displayed. The selected node can be only moved, but not resized.</field>
	/// <field name="MoveOnly">If a node is selected, it can be only moved. Best used with ModificationStart set to AutoHandles.</field>
	/// <field name="RoundAndSquare">Corner resize handles are round, remaining handles are square.</field>
	/// <field name="RoundAndSquare2">Corner resize handles are round, remaining handles are square. In addition, there is a dashed frame drawn around selected nodes.</field>
	/// <field name="SquareHandles">If selected, the node is drawn with square modification handles.</field>
	/// <field name="SquareHandles2">Square resize handles are drawn around a selected node. There isn't a move handle in the center as with the SquareHandles style, but nodes can be moved by dragging their interior or caption areas. Links can be created by drawing from near the edges of a node.</field>
	Custom: 0,
	DashFrame: 1,
	EasyMove: 2,
	HatchFrame: 3,
	HatchHandles: 4,
	HatchHandles2: 5,
	HatchHandles3: 6,
	Invisible: 7,
	InvisibleMove: 8,
	MoveOnly: 9,
	RoundAndSquare: 10,
	RoundAndSquare2: 11,
	SquareHandles: 12,
	SquareHandles2: 13
}
MindFusion.Diagramming.HandlesStyle.__enum = true;

MindFusion.Diagramming.HeaderEventArgs.prototype = {
	getHeader: function() {
		/// <summary>Gets the header related to the event.</summary>
	}
};
MindFusion.Diagramming.HeaderEventArgs.__class = true;

MindFusion.Diagramming.HeaderResizeEventArgs.prototype = {
	cancelDrag: function() {
		/// <summary>Immediately cancels the resize.</summary>
	},
	getCancel: function() {
		/// <summary>Gets a value indicating whether to allow the current operation.</summary>
		/// <returns type="Boolean">true to cancel the operation; otherwise, false.</returns>
	},
	getHorizontal: function() {
		/// <summary>Gets a value indicating whether the user resizes the header horizontally.</summary>
	},
	setCancel: function(value) {
		/// <summary>Sets a value indicating whether to allow the current operation.</summary>
		/// <param name="value" type="Boolean">true to cancel the operation; otherwise, false.</param>
	}
};
MindFusion.Diagramming.HeaderResizeEventArgs.__class = true;

MindFusion.Diagramming.InplaceEditEventArgs.prototype = {
	getBounds: function() {
		/// <summary>Gets the bounds of the item being edited.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance</returns>
	},
	getControl: function() {
		/// <summary>Gets the control used to edit the item's text.</summary>
		/// <returns type="Element">Html DOM element to use as editor.</returns>
	},
	getItem: function() {
		/// <summary>Gets a reference to the item being edited.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramItem">A DiagramItem instance.</returns>
	},
	setControl: function(value) {
		/// <summary>Sets the control used to edit the item's text.</summary>
		/// <param name="value" type="Element">Html DOM element to use as editor.</param>
	}
};
MindFusion.Diagramming.InplaceEditEventArgs.__class = true;

MindFusion.Diagramming.items.prototype = {
};
MindFusion.Diagramming.items.__class = true;

MindFusion.Diagramming.LengthType = {
	/// <summary>Indicates how GridPanel determines dimensions of its rows and columns.</summary>
	/// <field name="Auto">The row or column is auto-sized to fit its child components.</field>
	/// <field name="Relative">The size of relative elements is calculated from available space in the GridPanel proportionally to the number of other relative elements.</field>
	Auto: 0,
	Relative: 1
}
MindFusion.Diagramming.LengthType.__enum = true;

MindFusion.Diagramming.LinkCrossings = {
	/// <summary>Defines values that indicate how to render link intersection points.</summary>
	/// <field name="Arcs">An arc is drawn at the intersection point of two links. It connects the segments of the link at higher Z position and goes over the link at lower Z.</field>
	/// <field name="Cut">The intersection segments of links at lower Z position are cut by links at higher Z position.</field>
	/// <field name="Straight">No special indication for link intersection points.</field>
	Arcs: 0,
	Cut: 1,
	Straight: 2
}
MindFusion.Diagramming.LinkCrossings.__enum = true;

MindFusion.Diagramming.LinkEventArgs.prototype = {
	getLabel: function() {
		/// <summary>Gets the link label for which the event was raised.</summary>
		/// <returns type="MindFusion.Diagramming.LinkLabel">A LinkLabel instance.</returns>
	},
	getLink: function() {
		/// <summary>Gets the link for which the event was raised.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramLink">A DiagramLink instance.</returns>
	}
};
MindFusion.Diagramming.LinkEventArgs.__class = true;

MindFusion.Diagramming.LinkLabel.prototype = {
	getAutoArrange: function() {
		/// <summary>Gets a value indicating whether the label can be auto arranged.</summary>
		/// <returns type="Boolean">True if the label can be auto arranged, otherwise false.</returns>
	},
	getBrush: function() {
		/// <summary>Gets the brush used to draw the label's background.</summary>
		/// <returns type="Object">An object specifying the label's background.</returns>
	},
	getFont: function() {
		/// <summary>Gets the font used to render this label's text.</summary>
		/// <returns type="MindFusion.Drawing.Font">A Font instance.</returns>
	},
	getHorizontalAlign: function() {
		/// <summary>Gets the label's horizontal alignment.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	getMargin: function() {
		/// <summary>Gets the label's margin.</summary>
		/// <returns type="MindFusion.Drawing.Thickness">A Thickness instance specifying the size of margin on all sides of label.</returns>
	},
	getText: function() {
		/// <summary>Gets the label's text.</summary>
		/// <returns type="String">The text.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets a string specifying the color of this label's text.</summary>
		/// <returns type="String">A string value identifying the color of the text.</returns>
	},
	getVerticalAlign: function() {
		/// <summary>Gets the label's vertical alignment.</summary>
		/// <returns type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</returns>
	},
	setAutoArrange: function(value) {
		/// <summary>Sets a value indicating whether the label can be auto arranged.</summary>
		/// <param name="value" type="Boolean">True if the label can be auto arranged, otherwise false.</param>
	},
	setBrush: function(value) {
		/// <summary>Sets the brush used to draw the label's background.</summary>
		/// <param name="value" type="Object">A Brush object specifying the label's background.</param>
	},
	setControlPointPosition: function(controlPoint, dx, dy) {
		/// <summary>Positions this label relatively to the specified control point.</summary>
		/// <param name="controlPoint" type="Number">The control point index.</param>
		/// <param name="dx" type="Number">Horizontal offset from the control point.</param>
		/// <param name="dy" type="Number">Vertical offset from the control point.</param>
	},
	setFont: function(value) {
		/// <summary>Sets the font used to render this label's text.</summary>
		/// <param name="value" type="MindFusion.Drawing.Font">A Font instance.</param>
	},
	setHorizontalAlign: function(value) {
		/// <summary>Sets the label's horizontal alignment.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	},
	setLinkLengthPosition: function(lengthFactor) {
		/// <summary>Positions this label relatively to the link length.</summary>
		/// <param name="lengthFactor" type="Number">A value between 0 and 1 specifying the position of the label relatively to the link's length.</param>
	},
	setMargin: function(value) {
		/// <summary>Sets the label's margin.</summary>
		/// <param name="value" type="MindFusion.Drawing.Thickness">A Thickness instance specifying the size of margin on all sides of label.</param>
	},
	setSegmentPosition: function(segment, dx, dy) {
		/// <summary>Positions this label relatively to the specified link segment.</summary>
		/// <param name="segment" type="Number">The segment index.</param>
		/// <param name="dx" type="Number">Horizontal offset from the segment center.</param>
		/// <param name="dy" type="Number">Vertical offset from the segment center.</param>
	},
	setText: function(value) {
		/// <summary>Sets the label's text.</summary>
		/// <param name="value" type="String">The text.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets a string specifying the color of this label's text.</summary>
		/// <param name="value" type="String">A string value identifying the color of the text.</param>
	},
	setVerticalAlign: function(value) {
		/// <summary>Sets the label's vertical alignment.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Alignment">One of the Alignment enumeration values.</param>
	}
};
MindFusion.Diagramming.LinkLabel.__class = true;

MindFusion.Diagramming.LinkNodesBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.LinkNodesBehavior.__class = true;

MindFusion.Diagramming.links.prototype = {
};
MindFusion.Diagramming.links.__class = true;

MindFusion.Diagramming.LinkShape = {
	/// <summary>Specifies available styles for the segments of links.</summary>
	/// <field name="Bezier">The segments of a link are Bzier curves.</field>
	/// <field name="Cascading">The segments of a link are alternating horizontal and vertical lines, orthogonal to each other.</field>
	/// <field name="Polyline">The segments of a link are straight lines.</field>
	/// <field name="Spline">The segments of a link are curves forming an interpolating spline that passes through all control points.</field>
	Bezier: 0,
	Cascading: 1,
	Polyline: 2,
	Spline: 3
}
MindFusion.Diagramming.LinkShape.__enum = true;

MindFusion.Diagramming.LinkTextStyle = {
	/// <summary>Specifies the position and alignment of links' labels.</summary>
	/// <field name="Center">The text is displayed horizontally above the middle link segment or control point, depending on whetherthere are an odd or even number of segments.</field>
	/// <field name="Follow">The label text starts from the first point of the link and follows the path defined by the link segments.This style is useful for displaying long text.</field>
	/// <field name="MiddleSegment">The text is displayed horizontally above the middle link segment.If there are an even number of segments, the label is drawn over the longer from the two segments adjacent to the middle control point.</field>
	/// <field name="MiddleSegmentRotated">The text is displayed rotated at the same angle as the segment where the text is placed. A long enough segmentfrom the middle link segments is chosen for that purpose.</field>
	/// <field name="OverLongestSegment">The text follows the longest link segment and is displayed centered at the segment's middle point.</field>
	/// <field name="Rotate">The text is displayed rotated at the same angle as the segment where the text is placed. A long enough segmentfrom the middle link segments is chosen for that purpose.</field>
	Center: 0,
	Follow: 1,
	MiddleSegment: 2,
	MiddleSegmentRotated: 3,
	OverLongestSegment: 4,
	Rotate: 5
}
MindFusion.Diagramming.LinkTextStyle.__enum = true;

MindFusion.Diagramming.MagnifyBehavior.prototype = {
	onMouseDown: function(e) {
		/// <summary>BehaviorBase.onMouseDown override.</summary>
		/// <param name="e" type="MouseButtonEventArgs">A MouseButtonEventArgs that contains the event data.</param>
	},
	onMouseMove: function(e) {
		/// <summary>BehaviorBase.onMouseMove override.</summary>
		/// <param name="e" type="MouseEventArgs">A MouseEventArgs that contains the event data.</param>
	},
	onMouseUp: function(e) {
		/// <summary>BehaviorBase.onMouseUp override.</summary>
		/// <param name="e" type="MouseButtonEventArgs">A MouseButtonEventArgs that contains the event data.</param>
	}
};
MindFusion.Diagramming.MagnifyBehavior.__class = true;

MindFusion.Diagramming.Manipulator.prototype = {
};
MindFusion.Diagramming.Manipulator.__class = true;

MindFusion.Diagramming.MarkStyle = {
	/// <summary>Specifies the visual style of anchor point marks.</summary>
	/// <field name="Circle">Anchor point marked with a circle.</field>
	/// <field name="Cross">Anchor point marked with a cross.</field>
	/// <field name="None">No visual indication for the anchor point.</field>
	/// <field name="Rectangle">Anchor point marked with a rectangle.</field>
	/// <field name="X">Anchor point marked with an 'X'.</field>
	Circle: 0,
	Cross: 1,
	None: 2,
	Rectangle: 3,
	X: 4
}
MindFusion.Diagramming.MarkStyle.__enum = true;

MindFusion.Diagramming.ModificationStart = {
	/// <summary>Specifies how the user can start modifying an item.</summary>
	/// <field name="AutoHandles">Adjustment handles appear automatically around the object under the mouse; it can be modified without selecting it first.</field>
	/// <field name="SelectedOnly">Only selected objects can be modified.</field>
	AutoHandles: 0,
	SelectedOnly: 1
}
MindFusion.Diagramming.ModificationStart.__enum = true;

MindFusion.Diagramming.ModifierKeyAction = {
	/// <summary>Defines the actions that can be assigned to a modifier key such as CTRL or ALT.</summary>
	/// <field name="Magnify">Magnifies the diagram objects under the mouse while the modifier key is pressed down.</field>
	/// <field name="None">Specifies that a modifier key does not have any specific function assigned to it.</field>
	/// <field name="OverrideBehavior">While the modifier key is pressed down, dragging the mouse starts creating a new item or drawing a selection rectangle instead of modifying a selected item. Otherwise, dragging the mouse could start modification of the selected item.</field>
	/// <field name="Pan">Pan the view if the mouse is dragged while the modifier key is pressed down.</field>
	/// <field name="Select">Start drawing a selection rectangle if the mouse is dragged while a modifier key is pressed down. Toggle the selection if an item is clicked while the key is down.</field>
	Magnify: 0,
	None: 1,
	OverrideBehavior: 2,
	Pan: 3,
	Select: 4
}
MindFusion.Diagramming.ModifierKeyAction.__enum = true;

MindFusion.Diagramming.ModifierKeyActions.prototype = {
	getAlt: function() {
		/// <summary>Gets the action triggered by the ALT key.</summary>
		/// <returns type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</returns>
	},
	getControl: function() {
		/// <summary>Gets the action triggered by the CTRL key.</summary>
		/// <returns type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</returns>
	},
	getShift: function() {
		/// <summary>Gets the action triggered by the SHIFT key.</summary>
		/// <returns type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</returns>
	},
	setAlt: function(value) {
		/// <summary>Sets the action triggered by the ALT key.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</param>
	},
	setControl: function(value) {
		/// <summary>Sets the action triggered by the CTRL key.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</param>
	},
	setShift: function(value) {
		/// <summary>Sets the action triggered by the SHIFT key.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ModifierKeyAction">A member of the ModifierKeyAction enumeration.</param>
	}
};
MindFusion.Diagramming.ModifierKeyActions.__class = true;

MindFusion.Diagramming.ModifyBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.ModifyBehavior.__class = true;

MindFusion.Diagramming.ModifyLinkController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>SinglePointerController.validate override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.ModifyLinkController.__class = true;

MindFusion.Diagramming.ModifyNodeController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>SinglePointerController.validate override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.ModifyNodeController.__class = true;

MindFusion.Diagramming.ModifySelectionController.prototype = {
	commit: function(position) {
		/// <summary>SinglePointerController.commit override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>SinglePointerController.validate override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.ModifySelectionController.__class = true;

MindFusion.Diagramming.MouseButtonActions = {
	/// <summary>Specifies what actions can be associated with the middle and right mouse buttons.</summary>
	/// <field name="Cancel">Cancels the current drawing operation.</field>
	/// <field name="Draw">Draw new items or modify existing items.</field>
	/// <field name="Magnify">Magnifies the items under the mouse while the button is pressed down.</field>
	/// <field name="None">Do not associate any action with the button.</field>
	/// <field name="Pan">Pans the view if the mouse is dragged while the button is pressed down.</field>
	/// <field name="Select">Starts a multiple selection operation.</field>
	Cancel: 0,
	Draw: 1,
	Magnify: 2,
	None: 3,
	Pan: 4,
	Select: 5
}
MindFusion.Diagramming.MouseButtonActions.__enum = true;

MindFusion.Diagramming.MouseInputDispatcher.prototype = {
	onMouseDown: function(position, button) {
		/// <summary>Called when the user presses down a mouse button.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <param name="button" type="Number">0 for left button, 1 for middle button, 2 for right button.</param>
	},
	onMouseMove: function(position) {
		/// <summary>Called when the user moves the mouse.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	onMouseUp: function(position, button) {
		/// <summary>Called when the user releases a mouse button.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <param name="button" type="Number">0 for left button, 1 for middle button, 2 for right button.</param>
	}
};
MindFusion.Diagramming.MouseInputDispatcher.__class = true;

MindFusion.Diagramming.NodeEventArgs.prototype = {
	getContainer: function() {
		/// <summary>Gets the container a node has been added to or removed from.</summary>
		/// <returns type="MindFusion.Diagramming.ContainerNode">A ContainerNode instance.</returns>
	},
	getHyperlink: function() {
		/// <summary>Gets the hyperlink that was clicked inside a node.</summary>
		/// <returns type="String">The hyperlink that was clicked.</returns>
	},
	getNode: function() {
		/// <summary>Gets the node for which the event was raised.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramNode">An instance of the DiagramNode class.</returns>
	}
};
MindFusion.Diagramming.NodeEventArgs.__class = true;

MindFusion.Diagramming.NodeListView.prototype = {
	addEventListener: function(eventName, handler) {
		/// <summary>Registers a single event listener on the NodeListView.</summary>
		/// <param name="eventName" type="String">The name of the event. Currently supported events are controlLoaded and nodeSelected.</param>
		/// <param name="handler" type="Method">Represents the method that will handle the event specified with eventName.</param>
	},
	addNode: function(node, caption) {
		/// <summary>Adds a node to the NodeListView.</summary>
		/// <param name="node" type="MindFusion.Diagramming.DiagramNode">The node to add.</param>
		/// <param name="caption" type="String" optional="true">Optional. The caption to display for the node.</param>
	},
	clearAll: function() {
		/// <summary>Removes all items from the NodeListView.</summary>
	},
	getDefaultNodeSize: function() {
		/// <summary>Gets the default size of the nodes in the list view.</summary>
		/// <returns type="MindFusion.Drawing.Size">The size.</returns>
	},
	getDraggedNode: function() {
		/// <summary>Gets the currently dragged from the node list diagram node.</summary>
		/// <returns type="DiagramNode">The dragged diagram node.</returns>
	},
	getEnabled: function() {
		/// <summary>Checks if mouse events are enabled.</summary>
		/// <returns type="Boolean">true if handling of mouse events is enabled; otherwise, false.</returns>
	},
	getIconSize: function() {
		/// <summary>Gets the default size of the nodes in the list view.</summary>
		/// <returns type="MindFusion.Drawing.Size">The size.</returns>
	},
	getNodeAt: function(point) {
		/// <summary>Gets the item at the specified location.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The location where to look.</param>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The item found.</returns>
	},
	getNodes: function() {
		/// <summary>Gets the nodes contained in this NodeListView.</summary>
		/// <returns type="Array">An array of all DiagramNodes in this NodeListView.</returns>
	},
	getOrientation: function() {
		/// <summary>Gets the orientation of the nodes' layout.</summary>
		/// <returns type="MindFusion.Diagramming.Orientation">The orientation.</returns>
	},
	getPadding: function() {
		/// <summary>Gets the space between the NodeListView control and its contents.</summary>
		/// <returns type="Number">A value that specifies the space between the NodeListView control and its contents.</returns>
	},
	getShapeLibraryLocation: function() {
		/// <summary>Gets the location of a shape library file containing custom shape definitions.It can be set to a full URL of the file, or a relative file path.</summary>
		/// <returns type="String">The location of a shape library file containing custom shape definitions.</returns>
	},
	getTooltipDelay: function() {
		/// <summary>Gets the delay before a tooltip is shown.</summary>
		/// <returns type="Number">The tooltip delay in milliseconds.</returns>
	},
	registerForSubmit: function(id) {
		/// <summary>Registers an onsubmit handler for the NodeListView's parent html form to flush postback data.</summary>
		/// <param name="id" type="String">The id of the hidden field to flush the data to.</param>
	},
	selectItem: function(item) {
		/// <summary>Selects the specified item.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramNode">The item to select.</param>
	},
	setDefaultNodeSize: function(value) {
		/// <summary>Sets the default size of the nodes in the list view.</summary>
		/// <param name="value" type="MindFusion.Drawing.Size">The size.</param>
	},
	setEnabled: function(value) {
		/// <summary>Enables or disables handling of mouse events.</summary>
		/// <param name="value" type="Boolean">true if handling of mouse events is enabled; otherwise, false.</param>
	},
	setIconSize: function(value) {
		/// <summary>Sets the default size of the icons in the list view.</summary>
		/// <param name="value" type="MindFusion.Drawing.Size">The size.</param>
	},
	setOrientation: function(value) {
		/// <summary>Sets the orientation of the nodes' layout.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Orientation">The orientation.</param>
	},
	setPadding: function(value) {
		/// <summary>Sets the space between the NodeListView control and its contents.</summary>
		/// <param name="value" type="Number">A value that specifies the space between the NodeListView control and its contents.</param>
	},
	setShapeLibraryLocation: function(value) {
		/// <summary>Sets the location of a shape library file containing custom shape definitions.It can be set to a full URL of the file, or a relative file path.</summary>
		/// <param name="value" type="String">The location of a shape library file containing custom shape definitions.</param>
	},
	setTooltipDelay: function(value) {
		/// <summary>Sets the delay before a tooltip is shown.</summary>
		/// <param name="value" type="Number">The tooltip delay in milliseconds.</param>
	}
};
MindFusion.Diagramming.NodeListView.__class = true;

MindFusion.Diagramming.NodeListView.create = function(element) {
	/// <summary>Creates and initializes a new NodeListView from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the nodeListView should be attached to.</param>
	/// <returns type="MindFusion.Diagramming.NodeListView">A NodeListView object that represents the newly created nodeListView.</returns>
};
MindFusion.Diagramming.NodeListView.find = function(id, parent) {
	/// <summary>Returns the specified NodeListView object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the nodeListView to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the nodeListView to find.</param>
	/// <returns type="MindFusion.Diagramming.NodeListView">A NodeListView object that contains the nodeListView requested by id, if found; otherwise, null.</returns>
};

MindFusion.Diagramming.nodes.prototype = {
};
MindFusion.Diagramming.nodes.__class = true;

MindFusion.Diagramming.Orientation = {
	/// <summary>Specifies the orientation of user interface elements.</summary>
	/// <field name="Auto">Select orientation automatically.</field>
	/// <field name="Horizontal">Specifies horizontal orientation.</field>
	/// <field name="Vertical">Specifies vertical orientation.</field>
	Auto: 0,
	Horizontal: 1,
	Vertical: 2
}
MindFusion.Diagramming.Orientation.__enum = true;

MindFusion.Diagramming.Overview.prototype = {
	getAllowZoom: function() {
		/// <summary>Gets a value indicating whether users are allowed to zoom the diagram by resizing the overview's viewport tracker rectangle.</summary>
		/// <returns type="Boolean">true to let users zoom by resizing the tracker rectangle, or false otherwise.</returns>
	},
	getAutoScrollAmount: function() {
		/// <summary>Gets the amount by which to auto-scroll the view when the mouse leaves the view boundaries while drawing.</summary>
		/// <returns type="Number">A number specifying the amount by which to auto-scroll.</returns>
	},
	getEnabled: function() {
		/// <summary>Checks if mouse events are enabled.</summary>
		/// <returns type="Boolean">true if handling of mouse events is enabled; otherwise, false.</returns>
	},
	getScaleFactor: function() {
		/// <summary>Gets a fixed scale factor to be used when FitAll is disabled.</summary>
		/// <returns type="Number">A float value specifying the scale as percentage of diagram's size.</returns>
	},
	getScaleMode: function() {
		/// <summary>Gets a value indicating whether to fit the whole diagram inside the overview control.</summary>
		/// <returns type="MindFusion.Diagramming.ScaleMode">A member of the ScaleMode enumeration. The default value is FitAll.</returns>
	},
	getScrollX: function() {
		/// <summary>Gets the overview's horizontal scroll position.</summary>
		/// <returns type="Number">A number specifying the horizontal scroll position in the current unit of measure.</returns>
	},
	getScrollY: function() {
		/// <summary>Gets the overview's vertical scroll position.</summary>
		/// <returns type="Number">A number specifying the vertical scroll position in the current unit of measure.</returns>
	},
	getViewport: function() {
		/// <summary>Returns the visible portion of the diagram area.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance specifying the viewport coordinates.</returns>
	},
	registerForSubmit: function(id) {
		/// <summary>Registers an onsubmit handler for the Overview's parent html form to flush postback data.</summary>
		/// <param name="id" type="String">The id of the hidden field to flush the data to.</param>
	},
	setAllowZoom: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to zoom the diagram by resizing the overview's viewport tracker rectangle.</summary>
		/// <param name="value" type="Boolean">true to let users zoom by resizing the tracker rectangle, or false otherwise.</param>
	},
	setAutoScrollAmount: function(value) {
		/// <summary>Sets the amount by which to auto-scroll the view when the mouse leaves the view boundaries while drawing.</summary>
		/// <param name="value" type="Number">A number specifying the amount by which to auto-scroll.</param>
	},
	setDiagram: function(diagram) {
		/// <summary>Sets the Diagram shown by this Overview.</summary>
		/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram shown by the overview.</param>
	},
	setEnabled: function(value) {
		/// <summary>Enables or disables handling of mouse events.</summary>
		/// <param name="value" type="Boolean">true if handling of mouse events is enabled; otherwise, false.</param>
	},
	setScaleFactor: function(value) {
		/// <summary>Sets a fixed scale factor to be used when FitAll is disabled.</summary>
		/// <param name="value" type="Number">A float value specifying the scale as percentage of diagram's size.</param>
	},
	setScaleMode: function(value) {
		/// <summary>Sets a value indicating whether to fit the whole diagram inside the overview control.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ScaleMode">A member of the ScaleMode enumeration. The default value is FitAll.</param>
	}
};
MindFusion.Diagramming.Overview.__class = true;

MindFusion.Diagramming.Overview.create = function(element) {
	/// <summary>Creates and initializes a new Overview from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the overview should be attached to.</param>
	/// <returns type="MindFusion.Diagramming.Overview">A Overview object that represents the newly created overview.</returns>
};
MindFusion.Diagramming.Overview.find = function(id, parent) {
	/// <summary>Returns the specified Overview object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the overview to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the overview to find.</param>
	/// <returns type="MindFusion.Diagramming.Overview">A Overview object that contains the overview requested by id, if found; otherwise, null.</returns>
};

MindFusion.Diagramming.PanBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.PanBehavior.__class = true;

MindFusion.Diagramming.PanController.prototype = {
	move: function(position) {
		/// <summary>SinglePointerController.move override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>SinglePointerController.start override.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	}
};
MindFusion.Diagramming.PanController.__class = true;

MindFusion.Diagramming.Panel.prototype = {
	getComponents: function() {
		/// <summary>Gets the child components of this panel.</summary>
		/// <returns type="Array">An array containing the child components of this panel.</returns>
	}
};
MindFusion.Diagramming.Panel.__class = true;

MindFusion.Diagramming.Path.prototype = {
	getLength: function() {
		/// <summary>Gets the length of the Path expressed as the number of Linksparticipating in it.</summary>
		/// <returns type="Number">An integer value that represents the number of edges (links) in the path.</returns>
	},
	getWeight: function(incNodes, incLinks) {
		/// <summary>Calculates the weight of this Path by accumulating theWeight of all participating Diagram elements.</summary>
		/// <param name="incNodes" type="Boolean" optional="true">Optional. A boolean value, which specifies whether the Weight ofDiagramNode elements should be considered.</param>
		/// <param name="incLinks" type="Boolean" optional="true">Optional. A boolean value, which specifies whether the Weight ofDiagramLink elements should be considered.</param>
		/// <returns type="Number">A double value that represents the total weight of the elementsin this Path according to the incNodes and incLinks parameters.</returns>
	}
};
MindFusion.Diagramming.Path.__class = true;

MindFusion.Diagramming.PathFinder.prototype = {
	findAllCycles: function() {
		/// <summary>Finds all cycles in the underlying diagram.</summary>
		/// <returns type="Array">An array of Path objects; if no cycles are detected, the array is empty.</returns>
	},
	findAllPaths: function(from, to, maxPaths) {
		/// <summary>Finds and returns all paths that exist between two DiagramNode objects.</summary>
		/// <param name="from" type="DiagramNode">The first DiagramNode in the Path.</param>
		/// <param name="to" type="DiagramNode">The last DiagramNode in the Path.</param>
		/// <param name="maxPaths" type="Number" optional="true">Optional. The maximum number of paths to find.</param>
		/// <returns type="Array">An array of Path objects; if no paths are found, the array is empty.</returns>
	},
	findCycle: function(participant) {
		/// <summary>Detects whether the specified DiagramNode participates in a cycle.</summary>
		/// <param name="participant" type="DiagramNode">A DiagramNode element which should participate in the found cycle.</param>
		/// <returns type="MindFusion.Diagramming.Path">A Path instance that represents the found cycle; null if no cycle is detected.</returns>
	},
	findLongestPath: function(from, to) {
		/// <summary>Finds the longest path between the specified DiagramNode objects.</summary>
		/// <param name="from" type="DiagramNode" optional="true">Optional. The first DiagramNode element in the Path.</param>
		/// <param name="to" type="DiagramNode" optional="true">Optional. The last DiagramNode element in the Path.</param>
		/// <returns type="MindFusion.Diagramming.Path">A Path instance that represents the longest path found; null if there is no Path connecting from and to.</returns>
	},
	findShortestPath: function(from, to, useNodeWeights, useLinkWeights) {
		/// <summary>Finds and returns the shortest path between two DiagramNode elements,considering the Weight of the nodes, the Weight of the links or both.</summary>
		/// <param name="from" type="DiagramNode">The first DiagramNode in the Path.</param>
		/// <param name="to" type="DiagramNode">The last DiagramNode in the Path.</param>
		/// <param name="useNodeWeights" type="Boolean" optional="true">Optional. If true, the Path with minimal total weight is found, summing the Weight of nodes in the Path.</param>
		/// <param name="useLinkWeights" type="Boolean" optional="true">Optional. If true, the Path with minimal total weight is found, summing the Weight of links in the Path.</param>
		/// <returns type="MindFusion.Diagramming.Path">A Path instance that represents the shortest Path found or null if there is no Path connecting from and to.</returns>
	}
};
MindFusion.Diagramming.PathFinder.__class = true;

MindFusion.Diagramming.pen.prototype = {
};
MindFusion.Diagramming.pen.__class = true;

MindFusion.Diagramming.preventDefaultTouch.prototype = {
};
MindFusion.Diagramming.preventDefaultTouch.__class = true;

MindFusion.Diagramming.RelativeToLink = {
	/// <summary>Specifies how the link labels are positioned.</summary>
	/// <field name="ControlPoint">The link labels are positioned relative to a specified control point.</field>
	/// <field name="LinkLength">The link labels are positioned relative to the link.</field>
	/// <field name="Segment">The link labels are positioned relative to a specified segment.</field>
	ControlPoint: 0,
	LinkLength: 1,
	Segment: 2
}
MindFusion.Diagramming.RelativeToLink.__enum = true;

MindFusion.Diagramming.RemoveItemCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.RemoveItemCommand.__class = true;

MindFusion.Diagramming.ResizeTableColumnCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.ResizeTableColumnCommand.__class = true;

MindFusion.Diagramming.ResizeTableRowCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.ResizeTableRowCommand.__class = true;

MindFusion.Diagramming.Router.prototype = {
};
MindFusion.Diagramming.Router.__class = true;

MindFusion.Diagramming.Ruler.prototype = {
	getBackColor: function() {
		/// <summary>Gets the background color of the control.</summary>
		/// <returns type="String">A string specifying the ruler's background color.</returns>
	},
	getEnableGuides: function() {
		/// <summary>Gets a value indicating whether the alignment guides are enabled.</summary>
		/// <returns type="Boolean">true to allow aligning diagram items using ruler guides, or false otherwise. The default is true.</returns>
	},
	getForeColor: function() {
		/// <summary>Gets the foreground color of the control.</summary>
		/// <returns type="String">A string specifying the ruler's foreground color.</returns>
	},
	getGuideColor: function() {
		/// <summary>Gets the color of the alignment guide lines.</summary>
		/// <returns type="String">A string specifying color of guide lines.</returns>
	},
	getHorizontalScaleVisible: function() {
		/// <summary>Gets a value iindicating whether the horizontal ruler scale is visible.</summary>
		/// <returns type="Boolean">true to display the horizontal scale, or false otherwise. The default is true.</returns>
	},
	getNegatedX: function() {
		/// <summary>Gets whether the horizontal scale should show negated values, simulating that the coordinate system's X axis grows to the left.</summary>
		/// <returns type="Boolean">true if the horizontal scale should show negated values, or false otherwise. The default value is false.</returns>
	},
	getNegatedY: function() {
		/// <summary>Gets whether the vertical scale should show negated values, simulating that the coordinate system's Y axis grows to the top.</summary>
		/// <returns type="Boolean">true if the vertical scale should show negated values, or false otherwise. The default value is false.</returns>
	},
	getPointerColor: function() {
		/// <summary>Gets the color of the mouse pointer's projections.</summary>
		/// <returns type="String">A string specifying the color of pointer projection lines.</returns>
	},
	getProjectionColor: function() {
		/// <summary>Gets the color used to paint the projection of the active node.</summary>
		/// <returns type="String">A string specifying the projection color.</returns>
	},
	getProjectRotatedBounds: function() {
		/// <summary>Gets whether the projection of nodes on ruler's scales rotates with them.</summary>
		/// <returns type="Boolean">true if node's projection should match the boundaries of rotated node shape, or false to ignore rotation and project only the coordinates of node's Bounds. The default value is true.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets the color used to paint text in the ruler.</summary>
		/// <returns type="String">A string specifying the text color.</returns>
	},
	getUnit: function() {
		/// <summary>Gets the measure units displayed in the ruler scales.</summary>
		/// <returns type="MindFusion.Drawing.GraphicsUnit">A member of the GraphicsUnit enumeration.</returns>
	},
	getVerticalScaleVisible: function() {
		/// <summary>Gets a value iindicating whether the vertical ruler scale is visible.</summary>
		/// <returns type="Boolean">true to display the vertical scale, or false otherwise. The default is true.</returns>
	},
	registerForSubmit: function(id) {
		/// <summary>Registers an onsubmit handler for the Ruler's parent html form to flush postback data.</summary>
		/// <param name="id" type="String">The id of the hidden field to flush the data to.</param>
	},
	setBackColor: function(value) {
		/// <summary>Sets the background color of the control.</summary>
		/// <param name="value" type="String">A string specifying the ruler's background color.</param>
	},
	setDiagram: function(diagram) {
		/// <summary>Sets the Diagram attached to this Ruler.</summary>
		/// <param name="diagram" type="MindFusion.Diagramming.Diagram">The Diagram attached to the ruler.</param>
	},
	setEnableGuides: function(value) {
		/// <summary>Sets a value indicating whether the alignment guides are enabled.</summary>
		/// <param name="value" type="Boolean">true to allow aligning diagram items using ruler guides, or false otherwise. The default is true.</param>
	},
	setForeColor: function(value) {
		/// <summary>Sets the foreground color of the control.</summary>
		/// <param name="value" type="String">A string specifying the ruler's foreground color.</param>
	},
	setGuideColor: function(value) {
		/// <summary>Sets the color of the alignment guide lines.</summary>
		/// <param name="value" type="String">A string specifying color of guide lines.</param>
	},
	setHorizontalScaleVisible: function(value) {
		/// <summary>Sets a value indicating whether the horizontal ruler scale is visible.</summary>
		/// <param name="value" type="Boolean">true to display the horizontal scale, or false otherwise. The default is true.</param>
	},
	setNegatedX: function(value) {
		/// <summary>Sets whether the horizontal scale should show negated values, simulating that the coordinate system's X axis grows to the left.</summary>
		/// <param name="value" type="Boolean">true if the horizontal scale should show negated values, or false otherwise. The default value is false.</param>
	},
	setNegatedY: function(value) {
		/// <summary>Sets whether the vertical scale should show negated values, simulating that the coordinate system's Y axis grows to the top.</summary>
		/// <param name="value" type="Boolean">true if the vertical scale should show negated values, or false otherwise. The default value is false.</param>
	},
	setPointerColor: function(value) {
		/// <summary>Sets the color of the mouse pointer's projections.</summary>
		/// <param name="value" type="String">A string specifying the color of pointer projection lines.</param>
	},
	setProjectionColor: function(value) {
		/// <summary>Sets the color used to paint the projection of the active node.</summary>
		/// <param name="value" type="String">A string specifying the projection color.</param>
	},
	setProjectRotatedBounds: function(value) {
		/// <summary>Sets whether the projection of nodes on ruler's scales rotates with them.</summary>
		/// <param name="value" type="Boolean">true if node's projection should match the boundaries of rotated node shape, or false to ignore rotation and project only the coordinates of node's Bounds. The default value is true.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets the color used to paint text in the ruler.</summary>
		/// <param name="value" type="String">A string specifying the text color.</param>
	},
	setUnit: function(value) {
		/// <summary>Sets the measure units displayed in the ruler scales.</summary>
		/// <param name="value" type="MindFusion.Drawing.GraphicsUnit">A member of the GraphicsUnit enumeration.</param>
	},
	setVerticalScaleVisible: function(value) {
		/// <summary>Sets a value indicating whether the vertical ruler scale is visible.</summary>
		/// <param name="value" type="Boolean">true to display the vertical scale, or false otherwise. The default is true.</param>
	}
};
MindFusion.Diagramming.Ruler.__class = true;

MindFusion.Diagramming.Ruler.create = function(element) {
	/// <summary>Creates and initializes a new Ruler from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the ruler should be attached to.</param>
	/// <returns type="MindFusion.Diagramming.Ruler">A Ruler object that represents the newly created ruler.</returns>
};
MindFusion.Diagramming.Ruler.find = function(id, parent) {
	/// <summary>Returns the specified Ruler object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the ruler to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the ruler to find.</param>
	/// <returns type="MindFusion.Diagramming.Ruler">A Ruler object that contains the ruler requested by id, if found; otherwise, null.</returns>
};

MindFusion.Diagramming.SaveToStringFormat = {
	/// <summary>Specifies in what format to save the diagram when generating a string using the saveToString method.</summary>
	/// <field name="Json">Indicates JSON format.</field>
	/// <field name="Xml">Indicates XML format.</field>
	Json: 0,
	Xml: 1
}
MindFusion.Diagramming.SaveToStringFormat.__enum = true;

MindFusion.Diagramming.ScaleMode = {
	/// <summary>Defines Overview scaling modes.</summary>
	/// <field name="CombinedScales">Combine diagram's ZoomFactor with overview's ScaleFactor.</field>
	/// <field name="FitAll">Scale the Overview dynamically to fit the entire diagram.</field>
	/// <field name="FixedScale">Use fixed scale specified via ScaleFactor, ignoring diagram's zoom level.</field>
	CombinedScales: 0,
	FitAll: 1,
	FixedScale: 2
}
MindFusion.Diagramming.ScaleMode.__enum = true;

MindFusion.Diagramming.ScrollTableCommand.prototype = {
	execute: function() {
		/// <summary>Command.execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.undo override.</summary>
	}
};
MindFusion.Diagramming.ScrollTableCommand.__class = true;

MindFusion.Diagramming.Selection.prototype = {
	addItem: function(item) {
		/// <summary>Adds an item to this Selection.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The item to add.</param>
	},
	allowDrag: function(ist) {
		/// <summary>DiagramItem.allowDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	clear: function() {
		/// <summary>Removes all items from the selection.</summary>
	},
	endDrag: function(ist) {
		/// <summary>DiagramItem.endDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	getBounds: function() {
		/// <summary>Gets a rectangle that defines the position of the selection frame.</summary>
		/// <returns type="MindFusion.Drawing.Rect">The frame's bounding rectangle.</returns>
	},
	onRemove: function() {
		/// <summary>DiagramItem.onRemove override.</summary>
	},
	removeItem: function(item) {
		/// <summary>Removes an item from this Selection.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">The item to remove.</param>
	},
	saveLocationState: function() {
		/// <summary>DiagramItem.saveLocationState override.</summary>
		/// <returns type="Object">An object containing selection state.</returns>
	},
	startDrag: function(ist) {
		/// <summary>DiagramItem.startDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState" optional="true">Optional. An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
	updateDrag: function(ist) {
		/// <summary>DiagramItem.updateDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	}
};
MindFusion.Diagramming.Selection.__class = true;

MindFusion.Diagramming.SelectionEventArgs.prototype = {
	cancelDrag: function() {
		/// <summary>Immediately cancels the current selection modification.</summary>
	},
	getAdjustmentHandle: function() {
		/// <summary>Gets the adjustment handle being moved by the user.</summary>
		/// <returns type="MindFusion.Diagramming.AdjustmentHandles">One of the AdjustmentHandles enumeration values.</returns>
	},
	getCancel: function() {
		/// <summary>Gets a value indicating whether to allow the current operation.</summary>
		/// <returns type="Boolean">true if the current operation is allowed; otherwise, false.</returns>
	},
	getMousePosition: function() {
		/// <summary>Gets the current mouse pointer position.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point instance.</returns>
	},
	setCancel: function(value) {
		/// <summary>Sets a value indicating whether to allow the current operation.</summary>
		/// <param name="value" type="Boolean">true to allow the current operation; otherwise, false.</param>
	}
};
MindFusion.Diagramming.SelectionEventArgs.__class = true;

MindFusion.Diagramming.SelectOnlyBehavior.prototype = {
	createController: function(state) {
		/// <summary>BehaviorBase.createController override.</summary>
		/// <param name="state" type="Object">An object representing current context and input event.</param>
		/// <returns type="MindFusion.Diagramming.SinglePointerController">An instance of SinglePointerController -derived class.</returns>
	}
};
MindFusion.Diagramming.SelectOnlyBehavior.__class = true;

MindFusion.Diagramming.SerializeTagEventArgs.prototype = {
	getContext: function() {
		/// <summary>Gets an XmlPersistContext object providing helper read and write methods for various value types.</summary>
	},
	getElement: function() {
		/// <summary>Gets the XML element where the tag value should be serialized to or deserialized from.</summary>
	},
	getHandled: function() {
		/// <summary>Gets a value indicating whether the event has been handled.</summary>
	},
	getObject: function() {
		/// <summary>Gets the object whose property is being serialized or deserialized.</summary>
	},
	getPropertyName: function() {
		/// <summary>Gets the name of the property being serialized.</summary>
	},
	getTag: function() {
		/// <summary>Gets the tag value being serialized or deserialized.</summary>
	},
	setHandled: function(value) {
		/// <summary>Sets a value indicating whether the event has been handled.</summary>
		/// <param name="value" type="void"></param>
	},
	setTag: function(value) {
		/// <summary>Sets the tag value being serialized or deserialized.</summary>
		/// <param name="value" type="void"></param>
	}
};
MindFusion.Diagramming.SerializeTagEventArgs.__class = true;

MindFusion.Diagramming.setImage.prototype = {
};
MindFusion.Diagramming.setImage.__class = true;

MindFusion.Diagramming.setImageAlign.prototype = {
};
MindFusion.Diagramming.setImageAlign.__class = true;

MindFusion.Diagramming.setImageContent.prototype = {
};
MindFusion.Diagramming.setImageContent.__class = true;

MindFusion.Diagramming.setImageLocation.prototype = {
};
MindFusion.Diagramming.setImageLocation.__class = true;

MindFusion.Diagramming.setImagePadding.prototype = {
};
MindFusion.Diagramming.setImagePadding.__class = true;

MindFusion.Diagramming.setLineAlignment.prototype = {
};
MindFusion.Diagramming.setLineAlignment.__class = true;

MindFusion.Diagramming.setText.prototype = {
};
MindFusion.Diagramming.setText.__class = true;

MindFusion.Diagramming.setTextAlignment.prototype = {
};
MindFusion.Diagramming.setTextAlignment.__class = true;

MindFusion.Diagramming.ShadowsStyle = {
	/// <summary>Enumerates possible shadows-drawing styles.</summary>
	/// <field name="None">No shadows are drawn.</field>
	/// <field name="OneLevel">All shadows are drawn at the lowest z-level, and appear to be on one level.</field>
	/// <field name="ZOrder">Every shadows is drawn just below its object, possibly covering other objects.</field>
	None: 0,
	OneLevel: 1,
	ZOrder: 2
}
MindFusion.Diagramming.ShadowsStyle.__enum = true;

MindFusion.Diagramming.Shape.prototype = {
	getBrush: function() {
		/// <summary>Gets the object that specifies how to paint the interior of the Shape.</summary>
		/// <returns type="Object">An object specifying the fill of the shape.</returns>
	},
	getId: function() {
		/// <summary>Gets the id of this Shape.</summary>
		/// <returns type="String">The id.</returns>
	},
	getPen: function() {
		/// <summary>Gets an object used to paint the frame of the Shape.</summary>
		/// <returns type="String">A string value identifying the stroke of the shape.</returns>
	},
	isElliptic: function() {
		/// <summary>Gets a value indicating whether this shape is elliptic.</summary>
		/// <returns type="Boolean">True if the shape is elliptic, otherwise false.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>Loads the shape content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that contains the the shape's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of the Shape.</summary>
		/// <param name="value" type="Object">A Brush object specifying the fill of the shape.</param>
	},
	setPen: function(value) {
		/// <summary>Sets an object used to paint the frame of the Shape.</summary>
		/// <param name="value" type="String">A string value identifying the stroke of the shape.</param>
	}
};
MindFusion.Diagramming.Shape.__class = true;

MindFusion.Diagramming.Shape.component = function(id, isOutline, node) {
	/// <summary>Creates a shape component.</summary>
	/// <param name="id" type="String">The identifier of the shape.</param>
	/// <param name="isOutline" type="Boolean" optional="true">Optional. A value indicating whether this shape defines the outline of its host node.</param>
	/// <param name="node" type="MindFusion.Diagramming.CompositeNode" optional="true">Optional. The host node of this component.</param>
	/// <returns type="MindFusion.Diagramming.Shape">A reference to a Shape component with the specified identifier.</returns>
};
MindFusion.Diagramming.Shape.fromId = function(id) {
	/// <summary>Returns a reference to the shape with the specified string identifier.</summary>
	/// <param name="id" type="String">The identifier of the shape of interest.</param>
	/// <returns type="MindFusion.Diagramming.Shape">A reference to the Shape with the specified identifier or a null if there is no such shape.</returns>
};

MindFusion.Diagramming.ShapeLibrary.prototype = {
	getShapes: function() {
		/// <summary>Gets the list with all shapes contained in the library.</summary>
	},
	loadFromXml: function(fileUrl, onLoad, onError) {
		/// <summary>Loads the library from the specified XML document.</summary>
		/// <param name="fileUrl" type="String">The URL of an XML file where the data should be read from.</param>
		/// <param name="onLoad" type="Function" optional="true">Optional. A callback that should be invoked if the file is loaded successfully.</param>
		/// <param name="onError" type="Function" optional="true">Optional. A callback that should be invoked if the file could not be downloaded.</param>
	}
};
MindFusion.Diagramming.ShapeLibrary.__class = true;

MindFusion.Diagramming.ShapeNode.prototype = {
	containsPoint: function(point) {
		/// <summary>Checks if the ShapeNode contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The Point to check.</param>
		/// <returns type="Boolean">true if the point is within the bounds of this node; otherwise, false.</returns>
	},
	getAllowFlip: function() {
		/// <summary>Gets a value indicating whether the node's shape flips when an edge is dragged over its opposite edge.</summary>
		/// <returns type="Boolean">true to flip the shape, or false otherwise.</returns>
	},
	getEnableStyledText: function() {
		/// <summary>Gets a value indicating whether styled text rendering is enabled.</summary>
		/// <returns type="Boolean">true to parse the node's text in order to find formatting tags; or false otherwise.</returns>
	},
	getFlipX: function() {
		/// <summary>Gets a value indicating whether the node's shape is fliped horizontally.</summary>
		/// <returns type="Boolean">true if the shape is flipped horizontally, or false otherwise.</returns>
	},
	getFlipY: function() {
		/// <summary>Gets a value indicating whether the node's shape is fliped vertically.</summary>
		/// <returns type="Boolean">true if the shape is flipped vertically, or false otherwise.</returns>
	},
	getImage: function() {
		/// <summary>Gets the image of the node.</summary>
		/// <returns type="HTMLImageElement">The image of the node.</returns>
	},
	getImageAlign: function() {
		/// <summary>Gets the alignment for the image of this node.</summary>
		/// <returns type="MindFusion.Drawing.ImageAlign">One of the ImageAlign Enumeration values.</returns>
	},
	getImageContent: function() {
		/// <summary>Gets the Base64-encoded data of the image displayed in this ShapeNode.</summary>
		/// <returns type="String">The Base64-encoded data for the image to be loaded.</returns>
	},
	getImageLocation: function() {
		/// <summary>Gets the URL of the image displayed in this ShapeNode.</summary>
		/// <returns type="String">A valid URL string that identifies the image to be loaded.</returns>
	},
	getImagePadding: function() {
		/// <summary>Gets the padding distance between node borders and image.</summary>
		/// <returns type="MindFusion.Drawing.Thickness">A Thickness instance specifying image padding.</returns>
	},
	getOutline: function() {
		/// <summary>Gets an array of points that define the outline of this node shape.</summary>
		/// <returns type="Array">An array with the points.</returns>
	},
	getRotateImage: function() {
		/// <summary>Gets a value indicating whether the image is rotated when the node is rotated.</summary>
		/// <returns type="Boolean">true if the image is rotated; otherwise, false.</returns>
	},
	getRotateText: function() {
		/// <summary>Gets a value indicating whether text is rotated when the node is rotated.</summary>
		/// <returns type="Boolean">true if the text is rotated; otherwise, false.</returns>
	},
	getShape: function() {
		/// <summary>Gets a reference to the node's geometric shape definition.</summary>
		/// <returns type="MindFusion.Diagramming.Shape">The Shape of this node.</returns>
	},
	getTransparent: function() {
		/// <summary>Gets or sets a value indicating whether this shape node is transparent.</summary>
		/// <returns type="Boolean">true if the node is transparent; otherwise, false.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this ShapeNode instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramNode.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	resizeToFitText: function(fit) {
		/// <summary>Makes the shape node big enough to display its text without clipping.</summary>
		/// <param name="fit" type="MindFusion.Diagramming.FitSize">One of the FitSize enumeration values.</param>
		/// <returns type="Boolean">true if the node is resized successfully; otherwise, false.</returns>
	},
	restoreLocationState: function(ist) {
		/// <summary>DiagramItem.restoreLocationState override.</summary>
		/// <param name="ist" type="ShapeNodeState">A ShapeNodeState instance.</param>
	},
	saveLocationState: function() {
		/// <summary>DiagramItem.saveLocationState override.</summary>
		/// <returns type="ShapeNodeState">A ShapeNodeState instance.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the node's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setAllowFlip: function(value) {
		/// <summary>Sets a value indicating whether the node's shape flips when an edge is dragged over its opposite edge.</summary>
		/// <param name="value" type="Boolean">true to flip the shape, or false otherwise.</param>
	},
	setEnableStyledText: function(value) {
		/// <summary>Sets a value indicating whether styled text rendering is enabled.</summary>
		/// <param name="value" type="Boolean">true to parse the node's text in order to find formatting tags; or false otherwise.</param>
	},
	setFlipX: function(value) {
		/// <summary>Sets a value indicating whether the node's shape is flipped horizontally.</summary>
		/// <param name="value" type="Boolean">true if the shape is flipped horizontally, or false otherwise.</param>
	},
	setFlipY: function(value) {
		/// <summary>Sets a value indicating whether the node's shape is flipped vertically.</summary>
		/// <param name="value" type="Boolean">true if the shape is flipped vertically, or false otherwise.</param>
	},
	setImage: function(value) {
		/// <summary>Sets the image of the node.</summary>
		/// <param name="value" type="HTMLImageElement">The image to set.</param>
	},
	setImageAlign: function(value) {
		/// <summary>Sets the alignment for the image of this node.</summary>
		/// <param name="value" type="MindFusion.Drawing.ImageAlign">One of the ImageAlign Enumeration values.</param>
	},
	setImageContent: function(value) {
		/// <summary>Sets the Base64-encoded data of the image displayed in this ShapeNode.</summary>
		/// <param name="value" type="String">The Base64-encoded data for the image to be loaded.</param>
	},
	setImageLocation: function(value) {
		/// <summary>Sets the URL of the image displayed in this ShapeNode.</summary>
		/// <param name="value" type="String">A valid URL string that identifies the image to be loaded.</param>
	},
	setImagePadding: function(value) {
		/// <summary>Sets the padding distance between node borders and image.</summary>
		/// <param name="value" type="MindFusion.Drawing.Thickness">A Thickness instance specifying image padding.</param>
	},
	setRotateImage: function(value) {
		/// <summary>Sets a value indicating whether the image is rotated when the node is rotated.</summary>
		/// <param name="value" type="Boolean">true if the image is rotated; otherwise, false.</param>
	},
	setRotateText: function(value) {
		/// <summary>Sets a value indicating whether text is rotated when the node is rotated.</summary>
		/// <param name="value" type="Boolean">true if the text is rotated; otherwise, false.</param>
	},
	setShape: function(value) {
		/// <summary>Sets a reference to the node's geometric shape definition.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Shape">An instance of the Shape class.</param>
	},
	setTransparent: function(value) {
		/// <summary>Sets or sets a value indicating whether this shape node is transparent.</summary>
		/// <param name="value" type="Boolean">true if the node is transparent; otherwise, false.</param>
	},
	updateDrag: function(ist) {
		/// <summary>DiagramItem.updateDrag override.</summary>
		/// <param name="ist" type="MindFusion.Diagramming.InteractionState">An InteractionState object that encapsulates the current state of user interaction with the control.</param>
	},
};
MindFusion.Diagramming.ShapeNode.__class = true;

MindFusion.Diagramming.ShapeNode.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new ShapeNode instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.shapes.prototype = {
};
MindFusion.Diagramming.shapes.__class = true;

MindFusion.Diagramming.Shapes.prototype = {
};
MindFusion.Diagramming.Shapes.__class = true;

MindFusion.Diagramming.Shapes.Actor = function() {
	/// <summary>Gets the Actor predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Alternative = function() {
	/// <summary>Gets the Alternative predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow = function() {
	/// <summary>Gets the Arrow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow1 = function() {
	/// <summary>Gets the Arrow1 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow2 = function() {
	/// <summary>Gets the Arrow2 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow3 = function() {
	/// <summary>Gets the Arrow3 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow4 = function() {
	/// <summary>Gets the Arrow4 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow5 = function() {
	/// <summary>Gets the Arrow5 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow6 = function() {
	/// <summary>Gets the Arrow6 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow7 = function() {
	/// <summary>Gets the Arrow7 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow8 = function() {
	/// <summary>Gets the Arrow8 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Arrow9 = function() {
	/// <summary>Gets the Arrow9 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BackSlash = function() {
	/// <summary>Gets the BackSlash predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BeginLoop = function() {
	/// <summary>Gets the BeginLoop predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BowArrow = function() {
	/// <summary>Gets the BowArrow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnComplex = function() {
	/// <summary>Gets the BpmnComplex predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnDataBasedXor = function() {
	/// <summary>Gets the BpmnDataBasedXor predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndCancel = function() {
	/// <summary>Gets the BpmnEndCancel predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndCompensation = function() {
	/// <summary>Gets the BpmnEndCompensation predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndError = function() {
	/// <summary>Gets the BpmnEndError predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndLink = function() {
	/// <summary>Gets the BpmnEndLink predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndMessage = function() {
	/// <summary>Gets the BpmnEndMessage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndMultiple = function() {
	/// <summary>Gets the BpmnEndMultiple predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEndTerminate = function() {
	/// <summary>Gets the BpmnEndTerminate predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnEventBasedXor = function() {
	/// <summary>Gets the BpmnEventBasedXor predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnInclusive = function() {
	/// <summary>Gets the BpmnInclusive predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateCancel = function() {
	/// <summary>Gets the BpmnIntermediateCancel predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateCompensation = function() {
	/// <summary>Gets the BpmnIntermediateCompensation predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateError = function() {
	/// <summary>Gets the BpmnIntermediateError predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateLink = function() {
	/// <summary>Gets the BpmnIntermediateLink predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateMessage = function() {
	/// <summary>Gets the BpmnIntermediateMessage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateMultiple = function() {
	/// <summary>Gets the BpmnIntermediateMultiple predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateRule = function() {
	/// <summary>Gets the BpmnIntermediateRule predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnIntermediateTimer = function() {
	/// <summary>Gets the BpmnIntermediateTimer predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnParallelFork = function() {
	/// <summary>Gets the BpmnParallelFork predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnStartLink = function() {
	/// <summary>Gets the BpmnStartLink predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnStartMessage = function() {
	/// <summary>Gets the BpmnStartMessage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnStartMultiple = function() {
	/// <summary>Gets the BpmnStartMultiple predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnStartRule = function() {
	/// <summary>Gets the BpmnStartRule predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.BpmnStartTimer = function() {
	/// <summary>Gets the BpmnStartTimer predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Circle = function() {
	/// <summary>Gets the Circle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Cloud = function() {
	/// <summary>Gets the Cloud predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Collate = function() {
	/// <summary>Gets the Collate predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ConeDown = function() {
	/// <summary>Gets the ConeDown predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ConeUp = function() {
	/// <summary>Gets the ConeUp predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ConnectedIssues = function() {
	/// <summary>Gets the ConnectedIssues predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.CreateRequest = function() {
	/// <summary>Gets the CreateRequest predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Cross = function() {
	/// <summary>Gets the Cross predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Cube = function() {
	/// <summary>Gets the Cube predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Cylinder = function() {
	/// <summary>Gets the Cylinder predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Database = function() {
	/// <summary>Gets the Database predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DataTransmition = function() {
	/// <summary>Gets the DataTransmition predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DDelay = function() {
	/// <summary>Gets the DDelay predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Decagon = function() {
	/// <summary>Gets the Decagon predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Decision = function() {
	/// <summary>Gets the Decision predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Decision2 = function() {
	/// <summary>Gets the Decision2 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DefaultFlow = function() {
	/// <summary>Gets the DefaultFlow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Delay = function() {
	/// <summary>Gets the Delay predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DInDelay = function() {
	/// <summary>Gets the DInDelay predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DirectAccessStorage = function() {
	/// <summary>Gets the DirectAccessStorage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DiskStorage = function() {
	/// <summary>Gets the DiskStorage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Display = function() {
	/// <summary>Gets the Display predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DividedEvent = function() {
	/// <summary>Gets the DividedEvent predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DividedProcess = function() {
	/// <summary>Gets the DividedProcess predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Document = function() {
	/// <summary>Gets the Document predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Donut = function() {
	/// <summary>Gets the Donut predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DoubleArrow = function() {
	/// <summary>Gets the DoubleArrow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.DOutDelay = function() {
	/// <summary>Gets the DOutDelay predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Ellipse = function() {
	/// <summary>Gets the Ellipse predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.EndLoop = function() {
	/// <summary>Gets the EndLoop predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ExternalOrganization = function() {
	/// <summary>Gets the ExternalOrganization predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ExternalProcess = function() {
	/// <summary>Gets the ExternalProcess predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.File = function() {
	/// <summary>Gets the File predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.FramedRectangle = function() {
	/// <summary>Gets the FramedRectangle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Gate = function() {
	/// <summary>Gets the Gate predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Heart = function() {
	/// <summary>Gets the Heart predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Heptagon = function() {
	/// <summary>Gets the Heptagon predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Hourglass = function() {
	/// <summary>Gets the Hourglass predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Input = function() {
	/// <summary>Gets the Input predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.InternalStorage = function() {
	/// <summary>Gets the InternalStorage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Interrupt = function() {
	/// <summary>Gets the Interrupt predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Interrupt2 = function() {
	/// <summary>Gets the Interrupt2 predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.IsoProcess = function() {
	/// <summary>Gets the IsoProcess predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Junction = function() {
	/// <summary>Gets the Junction predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Lightning = function() {
	/// <summary>Gets the Lightning predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.LinedDocument = function() {
	/// <summary>Gets the LinedDocument predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.ManualOperation = function() {
	/// <summary>Gets the ManualOperation predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Merge = function() {
	/// <summary>Gets the Merge predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MessageFromUser = function() {
	/// <summary>Gets the MessageFromUser predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MessageToUser = function() {
	/// <summary>Gets the MessageToUser predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Microform = function() {
	/// <summary>Gets the Microform predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MicroformProcessing = function() {
	/// <summary>Gets the MicroformProcessing predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MicroformRecording = function() {
	/// <summary>Gets the MicroformRecording predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MultiDocument = function() {
	/// <summary>Gets the MultiDocument predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.MultiProc = function() {
	/// <summary>Gets the MultiProc predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Octagon = function() {
	/// <summary>Gets the Octagon predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.OfflineStorage = function() {
	/// <summary>Gets the OfflineStorage predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.OffpageConnection = function() {
	/// <summary>Gets the OffpageConnection predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.OffpageReference = function() {
	/// <summary>Gets the OffpageReference predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Or = function() {
	/// <summary>Gets the Or predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Pentagon = function() {
	/// <summary>Gets the Pentagon predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PentagonArrow = function() {
	/// <summary>Gets the PentagonArrow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Plaque = function() {
	/// <summary>Gets the Plaque predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PointerArrow = function() {
	/// <summary>Gets the PointerArrow predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PrimitiveFromCall = function() {
	/// <summary>Gets the PrimitiveFromCall predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PrimitiveToCall = function() {
	/// <summary>Gets the PrimitiveToCall predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Procedure = function() {
	/// <summary>Gets the Procedure predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Process = function() {
	/// <summary>Gets the Process predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Prysm = function() {
	/// <summary>Gets the Prysm predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PunchedCard = function() {
	/// <summary>Gets the PunchedCard predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PyramidDown = function() {
	/// <summary>Gets the PyramidDown predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.PyramidUp = function() {
	/// <summary>Gets the PyramidUp predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Quill = function() {
	/// <summary>Gets the Quill predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Rectangle = function() {
	/// <summary>Gets the Rectangle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Reversed = function() {
	/// <summary>Gets the Reversed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RevTriangle = function() {
	/// <summary>Gets the RevTriangle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RevWithCirc = function() {
	/// <summary>Gets the RevWithCirc predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RevWithLine = function() {
	/// <summary>Gets the RevWithLine predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Rhombus = function() {
	/// <summary>Gets the Rhombus predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RightTriangle = function() {
	/// <summary>Gets the RightTriangle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RoundRect = function() {
	/// <summary>Gets the RoundRect predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.RSave = function() {
	/// <summary>Gets the RSave predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Save = function() {
	/// <summary>Gets the Save predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Slash = function() {
	/// <summary>Gets the Slash predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Sort = function() {
	/// <summary>Gets the Sort predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Sphere = function() {
	/// <summary>Gets the Sphere predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star = function() {
	/// <summary>Gets the Star predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star16Pointed = function() {
	/// <summary>Gets the Star16Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star24Pointed = function() {
	/// <summary>Gets the Star24Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star32Pointed = function() {
	/// <summary>Gets the Star32Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star4Pointed = function() {
	/// <summary>Gets the Star4Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star5Pointed = function() {
	/// <summary>Gets the Star5Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star6Pointed = function() {
	/// <summary>Gets the Star6Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Star7Pointed = function() {
	/// <summary>Gets the Star7Pointed predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Start = function() {
	/// <summary>Gets the Start predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Tape = function() {
	/// <summary>Gets the Tape predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Terminator = function() {
	/// <summary>Gets the Terminator predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Tetragon = function() {
	/// <summary>Gets the Tetragon predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.TransmittalTape = function() {
	/// <summary>Gets the TransmittalTape predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Trapezoid = function() {
	/// <summary>Gets the Trapezoid predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};
MindFusion.Diagramming.Shapes.Triangle = function() {
	/// <summary>Gets the Triangle predefined shape.</summary>
	/// <returns type="MindFusion.Diagramming.Shape">An instance of the Shape class representing the predefined shape.</returns>
};

MindFusion.Diagramming.ShowAnchors = {
	/// <summary>Specifies when anchors points should be displayed.</summary>
	/// <field name="Always">Anchor point marks are always painted.</field>
	/// <field name="Auto">Anchor point marks are shown for the node under the mouse cursor.</field>
	/// <field name="Never">Anchor point marks are never painted.</field>
	/// <field name="Selected">Anchor point marks are painted for the selected node.</field>
	Always: 0,
	Auto: 1,
	Never: 2,
	Selected: 3
}
MindFusion.Diagramming.ShowAnchors.__enum = true;

MindFusion.Diagramming.SimplePanel.prototype = {
};
MindFusion.Diagramming.SimplePanel.__class = true;

MindFusion.Diagramming.SimpleShape = {
	/// <summary>Defines the possible values for Shape property of tables and containers.</summary>
	/// <field name="Rectangle">Sets node's shape to rectangle.</field>
	/// <field name="RoundedRectangle">Sets node's shape to rounded rectangle.</field>
	Rectangle: 0,
	RoundedRectangle: 1
}
MindFusion.Diagramming.SimpleShape.__enum = true;

MindFusion.Diagramming.SinglePointerController.prototype = {
	cancel: function(position) {
		/// <summary>Called when the user stops drawing or modifying a diagram element, rejecting the operation.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	commit: function(position) {
		/// <summary>Called when the user stops drawing or modifying a diagram element, accepting the operation.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	drawInteraction: function(context) {
		/// <summary>Called to draw current state of user interaction.</summary>
		/// <param name="context" type="DrawingContext2D">The drawing context for diagram's underlying canvas.</param>
	},
	move: function(position) {
		/// <summary>Called continuously while the user draws with the mouse or touch.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	start: function(position) {
		/// <summary>Called when the user starts drawing or modifying a diagram element.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
	},
	validate: function(position) {
		/// <summary>Called to validate the operation at current pointer position.</summary>
		/// <param name="position" type="MindFusion.Drawing.Point">A point specified in diagram coordinates.</param>
		/// <returns type="Boolean">true to accept the operation, or false otherwise.</returns>
	}
};
MindFusion.Diagramming.SinglePointerController.__class = true;

MindFusion.Diagramming.StackPanel.prototype = {
	getOrientation: function() {
		/// <summary>Gets the stack orientation.</summary>
		/// <returns type="MindFusion.Diagramming.Orientation">A member of the Orientation enumeration.</returns>
	},
	setOrientation: function(value) {
		/// <summary>Sets the stack orientation.</summary>
		/// <param name="value" type="MindFusion.Diagramming.Orientation">A member of the Orientation enumeration.</param>
	}
};
MindFusion.Diagramming.StackPanel.__class = true;

MindFusion.Diagramming.strokeThickness.prototype = {
};
MindFusion.Diagramming.strokeThickness.__class = true;

MindFusion.Diagramming.Style.prototype = {
	getBackBrush: function() {
		/// <summary>Gets the brush used to fill the diagram background.</summary>
		/// <returns type="Object">A brush object specifying the fill of the diagram background.</returns>
	},
	getBrush: function() {
		/// <summary>Gets the brush used to fill the interior of diagram items.</summary>
		/// <returns type="Object">A brush object specifying the fill of diagram items.</returns>
	},
	getFontName: function() {
		/// <summary>Gets the name of the font used to draw text of diagram items.</summary>
		/// <returns type="String">A string value identifying the font name of diagram items.</returns>
	},
	getFontSize: function() {
		/// <summary>Gets the size of the font used to draw text of diagram items.</summary>
		/// <returns type="Number">A number identifying the font size of diagram items.</returns>
	},
	getFontStyle: function() {
		/// <summary>Gets the style of the font used to draw text of diagram items.</summary>
		/// <returns type="MindFusion.Drawing.FontStyle">A combination of FontStyle enumeration members.</returns>
	},
	getNodeEffects: function() {
		/// <summary>Gets a list with all effects applied to the nodes of this diagram.</summary>
		/// <returns type="Array">A list with all effects applied to the nodes of this diagram.</returns>
	},
	getShadowColor: function() {
		/// <summary>Gets the color used to draw shadows of diagram items.</summary>
		/// <returns type="String">A string value identifying the shadow color of diagram items.</returns>
	},
	getStroke: function() {
		/// <summary>Gets the color used to stroke the frame of diagram items.</summary>
		/// <returns type="String">A string value identifying the stroke color of diagram items.</returns>
	},
	getStrokeDashStyle: function() {
		/// <summary>Gets the line dash pattern applied when stroking the frame of diagram items.</summary>
		/// <returns type="MindFusion.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	getStrokeThickness: function() {
		/// <summary>Gets the line width applied when stroking the frame of diagram items.</summary>
		/// <returns type="Number">A number identifying the stroke thickness of diagram items.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets the color used to draw text of diagram items.</summary>
		/// <returns type="String">A string value identifying the text color of diagram items.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this Style instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setBackBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of the diagram background.</summary>
		/// <param name="value" type="Object">A brush object specifying the fill of the diagram background.</param>
	},
	setBrush: function(value) {
		/// <summary>Sets an object that specifies how to paint the interior of diagram items.</summary>
		/// <param name="value" type="Object">A brush object specifying the fill of diagram items.</param>
	},
	setFontName: function(value) {
		/// <summary>Sets the name of the font used to draw text of diagram items.</summary>
		/// <param name="value" type="String">A string value identifying the font name of diagram items.</param>
	},
	setFontSize: function(A) {
		/// <summary>Sets the size of the font used to draw text of diagram items.</summary>
		/// <param name="A" type="Number">number identifying the font size of diagram items.</param>
	},
	setFontStyle: function(value) {
		/// <summary>Sets the style of the font used to draw text of diagram items.</summary>
		/// <param name="value" type="MindFusion.Drawing.FontStyle">A combination of FontStyle enumeration members.</param>
	},
	setNodeEffects: function(value) {
		/// <summary>Sets a list with all effects applied to the nodes of this diagram.</summary>
		/// <param name="value" type="Array">A list with all effects applied to the nodes of this diagram.</param>
	},
	setShadowColor: function(value) {
		/// <summary>Sets the color used to draw shadows of diagram items.</summary>
		/// <param name="value" type="String">A string value identifying the shadow color of diagram items.</param>
	},
	setStroke: function(value) {
		/// <summary>Sets the color used to stroke the frame of diagram items.</summary>
		/// <param name="value" type="String">A string value identifying the stroke color of diagram items.</param>
	},
	setStrokeDashStyle: function(value) {
		/// <summary>Sets the line dash pattern applied when stroking the frame of diagram items.</summary>
		/// <param name="value" type="MindFusion.Drawing.DashStyle">A member of the DashStyle enumeration.</param>
	},
	setStrokeThickness: function(value) {
		/// <summary>Sets the line width applied when stroking the frame of diagram items.</summary>
		/// <param name="value" type="Number">A number identifying the stroke thickness of diagram items.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets the color used to draw text of diagram items.</summary>
		/// <param name="value" type="String">A string value identifying the text color of diagram items.</param>
	},
};
MindFusion.Diagramming.Style.__class = true;

MindFusion.Diagramming.Style.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new Style instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.styles.prototype = {
};
MindFusion.Diagramming.styles.__class = true;

MindFusion.Diagramming.SvgContent.prototype = {
	parse: function(value) {
		/// <summary>Loads SVG code from the specified file.</summary>
		/// <param name="value" type="String">A string specifying the SVG file location.</param>
	},
	parseSvg: function(value) {
		/// <summary>Loads SVG code from the specified string.</summary>
		/// <param name="value" type="String">A string containing the SVG markup code.</param>
	}
};
MindFusion.Diagramming.SvgContent.__class = true;

MindFusion.Diagramming.SvgExporter.prototype = {
	exportElement: function(diagram) {
		/// <summary>Creates an SVG element representing the specified diagram.</summary>
		/// <param name="diagram" type="MindFusion.Drawing.Diagram">A reference to the diagram to be exported.</param>
	},
	exportString: function(diagram) {
		/// <summary>Creates an SVG document representing the specified diagram.</summary>
		/// <param name="diagram" type="MindFusion.Drawing.Diagram">A reference to the diagram to be exported.</param>
	}
};
MindFusion.Diagramming.SvgExporter.__class = true;

MindFusion.Diagramming.SvgNode.prototype = {
	getContent: function() {
		/// <summary>Gets an SvgContent instance representing the SVG drawing rendered in this node.</summary>
		/// <returns type="SvgContent">An instance of the SvgContent class.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this SvgNode instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramNode.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the node's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	setContent: function(value) {
		/// <summary>Sets an SvgContent instance representing the SVG drawing rendered in this node.</summary>
		/// <param name="value" type="SvgContent">An instance of the SvgContent class.</param>
	},
};
MindFusion.Diagramming.SvgNode.__class = true;

MindFusion.Diagramming.SvgNode.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new SvgNode instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.TableConnectionPoint.prototype = {
	addLinkToNode: function() {
		/// <summary>Adds the link associated with this connection point to the associated node.</summary>
	},
	getEndPoint: function() {
		/// <summary>Calculates the coordinates of this connection point expressed in document coordinates.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point that represents the coordinate.</returns>
	},
	getInitialPoint: function() {
		/// <summary>Returns a point (usually the center of the bounding rectangle) contained within the associated node.</summary>
		/// <returns type="MindFusion.Drawing.Point">A Point contained within the node.</returns>
	},
	getIntersection: function(point1, point2) {
		/// <summary>Calculates the intersection point between the specified line segment and the contour of the node associated with this connection point.</summary>
		/// <param name="point1" type="MindFusion.Drawing.Point">The first point of the segment.</param>
		/// <param name="point2" type="MindFusion.Drawing.Point">The second point of the segment.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point object representing the intersection point.</returns>
	},
	getNearestBorderPoint: function(point) {
		/// <summary>Returns the nearest point lying on the node border.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance specifying location in the diagram.</param>
		/// <returns type="AnchorPointDetails">An AnchorPointDetails specifying the anchor point properties.</returns>
	},
	linkChanges: function(item, point) {
		/// <summary>Checks whether the link would change if attached to the specified node at the specified point.</summary>
		/// <param name="item" type="MindFusion.Diagramming.DiagramItem">A DiagramItem under the mouse cursor.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">A point where the link will be connected.</param>
		/// <returns type="Boolean">true if the link would connect to a different entity if dropped at the specified location; otherwise, false.</returns>
	},
	removeLinkFromNode: function() {
		/// <summary>Removes the link associated with this connection point from the associated node.</summary>
	},
	saveEndRelative: function() {
		/// <summary>Updates the coordinates of the connection point represented by this link, relative to the bounding rectangle of the associated node.</summary>
	}
};
MindFusion.Diagramming.TableConnectionPoint.__class = true;

MindFusion.Diagramming.TableNode.prototype = {
	addColumn: function() {
		/// <summary>Adds a new column to the table.</summary>
		/// <returns type="Object">The newly created column object.</returns>
	},
	addRow: function() {
		/// <summary>Adds a new row to the table.</summary>
		/// <returns type="Object">The newly created row object.</returns>
	},
	cellFromPoint: function(point) {
		/// <summary>Returns the cell that contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance.</param>
		/// <returns type="Object">A JavaScript object representing the specified cell.</returns>
	},
	containsPoint: function(point) {
		/// <summary>Checks if the TableNode contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The Point to check.</param>
		/// <returns type="Boolean">true if the point is within the bounds of this node; otherwise, false.</returns>
	},
	createConnectionPoint: function(link, point, incoming) {
		/// <summary>Creates a connection point between this node and the specified link at the specified point.</summary>
		/// <param name="link" type="MindFusion.Diagramming.DiagramLink">A DiagramLink that should be connected to this node.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">The point at which the link should be connected.</param>
		/// <param name="incoming" type="Boolean">true if link is an incoming link, otherwise, false.</param>
		/// <returns type="MindFusion.Diagramming.TableConnectionPoint"></returns>
	},
	deleteColumn: function(col) {
		/// <summary>Deletes the specified column.</summary>
		/// <param name="col" type="Number">An integer value specifying which column to delete.</param>
	},
	deleteRow: function(row) {
		/// <summary>Deletes the specified row.</summary>
		/// <param name="row" type="Number">An integer value specifying which row to delete.</param>
	},
	getAllowResizeColumns: function() {
		/// <summary>Gets a value indicating whether users are allowed to resize table columns.</summary>
		/// <returns type="Boolean">true if users are allowed to resize table columns, otherwise false.</returns>
	},
	getAllowResizeRows: function() {
		/// <summary>Gets a value indicating whether users are allowed to resize table rows.</summary>
		/// <returns type="Boolean">true if users are allowed to resize table rows, otherwise false.</returns>
	},
	getCaptionBackBrush: function() {
		/// <summary>Gets the object that specifies how to fill the caption bar.</summary>
		/// <returns type="Object">An object specifying the fill of the caption bar.</returns>
	},
	getCaptionFont: function() {
		/// <summary>Gets the font used to render the table's caption text.</summary>
		/// <returns type="MindFusion.Drawing.Font">An object specifying the font of the caption bar.</returns>
	},
	getCaptionHeight: function() {
		/// <summary>Gets the height of the table's caption area.</summary>
		/// <returns type="Number">A number specifying the height of the table caption. The default value is 6.</returns>
	},
	getCell: function(col, row) {
		/// <summary>Returns a reference to the cell located at the specified column and row of this table.</summary>
		/// <param name="col" type="Number">An integer value specifying the index of a table's column.</param>
		/// <param name="row" type="Number">An integer value specifying the index of a table's row.</param>
		/// <returns type="MindFusion.Diagramming.Cell">A Cell instance representing the specified cell.</returns>
	},
	getCellFrameStyle: function() {
		/// <summary>Gets the style of the cell frame lines.</summary>
		/// <returns type="MindFusion.Diagramming.CellFrameStyle">A member of the CellFrameStyle enumeration.</returns>
	},
	getColumn: function(col) {
		/// <summary>Returns a reference to the column at the specified position within the table's list of columns.</summary>
		/// <param name="col" type="Number">An integer value specifying the index of a table's column.</param>
		/// <returns type="Object">A JavaScript object representing the specified column.</returns>
	},
	getColumnCount: function() {
		/// <summary>Gets the number of columns in the table.</summary>
		/// <returns type="Number">The number of columns in the table.</returns>
	},
	getConnectionStyle: function() {
		/// <summary>Gets a value indicating whether drawing a link from/to this table should connecta row of the table, or the whole table as an integral entity.</summary>
		/// <returns type="MindFusion.Diagramming.ConnectionStyle">A member of the ConnectionStyle enumeration.</returns>
	},
	getCurrentScrollRow: function() {
		/// <summary>Gets the table's current scroll position.</summary>
		/// <returns type="Number">The index of the first row that should be visible in the table.</returns>
	},
	getEnableStyledText: function() {
		/// <summary>Gets a value indicating whether styled text rendering is enabled.</summary>
		/// <returns type="Boolean">true to parse the node's text in order to find formatting tags, or false otherwise.</returns>
	},
	getOutline: function() {
		/// <summary>Gets an array of points that define the outline of this node shape.</summary>
		/// <returns type="Array">An array with the points.</returns>
	},
	getRow: function(row) {
		/// <summary>Returns a reference to the row at the specified position within the table's list of rows.</summary>
		/// <param name="row" type="Number">An integer value specifying the index of a table's row.</param>
		/// <returns type="Object">A JavaScript object representing the specified row.</returns>
	},
	getRowCount: function() {
		/// <summary>Gets the number of rows in the table.</summary>
		/// <returns type="Number">The number of rows in the table.</returns>
	},
	getRowRect: function(row) {
		/// <summary>Returns the bounding rectangle of the specified row.</summary>
		/// <param name="row" type="Number">An integer value specifying the index of a table's row.</param>
		/// <returns type="MindFusion.Drawing.Rect">A Rect object representing the row's bounding rectangle.</returns>
	},
	getScrollable: function() {
		/// <summary>Gets a value indicating whether the user is allowed to scroll the table rows.</summary>
		/// <returns type="Boolean">true if the table can be scrolled; otherwise, false.</returns>
	},
	getShape: function() {
		/// <summary>Gets the shape of the table's outline.</summary>
		/// <returns type="MindFusion.Diagramming.SimpleShape">A member of the SimpleShape enumeration.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this TableNode instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	insertColumn: function(col) {
		/// <summary>Inserts a new column at the specified position.</summary>
		/// <param name="col" type="Number">An integer value specifying the position within the table's list of columns where the new column should be inserted.</param>
	},
	insertRow: function(row) {
		/// <summary>Inserts a new row at the specified position.</summary>
		/// <param name="row" type="Number">An integer value specifying the position within the table's list of rows where the new row should be inserted.</param>
	},
	loadFromXml: function(xmlElement, context) {
		/// <summary>DiagramNode.LoadFromXml override. Loads the node's content from an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element containing the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	redimTable: function(columns, rows) {
		/// <summary>Changes the number of columns and rows in this table.</summary>
		/// <param name="columns" type="Number">An integer value specifying the new number of columns.</param>
		/// <param name="rows" type="Number">An integer value specifying the new number of rows.</param>
	},
	resizeToFitText: function(ignoreCaption, keepCellWidth) {
		/// <summary>Resizes the columns and rows so that the cells are large enough to fit their text.</summary>
		/// <param name="ignoreCaption" type="void"></param>
		/// <param name="keepCellWidth" type="void"></param>
	},
	rowFromPoint: function(point) {
		/// <summary>Returns the index of the table's row that contains the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance.</param>
		/// <returns type="Number">An integer value specifying the row's index.</returns>
	},
	saveToXml: function(xmlElement, context) {
		/// <summary>Saves the node's content into an XML element.</summary>
		/// <param name="xmlElement" type="Element">An XML DOM element that will contain the item's data.</param>
		/// <param name="context" type="MindFusion.Diagramming.XmlPersistContext">An object providing contextual information about the serialization process and some helper serialization methods.</param>
	},
	scrollDown: function() {
		/// <summary>Scrolls the table's rows down.</summary>
	},
	scrollUp: function() {
		/// <summary>Scrolls the table's rows up.</summary>
	},
	setAllowResizeColumns: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to resize table columns.</summary>
		/// <param name="value" type="Boolean">true if users are allowed to resize table columns, otherwise false.</param>
	},
	setAllowResizeRows: function(value) {
		/// <summary>Sets a value indicating whether users are allowed to resize table rows.</summary>
		/// <param name="value" type="Boolean">true if users are allowed to resize table rows, otherwise false.</param>
	},
	setCaptionBackBrush: function(value) {
		/// <summary>Sets an object that specifies how to fill the caption bar.</summary>
		/// <param name="value" type="Object">A Brush object specifying the fill of the caption bar.</param>
	},
	setCaptionFont: function(value) {
		/// <summary>Sets the font used to render the table's caption text.</summary>
		/// <param name="value" type="MindFusion.Drawing.Font">An object specifying the font of the caption bar.</param>
	},
	setCaptionHeight: function(value) {
		/// <summary>Sets the height of the table's caption area.</summary>
		/// <param name="value" type="Number">A number specifying the height of the table caption. The default value is 6.</param>
	},
	setCellFrameStyle: function(value) {
		/// <summary>Sets the style of the cell frame lines.</summary>
		/// <param name="value" type="MindFusion.Diagramming.CellFrameStyle">A member of the CellFrameStyle enumeration.</param>
	},
	setColumnCount: function(value) {
		/// <summary>Sets the number of columns in the table.</summary>
		/// <param name="value" type="Number">the number of columns in the table.</param>
	},
	setConnectionStyle: function(value) {
		/// <summary>Sets a value indicating whether drawing a link from/to this table should connecta row of the table, or the whole table as an integral entity.</summary>
		/// <param name="value" type="MindFusion.Diagramming.ConnectionStyle">A member of the ConnectionStyle enumeration.</param>
	},
	setCurrentScrollRow: function(row) {
		/// <summary>Sets the table's current scroll position.</summary>
		/// <param name="row" type="Number">The index of the first row that should be visible in the table.</param>
	},
	setEnableStyledText: function(value) {
		/// <summary>Sets a value indicating whether styled text rendering is enabled.</summary>
		/// <param name="value" type="Boolean">true to parse the node's text in order to find formatting tags, or false otherwise.</param>
	},
	setRowCount: function(value) {
		/// <summary>Sets the number of rows in the table.</summary>
		/// <param name="value" type="Number">the number of rows in the table.</param>
	},
	setScrollable: function(value) {
		/// <summary>Sets a value indicating whether the user is allowed to scroll the table rows.</summary>
		/// <param name="value" type="Boolean">true if the table can be scrolled; otherwise, false.</param>
	},
	setShape: function(value) {
		/// <summary>Sets the shape of the table's outline.</summary>
		/// <param name="value" type="MindFusion.Diagramming.SimpleShape">A member of the SimpleShape enumeration.</param>
	},
};
MindFusion.Diagramming.TableNode.__class = true;

MindFusion.Diagramming.TableNode.With = function(diagram) {
	/// <summary>Returns a Builder object used to configure and create new TableNode instances.</summary>
	/// <param name="diagram" type="void"></param>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Diagramming.Theme.prototype = {
};
MindFusion.Diagramming.Theme.__class = true;

MindFusion.Diagramming.useScrollBars.prototype = {
};
MindFusion.Diagramming.useScrollBars.__class = true;

MindFusion.Diagramming.XmlPersistContext.prototype = {
	addChildElement: function(elementName, parentElement, innerText) {
		/// <summary>Adds a new child node with the specified name and value to the specified parent node.</summary>
		/// <param name="elementName" type="String">A string containing the name of new child element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="innerText" type="String" optional="true">Optional. Optional value to be added as child text node of the new element.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	readBool: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a Boolean value with the specified name.</summary>
		/// <param name="elementName" type="String">A string specifying the name of the Boolean XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="defaultValue" type="Boolean" optional="true">Optional. The default value to return if specified child XML element does not exist.</param>
		/// <returns type="Boolean">The value loaded from XML.</returns>
	},
	readBrush: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a Brush object with the specified name.</summary>
		/// <param name="elementName" type="String">A string specifying the name of the brush XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="defaultValue" type="Object" optional="true">Optional. The default brush to return if specified child XML element does not exist.</param>
		/// <returns type="Object">The brush object loaded from XML.</returns>
	},
	readFloat: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a floating-point number with the specified name.</summary>
		/// <param name="elementName" type="String">A string specifying the name of the number XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="defaultValue" type="Number" optional="true">Optional. The default number to return if specified child XML element does not exist.</param>
		/// <returns type="Number">The number loaded from XML.</returns>
	},
	readImage: function(elementName, parentElement) {
		/// <summary>Reads an image object with the specified name.</summary>
		/// <param name="elementName" type="String">A string specifying the name of the image XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="String">Base64-encoded image data loaded from XML.</returns>
	},
	readInt: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads an integer number with the specified name.</summary>
		/// <param name="elementName" type="String">A string specifying the name of the number XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="defaultValue" type="Number" optional="true">Optional. The default number to return if specified child XML element does not exist.</param>
		/// <returns type="Number">The number loaded from XML.</returns>
	},
	readString: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a string value with the specified name.</summary>
		/// <param name="elementName" type="String">The name of the string's XML element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <param name="defaultValue" type="Object" optional="true">Optional. The default string to return if specified child XML element does not exist.</param>
		/// <returns type="String">The string loaded from XML.</returns>
	},
	writeBool: function(boolValue, elementName, parentElement) {
		/// <summary>Writes a Boolean value with the specified name.</summary>
		/// <param name="boolValue" type="Boolean">The Boolean value that should be saved in current XML document.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	writeBrush: function(brush, elementName, parentElement) {
		/// <summary>Writes a reference to the specified brush. The brush is registered within the internal hashtable for subsequent serialization.</summary>
		/// <param name="brush" type="Object">The Brush object that should be saved in current XML document.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	writeFloat: function(floatValue, elementName, parentElement) {
		/// <summary>Writes a floating-point number with the specified name.</summary>
		/// <param name="floatValue" type="Number">The number that should be saved in current XML document.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	writeImage: function(image, elementName, parentElement) {
		/// <summary>Writes a reference to the specified image. The image is registered within the internal hashtable for subsequent serialization.</summary>
		/// <param name="image" type="String">Base64-encoded image data that should be saved in XML.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	writeInt: function(intValue, elementName, parentElement) {
		/// <summary>Writes an integer number with the specified name.</summary>
		/// <param name="intValue" type="Number">The number that should be saved in current XML document.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	},
	writeString: function(stringValue, elementName, parentElement) {
		/// <summary>Writes a string value with the specified name.</summary>
		/// <param name="stringValue" type="String">The string that should be saved in current XML document.</param>
		/// <param name="elementName" type="String">A string specifying the name of the new element.</param>
		/// <param name="parentElement" type="Element">The parent DOM Element object.</param>
		/// <returns type="Element">The newly created DOM Element object.</returns>
	}
};
MindFusion.Diagramming.XmlPersistContext.__class = true;

MindFusion.Gauges.Alignment = {
	/// <summary>Indicates an alignment of an object relative to the scale. In the descriptionsbelow 'outbound' refers to an element's outer outline, 'inbound' refers to anelement's inner outline and 'center' refers to en element's center, that is,the middle of the inbound and outbound.</summary>
	/// <field name="CenterInside">Specifies that the outbound of an object is aligned with the center of the scale.</field>
	/// <field name="CenterOutside">Specifies that the inbound of an object is aligned with the center of the scale.</field>
	/// <field name="InnerCenter">Specifies that the center of an object is aligned with the inbound of the scale.</field>
	/// <field name="InnerInside">Specifies that the outbound of an object is aligned with the inbound of the scale.</field>
	/// <field name="InnerOutside">Specifies that the inbound of an object is aligned with the inbound of the scale.</field>
	/// <field name="OuterCenter">Specifies that the center of an object is aligned with the outbound of the scale.</field>
	/// <field name="OuterInside">Specifies that the outbound of an object is aligned with the outbound of the scale.</field>
	/// <field name="OuterOutside">Specifies that the inbound of an object is aligned with the outbound of the scale.</field>
	/// <field name="TrueCenter">Specifies that the center of an object is aligned with the center of the scale.</field>
	CenterInside: 0,
	CenterOutside: 1,
	InnerCenter: 2,
	InnerInside: 3,
	InnerOutside: 4,
	OuterCenter: 5,
	OuterInside: 6,
	OuterOutside: 7,
	TrueCenter: 8
}
MindFusion.Gauges.Alignment.__enum = true;

MindFusion.Gauges.ArcArea.prototype = {
	getEndAngle: function() {
		/// <summary>Gets the end angle of the arc.</summary>
		/// <returns type="Number">The end angle of the arc.</returns>
	},
	getStartAngle: function() {
		/// <summary>Gets the start angle of the arc.</summary>
		/// <returns type="Number">The start angle of the arc.</returns>
	},
	setEndAngle: function(value) {
		/// <summary>Sets the end angle of the arc.</summary>
		/// <param name="value" type="Number">The end angle of the arc.</param>
	},
	setStartAngle: function(value) {
		/// <summary>Sets the start angle of the arc.</summary>
		/// <param name="value" type="Number">The start angle of the arc.</param>
	}
};
MindFusion.Gauges.ArcArea.__class = true;

MindFusion.Gauges.ArcSegment.prototype = {
	addTo: function(path, startPoint, isOutline) {
		/// <summary>Segment.addTo override.</summary>
		/// <param name="path" type="void"></param>
		/// <param name="startPoint" type="void"></param>
		/// <param name="isOutline" type="void"></param>
	},
	getIsCounterclockwise: function() {
		/// <summary>Gets a value that indicates whether the arc is drawn in counterclockwise or clockwise direction.</summary>
		/// <returns type="Boolean">True if the arc is drawn in counterclockwise, otherwise false.</returns>
	},
	getIsLargeArc: function() {
		/// <summary>Gets a value that indicates whether the arc should be greater than 180 degrees.</summary>
		/// <returns type="Boolean">True if the arc should be greater than 180 degrees, otherwise false.</returns>
	},
	getPoint: function() {
		/// <summary>Gets the endpoint of the elliptical arc.</summary>
		/// <returns type="Point">The endpoint of the elliptical arc.</returns>
	},
	getRotationAngle: function() {
		/// <summary>Gets the amount (in degrees) by which the ellipse is rotated about the x-axis.</summary>
		/// <returns type="Number">The amount (in degrees) by which the ellipse is rotated about the x-axis.</returns>
	},
	getSize: function() {
		/// <summary>Gets the x- and y-radius of the arc as a Size structure.</summary>
		/// <returns type="Size">The x- and y-radius of the arc as a Size structure.</returns>
	},
	setIsCounterclockwise: function(value) {
		/// <summary>Sets a value that indicates whether the arc is drawn in counterclockwise or clockwise direction.</summary>
		/// <param name="value" type="Boolean">True if the arc is drawn in counterclockwise, otherwise false.</param>
	},
	setIsLargeArc: function(value) {
		/// <summary>Sets a value that indicates whether the arc should be greater than 180 degrees.</summary>
		/// <param name="value" type="Boolean">True if the arc should be greater than 180 degrees, otherwise false.</param>
	},
	setPoint: function(value) {
		/// <summary>Sets the endpoint of the elliptical arc.</summary>
		/// <param name="value" type="Point">The endpoint of the elliptical arc.</param>
	},
	setRotationAngle: function(value) {
		/// <summary>Sets the amount (in degrees) by which the ellipse is rotated about the x-axis.</summary>
		/// <param name="value" type="Number">The amount (in degrees) by which the ellipse is rotated about the x-axis.</param>
	},
	setSize: function(value) {
		/// <summary>Sets the x- and y-radius of the arc as a Size structure.</summary>
		/// <param name="value" type="Size">The x- and y-radius of the arc as a Size structure.</param>
	}
};
MindFusion.Gauges.ArcSegment.__class = true;

MindFusion.Gauges.BaseGauge.prototype = {
	addEventListener: function(eventName, handler) {
		/// <summary>Registers a single event listener on the element.</summary>
		/// <param name="eventName" type="String">The name of the event. See a list of supported events here.</param>
		/// <param name="handler" type="Method">Represents the method that will handle the event specified with eventName.</param>
	},
	addScale: function(scale) {
		/// <summary>Adds a scale to the gauge.</summary>
		/// <param name="scale" type="MindFusion.Gauges.BaseScale">The scale to add.</param>
	},
	getAutoPostBack: function() {
		/// <summary>Gets a value indicating whether the control will post back to the server when a pointer's value has changed.</summary>
		/// <returns type="Boolean">true if the control should post back, otherwise, false.</returns>
	},
	getElementByName: function(name) {
		/// <summary>Returns the VisualElement object corresponding to the specified name.</summary>
		/// <param name="name" type="String">The name of the object to find.</param>
	},
	getLicenseLocation: function() {
		/// <summary>Gets the URL of the gauge's license file.</summary>
		/// <returns type="String">A valid URL string that specifies the location of the license key.</returns>
	},
	getScales: function() {
		/// <summary>Returns the array of all scales in this gauge.</summary>
		/// <returns type="Array">Array of all BaseScale instances in the gauge.</returns>
	},
	raiseEvent: function(eventName, args) {
		/// <summary>Raises an event.</summary>
		/// <param name="eventName" type="String">The name of the event to raise.</param>
		/// <param name="args" type="EventArgs">An instance of type EventArgs that holds data for the event specified with eventName.</param>
	},
	removeEventListener: function(eventName, handler) {
		/// <summary>Removes a single event listener attached to the element.</summary>
		/// <param name="eventName" type="String">The name of the event. See a list of supported events here.</param>
		/// <param name="handler" type="Method">Represents the method that handles the event specified with eventName.</param>
	},
	removeScale: function(scale) {
		/// <summary>Removes a scale from the gauge.</summary>
		/// <param name="scale" type="MindFusion.Gauges.BaseScale">The scale to remove.</param>
	},
	setAutoPostBack: function(value) {
		/// <summary>Sets a value indicating whether the control should post back to the server when a pointer's value has changed.</summary>
		/// <param name="value" type="Boolean">true if the control should post back, otherwise, false.</param>
	},
	setLicenseLocation: function(value) {
		/// <summary>Sets the URL of the gauge's license file.</summary>
		/// <param name="value" type="String">A valid URL string that specifies the location of the license key.</param>
	}
};
MindFusion.Gauges.BaseGauge.__class = true;

MindFusion.Gauges.BaseScale.prototype = {
	addPointer: function(pointer) {
		/// <summary>Adds a Pointer object to the pointers collection.</summary>
		/// <param name="pointer" type="Pointer">The pointer to add.</param>
	},
	addRange: function(range) {
		/// <summary>Adds a Range object to the ranges collection.</summary>
		/// <param name="range" type="Range">The ranges to add.</param>
	},
	getCustomFunction: function() {
		/// <summary>Gets the function to be used for distribution of values along the scale when functionType is set to Custom.</summary>
		/// <returns type="FunctionDelegate">The function to be used for distribution of values along the scale when functionType is set to Custom.</returns>
	},
	getEndWidth: function() {
		/// <summary>Gets the width of the scale at its end.</summary>
		/// <returns type="Length">The width of the scale at its end.</returns>
	},
	getFunctionArgument: function() {
		/// <summary>Gets the argument passed to custom functions.</summary>
		/// <returns type="Number">The argument passed to custom functions.</returns>
	},
	getFunctionType: function() {
		/// <summary>Gets the type of the function used to calculate the distribution of values along the scale.</summary>
		/// <returns type="FunctionType">The type of the function used to calculate the distribution of values along the scale.</returns>
	},
	getLogarithmBase: function() {
		/// <summary>Gets the logarithm base when FunctionType is set to Logarithmic.</summary>
		/// <returns type="Number">The logarithm base when functionType is set to Logarithmic.</returns>
	},
	getMajorTickSettings: function() {
		/// <summary>Gets the settings for the major ticks and their associated labels.</summary>
		/// <returns type="MajorTickSettings">The settings for the major ticks and their associated labels.</returns>
	},
	getMaxValue: function() {
		/// <summary>Gets the maximal value displayed by the scale.</summary>
		/// <returns type="Number">The maximal value displayed by the scale.</returns>
	},
	getMiddleTickSettings: function() {
		/// <summary>Gets the settings for the middle ticks and their associated labels.</summary>
		/// <returns type="MiddleTickSettings">The settings for the middle ticks and their associated labels.</returns>
	},
	getMinorTickSettings: function() {
		/// <summary>Gets the settings for the minor ticks and their associated labels.</summary>
		/// <returns type="MinorTickSettings">The settings for the minor ticks and their associated labels.</returns>
	},
	getMinValue: function() {
		/// <summary>Gets the minimal value displayed by the scale.</summary>
		/// <returns type="Number">The minimal value displayed by the scale.</returns>
	},
	getPointers: function() {
		/// <summary>Returns the array of all pointers in this scale.</summary>
		/// <returns type="Array">Array of all Pointer instances in the scale.</returns>
	},
	getRanges: function() {
		/// <summary>Returns the array of all ranges in this scale.</summary>
		/// <returns type="Array">Array of all Range instances in the scale.</returns>
	},
	getReversedCustomFunction: function() {
		/// <summary>Gets the reversed version of the function specified through customFunction.</summary>
		/// <returns type="FunctionDelegate">The reversed version of the function specified through CustomFunction.</returns>
	},
	getStartWidth: function() {
		/// <summary>Gets the width of the scale at its beginning.</summary>
		/// <returns type="Length">The width of the scale at its beginning.</returns>
	},
	removePointer: function(pointer) {
		/// <summary>Removes a Pointer object from the pointers collection.</summary>
		/// <param name="pointer" type="Pointer">The pointer to remove.</param>
	},
	removeRange: function(range) {
		/// <summary>Removes a Range object from the ranges collection.</summary>
		/// <param name="range" type="Range">The ranges to remove.</param>
	},
	setCustomFunction: function(value) {
		/// <summary>Sets the function to be used for distribution of values along the scale when functionType is set to Custom.</summary>
		/// <param name="value" type="FunctionDelegate">The function to be used for distribution of values along the scale when functionType is set to Custom.</param>
	},
	setEndWidth: function(value) {
		/// <summary>Sets the width of the scale at its end.</summary>
		/// <param name="value" type="Length">The width of the scale at its end.</param>
	},
	setFunctionArgument: function(value) {
		/// <summary>Sets the argument passed to custom functions.</summary>
		/// <param name="value" type="Number">The argument passed to custom functions.</param>
	},
	setFunctionType: function(value) {
		/// <summary>Sets the type of the function used to calculate the distribution of values along the scale.</summary>
		/// <param name="value" type="FunctionType">The type of the function used to calculate the distribution of values along the scale.</param>
	},
	setLogarithmBase: function(value) {
		/// <summary>Sets the logarithm base when FunctionType is set to Logarithmic.</summary>
		/// <param name="value" type="Number">The logarithm base when functionType is set to Logarithmic.</param>
	},
	setMaxValue: function(value) {
		/// <summary>Sets the maximal value displayed by the scale.</summary>
		/// <param name="value" type="Number">The maximal value displayed by the scale.</param>
	},
	setMinValue: function(value) {
		/// <summary>Sets the minimal value displayed by the scale.</summary>
		/// <param name="value" type="Number">The minimal value displayed by the scale.</param>
	},
	setReversedCustomFunction: function(value) {
		/// <summary>Sets the reversed version of the function specified through customFunction.</summary>
		/// <param name="value" type="FunctionDelegate">The reversed version of the function specified through CustomFunction.</param>
	},
	setStartWidth: function(value) {
		/// <summary>Sets the width of the scale at its beginning.</summary>
		/// <param name="value" type="Length">The width of the scale at its beginning.</param>
	}
};
MindFusion.Gauges.BaseScale.__class = true;

MindFusion.Gauges.CenterPanel.prototype = {
};
MindFusion.Gauges.CenterPanel.__class = true;

MindFusion.Gauges.CustomInterval.prototype = {
	contains: function(value) {
		/// <summary>Checks whether the specified value falls within this interval.</summary>
		/// <param name="value" type="void"></param>
	},
	getFill: function() {
		/// <summary>Gets the brush to apply as a background of the elements within the custom interval.</summary>
		/// <returns type="Object">The brush to apply as a background of the elements within the custom interval.</returns>
	},
	getForeground: function() {
		/// <summary>Gets the color to apply as a foreground to the elements within this custom interval.</summary>
		/// <returns type="Object">The color to apply as a foreground to the elements within this custom interval.</returns>
	},
	getMaxValue: function() {
		/// <summary>Gets the end of this custom interval.</summary>
		/// <returns type="Number">The end of this custom interval.</returns>
	},
	getMinValue: function() {
		/// <summary>Gets the start of this custom interval.</summary>
		/// <returns type="Number">The start of this custom interval.</returns>
	},
	getStroke: function() {
		/// <summary>Gets the brush to apply as an outline of the elements within the custom interval.</summary>
		/// <returns type="Object">The brush to apply as an outline of the elements within the custom interval.</returns>
	},
	setFill: function(value) {
		/// <summary>Sets the brush to apply as a background of the elements within the custom interval.</summary>
		/// <param name="value" type="Object">The brush to apply as a background of the elements within the custom interval.</param>
	},
	setForeground: function(value) {
		/// <summary>Sets the color to apply as a foreground to the elements within this custom interval.</summary>
		/// <param name="value" type="Object">The color to apply as a foreground to the elements within this custom interval.</param>
	},
	setMaxValue: function(value) {
		/// <summary>Sets the end of this custom interval.</summary>
		/// <param name="value" type="Number">The end of this custom interval.</param>
	},
	setMinValue: function(value) {
		/// <summary>Sets the start of this custom interval.</summary>
		/// <param name="value" type="Number">The start of this custom interval.</param>
	},
	setStroke: function(value) {
		/// <summary>Sets the brush to apply as an outline of the elements within the custom interval.</summary>
		/// <param name="value" type="Object">The brush to apply as an outline of the elements within the custom interval.</param>
	}
};
MindFusion.Gauges.CustomInterval.__class = true;

MindFusion.Gauges.DisplayType = {
	/// <summary>Specifies a display condition.</summary>
	/// <field name="Always">Indicates that the the element should always be displayed.</field>
	/// <field name="Auto">Indicates that the visibility of an element should be determined automatically.</field>
	/// <field name="Never">Indicates that the the element should always be hidden.</field>
	Always: 0,
	Auto: 1,
	Never: 2
}
MindFusion.Gauges.DisplayType.__enum = true;

MindFusion.Gauges.Ellipse.prototype = {
};
MindFusion.Gauges.Ellipse.__class = true;

MindFusion.Gauges.Events.prototype = {
};
MindFusion.Gauges.Events.__class = true;


MindFusion.Gauges.Events.controlLoaded = function() {
	/// <summary>Raised when the control is loaded.</summary>
};


MindFusion.Gauges.Events.paintBackground = function() {
	/// <summary>Raised when the gauge background is being painted.</summary>
};


MindFusion.Gauges.Events.paintForeground = function() {
	/// <summary>Raised when the gauge foreground is being painted.</summary>
};


MindFusion.Gauges.Events.paintPointer = function() {
	/// <summary>Raised when a gauge pointer is being painted.</summary>
};


MindFusion.Gauges.Events.paintScale = function() {
	/// <summary>Raised when a gauge scale is being painted.</summary>
};


MindFusion.Gauges.Events.paintTick = function() {
	/// <summary>Raised when a gauge tick is being painted.</summary>
};


MindFusion.Gauges.Events.prepaintBackground = function() {
	/// <summary>Raised before the gauge background is painted.</summary>
};


MindFusion.Gauges.Events.prepaintForeground = function() {
	/// <summary>Raised before the gauge foreground is painted.</summary>
};


MindFusion.Gauges.Events.prepaintPointer = function() {
	/// <summary>Raised before a gauge pointer is painted.</summary>
};


MindFusion.Gauges.Events.prepaintScale = function() {
	/// <summary>Raised before a gauge scale is painted.</summary>
};


MindFusion.Gauges.Events.prepaintTick = function() {
	/// <summary>Raised before a gauge tick is painted.</summary>
};


MindFusion.Gauges.Events.valueChanged = function() {
	/// <summary>Raised when the value of a pointer is being changed interactively.</summary>
};


MindFusion.Gauges.Events.valueChanging = function() {
	/// <summary>Raised when the value of a pointer has changed interactively.</summary>
};

MindFusion.Gauges.FunctionType = {
	/// <summary>Indicates the type of function that will be used to distribute values along the gauge scale.</summary>
	/// <field name="Custom">Specifies a user defined function, which will be supplied by the CustomFunction property.</field>
	/// <field name="Linear">Specifies that the values will be distributed linearly.</field>
	/// <field name="Logarithmic">Specifies a logarithmic function with base specified by the LogarithmBase property.</field>
	Custom: 0,
	Linear: 1,
	Logarithmic: 2
}
MindFusion.Gauges.FunctionType.__enum = true;

MindFusion.Gauges.GeometryFactory.prototype = {
};
MindFusion.Gauges.GeometryFactory.__class = true;

MindFusion.Gauges.GeometryFactory.createLinearGeometry = function(centerX, centerY, startInnerOffset, startOuterOffset, endInnerOffset, endOuterOffset, length, isVertical, capStart, capEnd, strokeInner, strokeOuter) {
	/// <summary>Generates a linear bar geometry with the specified parameters.</summary>
	/// <param name="centerX" type="Number">The x-coordinate of the generated geometry.</param>
	/// <param name="centerY" type="Number">The y-coordinate of the generated geometry.</param>
	/// <param name="startInnerOffset" type="Number">The start inner offset of the generated geometry relative to the specified center.</param>
	/// <param name="startOuterOffset" type="Number">The start outer offset of the generated geometry relative to the specified center.</param>
	/// <param name="endInnerOffset" type="Number">The end inner offset of the generated geometry relative to the specified center.</param>
	/// <param name="endOuterOffset" type="Number">The end outer offset of the generated geometry relative to the specified center.</param>
	/// <param name="length" type="Number">The length of the generated geometry.</param>
	/// <param name="isVertical" type="Boolean">A flag indicating whether the generated geometry is vertical.</param>
	/// <param name="capStart" type="Boolean">A flag indicating whether to draw a stroke at the start of the bar.</param>
	/// <param name="capEnd" type="Boolean">A flag indicating whether to draw a stroke at the end of the bar.</param>
	/// <param name="strokeInner" type="Boolean">A flag indicating whether to draw a stroke at the inner side of the bar.</param>
	/// <param name="strokeOuter" type="Boolean">A flag indicating whether to draw a stroke at the outer side of the bar.</param>
	/// <returns type="PathFigure">A PathFigure representing a linear bar with the specified parameters.</returns>
};
MindFusion.Gauges.GeometryFactory.createRadialGeometry = function(centerX, centerY, startInnerRadius, startOuterRadius, endInnerRadius, endOuterRadius, startAngle, endAngle, capStart, capEnd, strokeInner, strokeOuter) {
	/// <summary>Generates a radial bar geometry with the specified parameters.</summary>
	/// <param name="centerX" type="Number">The x-coordinate of the generated geometry.</param>
	/// <param name="centerY" type="Number">The y-coordinate of the generated geometry.</param>
	/// <param name="startInnerRadius" type="Number">The radius of the start point of the inner outline of the bar.</param>
	/// <param name="startOuterRadius" type="Number">The radius of the start point of the outer outline of the bar.</param>
	/// <param name="endInnerRadius" type="Number">The radius of the end point of the inner outline of the bar.</param>
	/// <param name="endOuterRadius" type="Number">The radius of the end point of the outer outline of the bar.</param>
	/// <param name="startAngle" type="Number">The start angle of the radial bar.</param>
	/// <param name="endAngle" type="Number">The end angle of the radial bar.</param>
	/// <param name="capStart" type="Boolean">A flag indicating whether to draw a stroke at the start of the bar.</param>
	/// <param name="capEnd" type="Boolean">A flag indicating whether to draw a stroke at the end of the bar.</param>
	/// <param name="strokeInner" type="Boolean">A flag indicating whether to draw a stroke at the inner curve of the bar.</param>
	/// <param name="strokeOuter" type="Boolean">A flag indicating whether to draw a stroke at the outer curve of the bar.</param>
	/// <returns type="PathFigure">A PathFigure representing a radial bar with the specified parameters.</returns>
};

MindFusion.Gauges.LabelRotation = {
	/// <summary>Indicates the rotation of a label within a scale.</summary>
	/// <field name="Auto">Specifies that the labels are automatically rotated so that their baseline always points downwards.</field>
	/// <field name="BaselineAwayFromCenter">Specifies that the labels are rotated so that their baseline points away from the center of the scale.</field>
	/// <field name="BaselineToCenter">Specifies that the labels are rotated so that their baseline points towards the center of the scale.</field>
	/// <field name="None">Specifies no rotation.</field>
	/// <field name="Sideways">Specifies that the labels are aligned sideways to the scale.</field>
	Auto: 0,
	BaselineAwayFromCenter: 1,
	BaselineToCenter: 2,
	None: 3,
	Sideways: 4
}
MindFusion.Gauges.LabelRotation.__enum = true;

MindFusion.Gauges.Length.prototype = {
	getAbsoluteLength: function(space) {
		/// <summary>Calculates the absolute length corresponding to the specified argument, relative to the the specified area.</summary>
		/// <param name="space" type="void"></param>
	},
	getType: function() {
		/// <summary>Gets the type of this length.</summary>
		/// <returns type="LengthType">The type of this length.</returns>
	},
	getValue: function() {
		/// <summary>Gets the value representing this length.</summary>
		/// <returns type="Number">The value representing this length.</returns>
	},
	setType: function(value) {
		/// <summary>Sets the type of this length.</summary>
		/// <param name="value" type="LengthType">The type of this length.</param>
	},
	setValue: function(value) {
		/// <summary>Sets the value representing this length.</summary>
		/// <param name="value" type="Number">The value representing this length.</param>
	}
};
MindFusion.Gauges.Length.__class = true;

MindFusion.Gauges.LengthType = {
	/// <summary>Indicates the type of the units of a Length object.</summary>
	/// <field name="Absolute">Specifies absolute length, expressed in pixels.</field>
	/// <field name="Relative">Specifies relative length, expressed as a percentage of the container's size.</field>
	Absolute: 0,
	Relative: 1
}
MindFusion.Gauges.LengthType.__enum = true;

MindFusion.Gauges.LinearGauge.prototype = {
	getOrientation: function() {
		/// <summary>Gets the orientation of the gauge.</summary>
		/// <returns type="Orientation">The orientation of the gauge.</returns>
	},
	setOrientation: function(value) {
		/// <summary>Sets the orientation of the gauge.</summary>
		/// <param name="value" type="Orientation">The orientation of the gauge.</param>
	}
};
MindFusion.Gauges.LinearGauge.__class = true;

MindFusion.Gauges.LinearGauge.create = function(element) {
	/// <summary>Creates and initializes a new LinearGauge from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the LinearGauge should be attached to.</param>
	/// <returns type="MindFusion.Gauges.LinearGauge">A LinearGauge object that represents the newly created gauge.</returns>
};
MindFusion.Gauges.LinearGauge.find = function(id, parent) {
	/// <summary>Returns the specified LinearGauge object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the LinearGauge to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the LinearGauge to find.</param>
	/// <returns type="MindFusion.Gauges.LinearGauge">A LinearGauge object that contains the gauge requested by id, if found; otherwise, null.</returns>
};

MindFusion.Gauges.LinearScale.prototype = {
	getLeft: function() {
		/// <summary>Gets the distance between the left of this scale and the left of its container.</summary>
		/// <returns type="Length">The distance between the left of this scale and the left of its container.</returns>
	},
	getOrientation: function() {
		/// <summary>Gets the orientation of the scale.</summary>
		/// <returns type="Orientation">The orientation of the scale.</returns>
	},
	getScaleAlignment: function() {
		/// <summary>Gets the alignment of the scale.</summary>
		/// <returns type="Alignment">The alignment of the scale.</returns>
	},
	getScaleLength: function() {
		/// <summary>Gets the length of the scale.</summary>
		/// <returns type="Length">The length of the scale.</returns>
	},
	getTop: function() {
		/// <summary>Gets the distance between the top of this scale and the top of its container.</summary>
		/// <returns type="Length">The distance between the top of this scale and the top of its container.</returns>
	},
	getValueFromPoint: function(point) {
		/// <summary>BaseScale.getValueFromPoint override.</summary>
		/// <param name="point" type="Point">The point to test.</param>
		/// <returns type="Number">The value from the scale, corresponding to the point, possibly MinValue orMaxValue if the specified point cannot be associated with a value.</returns>
	},
	setLeft: function(value) {
		/// <summary>Sets the distance between the left of this scale and the left of its container.</summary>
		/// <param name="value" type="Length">The distance between the left of this scale and the left of its container.</param>
	},
	setOrientation: function(value) {
		/// <summary>Sets the orientation of the scale.</summary>
		/// <param name="value" type="Orientation">The orientation of the scale.</param>
	},
	setScaleAlignment: function(value) {
		/// <summary>Sets the alignment of the scale.</summary>
		/// <param name="value" type="Alignment">The alignment of the scale.</param>
	},
	setScaleLength: function(value) {
		/// <summary>Sets the length of the scale.</summary>
		/// <param name="value" type="Length">The length of the scale.</param>
	},
	setTop: function(value) {
		/// <summary>Sets the distance between the top of this scale and the top of its container.</summary>
		/// <param name="value" type="Length">The distance between the top of this scale and the top of its container.</param>
	}
};
MindFusion.Gauges.LinearScale.__class = true;

MindFusion.Gauges.LineSegment.prototype = {
	addTo: function(path, startPoint, isOutline) {
		/// <summary>Segment.addTo override.</summary>
		/// <param name="path" type="void"></param>
		/// <param name="startPoint" type="void"></param>
		/// <param name="isOutline" type="void"></param>
	},
	getPoint: function() {
		/// <summary>Gets the end point of the line segment.</summary>
		/// <returns type="Point">The end point of the line segment.</returns>
	},
	setPoint: function(value) {
		/// <summary>Sets the end point of the line segment.</summary>
		/// <param name="value" type="Point">The end point of the line segment.</param>
	}
};
MindFusion.Gauges.LineSegment.__class = true;

MindFusion.Gauges.MajorTickSettings.prototype = {
};
MindFusion.Gauges.MajorTickSettings.__class = true;

MindFusion.Gauges.MiddleTickSettings.prototype = {
};
MindFusion.Gauges.MiddleTickSettings.__class = true;

MindFusion.Gauges.MinorTickSettings.prototype = {
};
MindFusion.Gauges.MinorTickSettings.__class = true;

MindFusion.Gauges.MouseAction = {
	/// <summary>Specifies an action performed with the mouse.</summary>
	/// <field name="Down">Indicates the press of a mouse button.</field>
	/// <field name="Move">Indicates the move of a mouse.</field>
	/// <field name="Up">Indicates the release of a mouse button.</field>
	Down: 0,
	Move: 1,
	Up: 2
}
MindFusion.Gauges.MouseAction.__enum = true;

MindFusion.Gauges.MouseInfo.prototype = {
	getAction: function() {
		/// <summary>Gets the action that was performed.</summary>
		/// <returns type="MouseAction">The action that was performed.</returns>
	},
	getPoint: function() {
		/// <summary>Gets the mouse location.</summary>
		/// <returns type="Point">The mouse location.</returns>
	}
};
MindFusion.Gauges.MouseInfo.__class = true;

MindFusion.Gauges.Orientation = {
	/// <summary>Specifies the orientation of elements.</summary>
	/// <field name="Horizontal">The element is oriented horizontally.</field>
	/// <field name="Vertical">The element is oriented vertically.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.Gauges.Orientation.__enum = true;

MindFusion.Gauges.OvalGauge.prototype = {
	getStyle: function() {
		/// <summary>Gets the visual style of the gauge.</summary>
		/// <returns type="OvalGaugeStyle">The visual style of the gauge.</returns>
	},
	setStyle: function(value) {
		/// <summary>Sets the visual style of the gauge.</summary>
		/// <param name="value" type="OvalGaugeStyle">The visual style of the gauge.</param>
	}
};
MindFusion.Gauges.OvalGauge.__class = true;

MindFusion.Gauges.OvalGauge.create = function(element) {
	/// <summary>Creates and initializes a new OvalGauge from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the OvalGauge should be attached to.</param>
	/// <returns type="MindFusion.Gauges.OvalGauge">A OvalGauge object that represents the newly created gauge.</returns>
};
MindFusion.Gauges.OvalGauge.find = function(id, parent) {
	/// <summary>Returns the specified OvalGauge object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the OvalGauge to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the OvalGauge to find.</param>
	/// <returns type="MindFusion.Gauges.OvalGauge">A OvalGauge object that contains the gauge requested by id, if found; otherwise, null.</returns>
};

MindFusion.Gauges.OvalGaugeStyle = {
	/// <summary>Specifies the appearance of an oval gauge.</summary>
	/// <field name="Circular">Indicates a regular circular appearance.</field>
	/// <field name="QuadraticNE">Indicates a quadratic appearance with the scales oriented towards North-East.</field>
	/// <field name="QuadraticNW">Indicates a quadratic appearance with the scales oriented towards North-West.</field>
	/// <field name="QuadraticSE">Indicates a quadratic appearance with the scales oriented towards South-East.</field>
	/// <field name="QuadraticSW">Indicates a quadratic appearance with the scales oriented towards South-West.</field>
	/// <field name="SemicircleE">Indicates a semi-circular appearance with the scales oriented towards East.</field>
	/// <field name="SemicircleN">Indicates a semi-circular appearance with the scales oriented towards North.</field>
	/// <field name="SemicircleS">Indicates a semi-circular appearance with the scales oriented towards South.</field>
	/// <field name="SemicircleW">Indicates a semi-circular appearance with the scales oriented towards West.</field>
	Circular: 0,
	QuadraticNE: 1,
	QuadraticNW: 2,
	QuadraticSE: 3,
	QuadraticSW: 4,
	SemicircleE: 5,
	SemicircleN: 6,
	SemicircleS: 7,
	SemicircleW: 8
}
MindFusion.Gauges.OvalGaugeStyle.__enum = true;

MindFusion.Gauges.OvalScale.prototype = {
	getEndAngle: function() {
		/// <summary>Gets the end angle of the scale.</summary>
		/// <returns type="Number">The end angle of the scale.</returns>
	},
	getScaleRelativeCenter: function() {
		/// <summary>Gets the center of the scale relative to the scale bounds.</summary>
		/// <returns type="Point">The center of the scale relative to the scale bounds.</returns>
	},
	getScaleRelativeRadius: function() {
		/// <summary>Gets the radius of the scale relative to the scale bounds.</summary>
		/// <returns type="Number">The radius of the scale relative to the scale bounds.</returns>
	},
	getStartAngle: function() {
		/// <summary>Gets the start angle of the scale.</summary>
		/// <returns type="Number">The start angle of the scale.</returns>
	},
	getValueFromPoint: function(point) {
		/// <summary>BaseScale.getValueFromPoint override.</summary>
		/// <param name="point" type="Point">The point to test.</param>
		/// <returns type="Number">The value from the scale, corresponding to the point, possibly MinValue orMaxValue if the specified point cannot be associated with a value.</returns>
	},
	setEndAngle: function(value) {
		/// <summary>Sets the end angle of the scale.</summary>
		/// <param name="value" type="Number">The end angle of the scale.</param>
	},
	setScaleRelativeCenter: function(value) {
		/// <summary>Sets the center of the scale relative to the scale bounds.</summary>
		/// <param name="value" type="Point">The center of the scale relative to the scale bounds.</param>
	},
	setScaleRelativeRadius: function(value) {
		/// <summary>Sets the radius of the scale relative to the scale bounds.</summary>
		/// <param name="value" type="Number">The radius of the scale relative to the scale bounds.</param>
	},
	setStartAngle: function(value) {
		/// <summary>Sets the start angle of the scale.</summary>
		/// <param name="value" type="Number">The start angle of the scale.</param>
	}
};
MindFusion.Gauges.OvalScale.__class = true;

MindFusion.Gauges.PaintEventArgs.prototype = {
	getContext: function() {
		/// <summary>Gets the canvas rendering context.</summary>
		/// <returns type="CanvasRenderingContext2D">A rendering context used to draw on the Canvas element.</returns>
	},
	getElement: function() {
		/// <summary>Gets the element being custom drawn.</summary>
		/// <returns type="VisualElement">A VisualElement instance.</returns>
	},
	paintVisualElement: function(element, constraint) {
		/// <summary>Paints the specified visual element to the underlying canvas.</summary>
		/// <param name="element" type="VisualElement">The VisualElement to paint.</param>
		/// <param name="constraint" type="Size">The available size.</param>
	},
	setElement: function(value) {
		/// <summary>Sets the element being custom drawn.</summary>
		/// <param name="value" type="VisualElement">A VisualElement instance.</param>
	}
};
MindFusion.Gauges.PaintEventArgs.__class = true;

MindFusion.Gauges.PathFigure.prototype = {
};
MindFusion.Gauges.PathFigure.__class = true;

MindFusion.Gauges.Pointer.prototype = {
	getAlignment: function() {
		/// <summary>Gets the alignment of the pointer relative to the scale.</summary>
		/// <returns type="Alignment">The alignment of the pointer relative to the scale.</returns>
	},
	getCustomShape: function() {
		/// <summary>Gets the definition of the pointer shape when Shape is set to Custom.</summary>
		/// <returns type="String">The definition of the pointer shape when Shape is set to Custom.</returns>
	},
	getIsDiscrete: function() {
		/// <summary>Gets a value indicating whether the pointer value can be changed only discretely(the pointer Value can be only integer).</summary>
		/// <returns type="Boolean">True if the pointer is discrete, otherwise false.</returns>
	},
	getIsInteractive: function() {
		/// <summary>Gets a value indicating whether the pointer position should be affected by user interactions.</summary>
		/// <returns type="Boolean">True if the pointer is interactive, otherwise false.</returns>
	},
	getPointerHeight: function() {
		/// <summary>Gets the height of the pointer.</summary>
		/// <returns type="Length">The height of the pointer.</returns>
	},
	getPointerOffset: function() {
		/// <summary>Gets the offset of the pointer along the direction it points to.</summary>
		/// <returns type="Length">The offset of the pointer along the direction it points to.</returns>
	},
	getPointerWidth: function() {
		/// <summary>Gets the width of the pointer.</summary>
		/// <returns type="Length">The width of the pointer.</returns>
	},
	getShape: function() {
		/// <summary>Gets the shape of the pointer.</summary>
		/// <returns type="PointerShape">The shape of the pointer.</returns>
	},
	getValue: function() {
		/// <summary>Gets the value this pointer points to.</summary>
		/// <returns type="Number">The value this pointer points to.</returns>
	},
	setAlignment: function(value) {
		/// <summary>Sets the alignment of the pointer relative to the scale.</summary>
		/// <param name="value" type="Alignment">The alignment of the pointer relative to the scale.</param>
	},
	setCustomShape: function(value) {
		/// <summary>Sets the definition of the pointer shape when Shape is set to Custom.</summary>
		/// <param name="value" type="String">The definition of the pointer shape when Shape is set to Custom.</param>
	},
	setIsDiscrete: function(value) {
		/// <summary>Sets a value indicating whether the pointer value can be changed only discretely(the pointer Value can be only integer).</summary>
		/// <param name="value" type="Boolean">True if the pointer is discrete, otherwise false.</param>
	},
	setIsInteractive: function(value) {
		/// <summary>Sets a value indicating whether the pointer position should be affected by user interactions.</summary>
		/// <param name="value" type="Boolean">True if the pointer is interactive, otherwise false.</param>
	},
	setPointerHeight: function(value) {
		/// <summary>Sets the height of the pointer.</summary>
		/// <param name="value" type="Length">The height of the pointer.</param>
	},
	setPointerOffset: function(value) {
		/// <summary>Sets the offset of the pointer along the direction it points to.</summary>
		/// <param name="value" type="Length">The offset of the pointer along the direction it points to.</param>
	},
	setPointerWidth: function(value) {
		/// <summary>Sets the width of the pointer.</summary>
		/// <param name="value" type="Length">The width of the pointer.</param>
	},
	setShape: function(value) {
		/// <summary>Sets the shape of the pointer.</summary>
		/// <param name="value" type="PointerShape">The shape of the pointer.</param>
	},
	setValue: function(value) {
		/// <summary>Sets the value this pointer points to.</summary>
		/// <param name="value" type="Number">The value this pointer points to.</param>
	}
};
MindFusion.Gauges.Pointer.__class = true;

MindFusion.Gauges.pointers.prototype = {
};
MindFusion.Gauges.pointers.__class = true;

MindFusion.Gauges.PointerShape = {
	/// <summary>Indicates the shape of a pointer.</summary>
	/// <field name="Custom">Specifies a custom shape.</field>
	/// <field name="Ellipse">Specifies an elliptical shape.</field>
	/// <field name="Needle">Specifies a sharp pointer with a circle at its base.</field>
	/// <field name="Needle2"></field>
	/// <field name="None">Specifies an empty shape, that is, the pointer is not displayed.</field>
	/// <field name="Rectangle">Specifies a rectangular shape.</field>
	Custom: 0,
	Ellipse: 1,
	Needle: 2,
	Needle2: 3,
	None: 4,
	Rectangle: 5
}
MindFusion.Gauges.PointerShape.__enum = true;

MindFusion.Gauges.PrepaintEventArgs.prototype = {
	getCancelDefaultPainting: function() {
		/// <summary>Gets a value indicating whether the default painting of this element should be performed.</summary>
		/// <returns type="Boolean">true if the default painting of this element should be performed; otherwise, false.</returns>
	},
	setCancelDefaultPainting: function(value) {
		/// <summary>Sets a value indicating whether the default painting of this element should be performed.</summary>
		/// <param name="value" type="Boolean">true if the default painting of this element should be performed; otherwise, false.</param>
	}
};
MindFusion.Gauges.PrepaintEventArgs.__class = true;

MindFusion.Gauges.Range.prototype = {
	getAlignment: function() {
		/// <summary>Gets the alignment of this range relative to the scale it is associated with.</summary>
		/// <returns type="Alignment">The alignment of this range relative to the scale it is associated with.</returns>
	},
	getAutoSize: function() {
		/// <summary>Gets a value indicating whether the start and end width of the range will be automatically adjusted to match the width of the scale.</summary>
		/// <returns type="Boolean">True if the range is autosized, otherwise false.</returns>
	},
	getCapEnd: function() {
		/// <summary>Gets a value indicating whether to draw a stroke in the end of this range.</summary>
		/// <returns type="Boolean">True if there should be a stroke in the end of this range, otherwise false.</returns>
	},
	getCapStart: function() {
		/// <summary>Gets a value indicating whether to draw a stroke in the beginning of this range.</summary>
		/// <returns type="Boolean">True if there should be a stroke in the beginning of this range, otherwise false.</returns>
	},
	getEndWidth: function() {
		/// <summary>Gets the width of this range at its end.</summary>
		/// <returns type="Length">The width of this range at its end.</returns>
	},
	getMaxValue: function() {
		/// <summary>Gets the end value of this range.</summary>
		/// <returns type="Number">The end value of this range.</returns>
	},
	getMinValue: function() {
		/// <summary>Gets the start value of this range.</summary>
		/// <returns type="Number">The start value of this range.</returns>
	},
	getOffset: function() {
		/// <summary>Gets the offset of the range from the position calculated according to its alignment.</summary>
		/// <returns type="Length">The offset of the range from the position calculated according to its alignment.</returns>
	},
	getStartWidth: function() {
		/// <summary>Gets the width of this range at its start.</summary>
		/// <returns type="Length">The width of this range at its start.</returns>
	},
	getStrokeInside: function() {
		/// <summary>Gets a value indicating whether to draw a stroke at the inside of this range.</summary>
		/// <returns type="Boolean">True if there should be a stroke at the inside of this range, otherwise false.</returns>
	},
	getStrokeOutside: function() {
		/// <summary>Gets a value indicating whether to draw a stroke at the outside of this range.</summary>
		/// <returns type="Boolean">True if there should be a stroke at the outside of this range, otherwise false.</returns>
	},
	setAlignment: function(value) {
		/// <summary>Sets the alignment of this range relative to the scale it is associated with.</summary>
		/// <param name="value" type="Alignment">The alignment of this range relative to the scale it is associated with.</param>
	},
	setAutoSize: function(value) {
		/// <summary>Sets a value indicating whether the start and end width of the range will be automatically adjusted to match the width of the scale.</summary>
		/// <param name="value" type="Boolean">True if the range is autosized, otherwise false.</param>
	},
	setCapEnd: function(value) {
		/// <summary>Sets a value indicating whether to draw a stroke in the end of this range.</summary>
		/// <param name="value" type="Boolean">True if there should be a stroke in the end of this range, otherwise false.</param>
	},
	setCapStart: function(value) {
		/// <summary>Sets a value indicating whether to draw a stroke in the beginning of this range.</summary>
		/// <param name="value" type="Boolean">True if there should be a stroke in the beginning of this range, otherwise false.</param>
	},
	setEndWidth: function(value) {
		/// <summary>Sets the width of this range at its end.</summary>
		/// <param name="value" type="Length">The width of this range at its end.</param>
	},
	setMaxValue: function(value) {
		/// <summary>Sets the end value of this range.</summary>
		/// <param name="value" type="Number">The end value of this range.</param>
	},
	setMinValue: function(value) {
		/// <summary>Sets the start value of this range.</summary>
		/// <param name="value" type="Number">The start value of this range.</param>
	},
	setOffset: function(value) {
		/// <summary>Sets the offset of the range from the position calculated according to its alignment.</summary>
		/// <param name="value" type="Length">The offset of the range from the position calculated according to its alignment.</param>
	},
	setStartWidth: function(value) {
		/// <summary>Sets the width of this range at its start.</summary>
		/// <param name="value" type="Length">The width of this range at its start.</param>
	},
	setStrokeInside: function(value) {
		/// <summary>Sets a value indicating whether to draw a stroke at the inside of this range.</summary>
		/// <param name="value" type="Boolean">True if there should be a stroke at the inside of this range, otherwise false.</param>
	},
	setStrokeOutside: function(value) {
		/// <summary>Sets a value indicating whether to draw a stroke at the outside of this range.</summary>
		/// <param name="value" type="Boolean">True if there should be a stroke at the outside of this range, otherwise false.</param>
	}
};
MindFusion.Gauges.Range.__class = true;

MindFusion.Gauges.ranges.prototype = {
};
MindFusion.Gauges.ranges.__class = true;

MindFusion.Gauges.RoundRectangle.prototype = {
	getRoundness: function() {
		/// <summary>Gets the relative roundness of this rectangle's corners.</summary>
		/// <returns type="Number">The relative roundness of this rectangle's corners.</returns>
	},
	setRoundness: function(value) {
		/// <summary>Sets the relative roundness of this rectangle's corners.</summary>
		/// <param name="value" type="Number">The relative roundness of this rectangle's corners.</param>
	}
};
MindFusion.Gauges.RoundRectangle.__class = true;

MindFusion.Gauges.scales.prototype = {
};
MindFusion.Gauges.scales.__class = true;

MindFusion.Gauges.Segment.prototype = {
	addTo: function(path, startPoint, isOutline) {
		/// <summary>Adds the segment to the specified graphics path.</summary>
		/// <param name="path" type="void"></param>
		/// <param name="startPoint" type="void"></param>
		/// <param name="isOutline" type="void"></param>
	},
	getIsStroked: function() {
		/// <summary>Gets a value that indicates whether the segment is stroked.</summary>
		/// <returns type="Boolean">True if the segment is stroked, otherwise false.</returns>
	},
	setIsStroked: function(value) {
		/// <summary>Sets a value that indicates whether the segment is stroked.</summary>
		/// <param name="value" type="Boolean">True if the segment is stroked, otherwise false.</param>
	}
};
MindFusion.Gauges.Segment.__class = true;

MindFusion.Gauges.Thickness.prototype = {
	apply: function(rect) {
		/// <summary>Applies the current thickness to the specified rectangle by deflating the rectangle.</summary>
		/// <param name="rect" type="Rect">The rectangle to deflate.</param>
		/// <returns type="Rect">The modified rectangle.</returns>
	},
	getBottom: function() {
		/// <summary>Gets the width of the bottom side of the frame.</summary>
		/// <returns type="Number">The width of the bottom side of the frame.</returns>
	},
	getIsRelative: function() {
		/// <summary>Gets a flag indicating whether the thickness properties are expressed as relative or absolute quantities.</summary>
		/// <returns type="Boolean">True if the thickness is relative, otherwise false.</returns>
	},
	getLeft: function() {
		/// <summary>Gets the width of the left side of the frame.</summary>
		/// <returns type="Number">The width of the left side of the frame.</returns>
	},
	getRight: function() {
		/// <summary>Gets the width of the right side of the frame.</summary>
		/// <returns type="Number">The width of the right side of the frame.</returns>
	},
	getTop: function() {
		/// <summary>Gets the width of the top side of the frame.</summary>
		/// <returns type="Number">The width of the top side of the frame.</returns>
	},
	setBottom: function(value) {
		/// <summary>Sets the width of the top bottom of the frame.</summary>
		/// <param name="value" type="Number">The width of the bottom side of the frame.</param>
	},
	setIsRelative: function(value) {
		/// <summary>Sets a flag indicating whether the thickness properties are expressed as relative or absolute quantities.</summary>
		/// <param name="value" type="Boolean">True if the thickness is relative, otherwise false.</param>
	},
	setLeft: function(value) {
		/// <summary>Sets the width of the left side of the frame.</summary>
		/// <param name="value" type="Number">The width of the left side of the frame.</param>
	},
	setRight: function(value) {
		/// <summary>Sets the width of the right side of the frame.</summary>
		/// <param name="value" type="Number">The width of the right side of the frame.</param>
	},
	setTop: function(value) {
		/// <summary>Sets the width of the top side of the frame.</summary>
		/// <param name="value" type="Number">The width of the top side of the frame.</param>
	},
	toAbsolute: function(size) {
		/// <summary>Converts the current thickness to absolute value relative to the specified size.</summary>
		/// <param name="size" type="void"></param>
	}
};
MindFusion.Gauges.Thickness.__class = true;

MindFusion.Gauges.Tick.prototype = {
	getRawValue: function() {
		/// <summary>Gets the value associated with this tick before it was processed by any value distribution functions.</summary>
		/// <returns type="Number">The value associated with this tick before it was processed by any value distribution functions.</returns>
	},
	getSettings: function() {
		/// <summary>Gets the TickSettings object associated with this tick.</summary>
		/// <returns type="TickSettings">The TickSettings object associated with this tick.</returns>
	},
	getValue: function() {
		/// <summary>Gets the value associated with this tick.</summary>
		/// <returns type="Number">The value associated with this tick.</returns>
	}
};
MindFusion.Gauges.Tick.__class = true;

MindFusion.Gauges.TickLabel.prototype = {
	getForeground: function() {
		/// <summary>Gets the foreground color of this label.</summary>
		/// <returns type="Color">The foreground color of this label.</returns>
	},
	getRawValue: function() {
		/// <summary>Gets the value associated with this tick before it was processed by any value distribution functions.</summary>
		/// <returns type="Number">The value associated with this tick before it was processed by any value distribution functions.</returns>
	},
	getSettings: function() {
		/// <summary>Gets the TickSettings object associated with this label.</summary>
		/// <returns type="TickSettings">The TickSettings object associated with this label.</returns>
	},
	getValue: function() {
		/// <summary>Gets the value associated with this label.</summary>
		/// <returns type="Number">The value associated with this label.</returns>
	}
};
MindFusion.Gauges.TickLabel.__class = true;

MindFusion.Gauges.TickSettings.prototype = {
	addCustomInterval: function(interval) {
		/// <summary>Adds a CustomInterval object to these settings' customIntervals collection.</summary>
		/// <param name="interval" type="CustomInterval">The interval to add.</param>
	},
	getCount: function() {
		/// <summary>Gets the number of ticks and labels.</summary>
		/// <returns type="Number">The number of ticks and labels.</returns>
	},
	getCustomIntervals: function() {
		/// <summary>Gets an array of CustomInterval objects, which can be used to customize the appearance of the ticks in a particular interval.</summary>
		/// <returns type="Array">An array of CustomInterval objects, which can be used to customize the appearance of the ticks in a particular interval.</returns>
	},
	getFill: function() {
		/// <summary>Gets the fill brush of the ticks.</summary>
		/// <returns type="Object">The fill brush of the ticks.</returns>
	},
	getFontFamily: function() {
		/// <summary>Gets the font family of the labels.</summary>
		/// <returns type="String">The font family of the labels.</returns>
	},
	getFontSize: function() {
		/// <summary>Gets the font size of the labels.</summary>
		/// <returns type="Length">The font size of the labels.</returns>
	},
	getFontStyle: function() {
		/// <summary>Gets the font style of the labels.</summary>
		/// <returns type="String">The font style of the labels.</returns>
	},
	getLabelAlignment: function() {
		/// <summary>Gets the alignment of the labels relative to the scale.</summary>
		/// <returns type="Alignment">The alignment of the labels relative to the scale.</returns>
	},
	getLabelForeground: function() {
		/// <summary>Gets the brush used to paint label texts.</summary>
		/// <returns type="Object">The brush used to paint label texts.</returns>
	},
	getLabelOffset: function() {
		/// <summary>Gets the offset of the labels relative to their calculated position.</summary>
		/// <returns type="Length">The offset of the labels relative to their calculated position.</returns>
	},
	getLabelRotation: function() {
		/// <summary>Gets the rotation mode of the labels.</summary>
		/// <returns type="LabelRotation">The rotation mode of the labels.</returns>
	},
	getNumberPrecision: function() {
		/// <summary>Gets the number recision of the labels.</summary>
		/// <returns type="Number">The number recision of the labels.</returns>
	},
	getShowLabels: function() {
		/// <summary>Gets a value indicating whether the labels are visible.</summary>
		/// <returns type="Boolean">True if labels are visible, otherwise false.</returns>
	},
	getShowMaxValueTick: function() {
		/// <summary>Gets a value indicating whether to display a tick for the maxValue of the scale.</summary>
		/// <returns type="Boolean">True to display a tick for the maxValue, otherwise false.</returns>
	},
	getShowTicks: function() {
		/// <summary>Gets a value indicating whether the ticks are visible.</summary>
		/// <returns type="Boolean">True if ticks are visible, otherwise false.</returns>
	},
	getStep: function() {
		/// <summary>Gets the value between adjacent ticks and labels.</summary>
		/// <returns type="Number">The value between adjacent ticks and labels.</returns>
	},
	getStroke: function() {
		/// <summary>Gets the stroke brush of the ticks.</summary>
		/// <returns type="Object">The stroke brush of the ticks.</returns>
	},
	getTickAlignment: function() {
		/// <summary>Gets the alignment of the ticks relative to the scale.</summary>
		/// <returns type="Alignment">The alignment of the ticks relative to the scale.</returns>
	},
	getTickHeight: function() {
		/// <summary>Gets the height of a tick.</summary>
		/// <returns type="Length">The height of a tick.</returns>
	},
	getTickOffset: function() {
		/// <summary>Gets the offset of the ticks relative to their calculated position.</summary>
		/// <returns type="Length">The offset of the ticks relative to their calculated position.</returns>
	},
	getTickShape: function() {
		/// <summary>Gets the shape of the ticks.</summary>
		/// <returns type="TickShape">The shape of the ticks.</returns>
	},
	getTickWidth: function() {
		/// <summary>Gets the width of a tick.</summary>
		/// <returns type="Length">The width of a tick.</returns>
	},
	removeCustomInterval: function(interval) {
		/// <summary>Removes a CustomInterval object from these settings' customIntervals collection.</summary>
		/// <param name="interval" type="CustomInterval">The interval to remove.</param>
	},
	setCount: function(value) {
		/// <summary>Sets the number of ticks and labels.</summary>
		/// <param name="value" type="Number">The number of ticks and labels.</param>
	},
	setFill: function(value) {
		/// <summary>Sets the fill brush of the ticks.</summary>
		/// <param name="value" type="Object">The fill brush of the ticks.</param>
	},
	setFontFamily: function(value) {
		/// <summary>Sets the font family of the labels.</summary>
		/// <param name="value" type="String">The font family of the labels.</param>
	},
	setFontSize: function(value) {
		/// <summary>Sets the font size of the labels.</summary>
		/// <param name="value" type="Length">The font size of the labels.</param>
	},
	setFontStyle: function(value) {
		/// <summary>Sets the font style of the labels.</summary>
		/// <param name="value" type="String">The font style of the labels.</param>
	},
	setLabelAlignment: function(value) {
		/// <summary>Sets the alignment of the labels relative to the scale.</summary>
		/// <param name="value" type="Alignment">The alignment of the labels relative to the scale.</param>
	},
	setLabelForeground: function(value) {
		/// <summary>Sets the brush used to paint label texts.</summary>
		/// <param name="value" type="Object">The brush used to paint label texts.</param>
	},
	setLabelOffset: function(value) {
		/// <summary>Sets the offset of the labels relative to their calculated position.</summary>
		/// <param name="value" type="Length">The offset of the labels relative to their calculated position.</param>
	},
	setLabelRotation: function(value) {
		/// <summary>Sets the rotation mode of the labels.</summary>
		/// <param name="value" type="LabelRotation">The rotation mode of the labels.</param>
	},
	setNumberPrecision: function(value) {
		/// <summary>Sets the number recision of the labels.</summary>
		/// <param name="value" type="Number">The number recision of the labels.</param>
	},
	setShowLabels: function(value) {
		/// <summary>Sets a value indicating whether the labels are visible.</summary>
		/// <param name="value" type="Boolean">True if labels are visible, otherwise false.</param>
	},
	setShowMaxValueTick: function(value) {
		/// <summary>Sets a value indicating whether to display a tick for the maxValue of the scale.</summary>
		/// <param name="value" type="Boolean">True to display a tick for the maxValue, otherwise false.</param>
	},
	setShowTicks: function(value) {
		/// <summary>Sets a value indicating whether the ticks are visible.</summary>
		/// <param name="value" type="Boolean">True if ticks are visible, otherwise false.</param>
	},
	setStep: function(value) {
		/// <summary>Sets the value between adjacent ticks and labels.</summary>
		/// <param name="value" type="Number">The value between adjacent ticks and labels.</param>
	},
	setStroke: function(value) {
		/// <summary>Sets the stroke brush of the ticks.</summary>
		/// <param name="value" type="Object">The stroke brush of the ticks.</param>
	},
	setTickAlignment: function(value) {
		/// <summary>Sets the alignment of the ticks relative to the scale.</summary>
		/// <param name="value" type="Alignment">The alignment of the ticks relative to the scale.</param>
	},
	setTickHeight: function(value) {
		/// <summary>Sets the height of a tick.</summary>
		/// <param name="value" type="Length">The height of a tick.</param>
	},
	setTickOffset: function(value) {
		/// <summary>Sets the offset of the ticks relative to their calculated position.</summary>
		/// <param name="value" type="Length">The offset of the ticks relative to their calculated position.</param>
	},
	setTickShape: function(value) {
		/// <summary>Sets the shape of the ticks.</summary>
		/// <param name="value" type="TickShape">The shape of the ticks.</param>
	},
	setTickWidth: function(value) {
		/// <summary>Sets the width of a tick.</summary>
		/// <param name="value" type="Length">The width of a tick.</param>
	}
};
MindFusion.Gauges.TickSettings.__class = true;

MindFusion.Gauges.TickShape = {
	/// <summary>Indicates the shape of a scale tick.</summary>
	/// <field name="Arrow1">Specifies an arrow shape.</field>
	/// <field name="Arrow2">Specifies an arrow shape.</field>
	/// <field name="Arrow3">Specifies an arrow shape.</field>
	/// <field name="Custom">Specifies a custom shape.</field>
	/// <field name="Ellipse">Specifies an elliptical shape.</field>
	/// <field name="Line">Specifies a line as a shape.</field>
	/// <field name="None">Specifies an empty shape, that is, the tick is not displayed.</field>
	/// <field name="Rectangle">Specifies a rectangular shape.</field>
	/// <field name="Rhombus">Specifies a rhombus as a shape.</field>
	/// <field name="RoundRect">Specifies a rounded rectangle as a shape.</field>
	/// <field name="Triangle">Specifies a triangular shape.</field>
	Arrow1: 0,
	Arrow2: 1,
	Arrow3: 2,
	Custom: 3,
	Ellipse: 4,
	Line: 5,
	None: 6,
	Rectangle: 7,
	Rhombus: 8,
	RoundRect: 9,
	Triangle: 10
}
MindFusion.Gauges.TickShape.__enum = true;

MindFusion.Gauges.TickType = {
	/// <summary>Indicates the type of a scale tick.</summary>
	/// <field name="Major">Specifies a major tick.</field>
	/// <field name="Middle">Specifies a middle tick.</field>
	/// <field name="Minor">Specifies a minor tick.</field>
	/// <field name="None">Specifies ticks of an unknown type.</field>
	Major: 0,
	Middle: 1,
	Minor: 2,
	None: 3
}
MindFusion.Gauges.TickType.__enum = true;

MindFusion.Gauges.ValueChangedEventArgs.prototype = {
	getNewValue: function() {
		/// <summary>Gets the new value of the changed property.</summary>
		/// <returns type="Object">The new value of the changed property.</returns>
	},
	getOldValue: function() {
		/// <summary>Gets the previous value of the changed property.</summary>
		/// <returns type="Object">The previous value of the changed property.</returns>
	}
};
MindFusion.Gauges.ValueChangedEventArgs.__class = true;

MindFusion.Gauges.ValueChangingEventArgs.prototype = {
	getNewValue: function(value) {
		/// <summary>Gets the new value of the changing property.</summary>
		/// <param name="value" type="void"></param>
		/// <returns type="Object">The new value of the changing property.</returns>
	},
	getOldValue: function() {
		/// <summary>Gets the previous value of the changing property.</summary>
		/// <returns type="Object">The previous value of the changing property.</returns>
	}
};
MindFusion.Gauges.ValueChangingEventArgs.__class = true;

MindFusion.Gauges.VisualElement.prototype = {
	getBounds: function() {
		/// <summary>Gets the bounding rectangle of this element.</summary>
		/// <returns type="Rect">The bounding rectangle of this element.</returns>
	},
	getFill: function() {
		/// <summary>Gets the fill of this element.</summary>
		/// <returns type="Object">The fill of this element.</returns>
	},
	getIsVisible: function() {
		/// <summary>Gets a value indicating whether this element is visible.</summary>
		/// <returns type="Boolean">True if the element is visible, otherwise false.</returns>
	},
	getMargin: function() {
		/// <summary>Gets the margin of this element.</summary>
		/// <returns type="Thickness">The margin of this element.</returns>
	},
	getName: function() {
		/// <summary>Gets the name of this element.</summary>
		/// <returns type="String">The name of this element.</returns>
	},
	getRelativeCoordinates: function() {
		/// <summary>Gets a value indicating whether the metrics of this element are expressed as relative or absolute quantities.</summary>
		/// <returns type="Boolean">True if the metrics are relative, otherwise false.</returns>
	},
	getRenderSize: function() {
		/// <summary>Gets the rendering size of the element.</summary>
		/// <returns type="Size">The rendering size of the element.</returns>
	},
	getSize: function() {
		/// <summary>Gets the size of this element.</summary>
		/// <returns type="Size">The size of this element.</returns>
	},
	getStroke: function() {
		/// <summary>Gets the stroke of this element.</summary>
		/// <returns type="Object">The stroke of this element.</returns>
	},
	getX: function() {
		/// <summary>Gets the normalized x position of this element, relative to its parent.</summary>
		/// <returns type="Number">The normalized x position of this element, relative to its parent.</returns>
	},
	getY: function() {
		/// <summary>Gets the normalized y position of this element, relative to its parent.</summary>
		/// <returns type="Number">The normalized y position of this element, relative to its parent.</returns>
	},
	setBounds: function(value) {
		/// <summary>Sets the bounding rectangle of this element.</summary>
		/// <param name="value" type="Rect">The bounding rectangle of this element.</param>
	},
	setFill: function(value) {
		/// <summary>Sets the fill of this element.</summary>
		/// <param name="value" type="Object">The fill of this element.</param>
	},
	setIsVisible: function(value) {
		/// <summary>Sets a value indicating whether this element is visible.</summary>
		/// <param name="value" type="Boolean">True if the element is visible, otherwise false.</param>
	},
	setMargin: function(value) {
		/// <summary>Sets the margin of this element.</summary>
		/// <param name="value" type="Thickness">The margin of this element.</param>
	},
	setName: function(value) {
		/// <summary>Sets the name of this element.</summary>
		/// <param name="value" type="String">The name of this element.</param>
	},
	setRelativeCoordinates: function(value) {
		/// <summary>Sets a value indicating whether the metrics of this element are expressed as relative or absolute quantities.</summary>
		/// <param name="value" type="Boolean">True if the metrics are relative, otherwise false.</param>
	},
	setRenderSize: function(value) {
		/// <summary>Sets the rendering size of the element.</summary>
		/// <param name="value" type="Size">The rendering size of the element.</param>
	},
	setStroke: function(value) {
		/// <summary>Sets the stroke of this element.</summary>
		/// <param name="value" type="Object">The stroke of this element.</param>
	},
	setX: function(value) {
		/// <summary>Sets the normalized x position of this element, relative to its parent.</summary>
		/// <param name="value" type="Number">The normalized x position of this element, relative to its parent.</param>
	},
	setY: function(value) {
		/// <summary>Sets the normalized y position of this element, relative to its parent.</summary>
		/// <param name="value" type="Number">The normalized y position of this element, relative to its parent.</param>
	}
};
MindFusion.Gauges.VisualElement.__class = true;

MindFusion.Gauges.VisualElementContainer.prototype = {
};
MindFusion.Gauges.VisualElementContainer.__class = true;

MindFusion.Graphs.anchoring.prototype = {
};
MindFusion.Graphs.anchoring.__class = true;

MindFusion.Graphs.Anchoring = {
	/// <summary>Defines values that specify how automatic layout algorithms align links to anchor points.</summary>
	/// <field name="Ignore">Value: 0. Anchor points are ignored.</field>
	/// <field name="Keep">Value: 1. Links are aligned to their original anchor points.</field>
	/// <field name="Reassign">Value: 2. Links are aligned to new anchor points, depending on the positions of graph nodes after a layout is applied.</field>
	Ignore: 0,
	Keep: 1,
	Reassign: 2
}
MindFusion.Graphs.Anchoring.__enum = true;

MindFusion.Graphs.AssistantType = {
	/// <summary>Indicates the type of an assistant node in a tree.</summary>
	/// <field name="Left">Value: 2. The node is an assistant and it is always positioned to the left of its parent.</field>
	/// <field name="Normal">Value: 1. The node is an assistant and its relative position is determinedautomatically by the layout.</field>
	/// <field name="Right">Value: 3. The node is an assistant and it is always positioned to the right of its parent.</field>
	Left: 0,
	Normal: 1,
	Right: 2
}
MindFusion.Graphs.AssistantType.__enum = true;

MindFusion.Graphs.BorderedTreeLayout.prototype = {
	arrange: function(graph) {
		/// <summary>Applies the layout to the specified graph.</summary>
		/// <param name="graph" type="MindFusion.Graphs.Graph">The graph to arrange.</param>
	},
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getDirection: function() {
		/// <summary>Gets the orientation of the arranged graph.</summary>
		/// <returns type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getKeepRootPosition: function() {
		/// <summary>Gets a value indicating whether to keep the root node at its original position.</summary>
		/// <returns type="bool">true if the root node should be kept at its original position, otherwise false.</returns>
	},
	getLevelDistance: function() {
		/// <summary>Gets the space to leave between adjacent levels of the tree.</summary>
		/// <returns type="Number">the space to leave between adjacent levels of the tree.</returns>
	},
	getLinkType: function() {
		/// <summary>Gets the type of the links in the arranged tree.</summary>
		/// <returns type="MindFusion.Graphs.TreeLayoutLinkType">One of the TreeLayoutLinkType Enumeration values.</returns>
	},
	getMultipleGraphsPlacement: function() {
		/// <summary>Gets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <returns type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</returns>
	},
	getNodeDistance: function() {
		/// <summary>Gets the space to leave between adjacent nodes on the same level.</summary>
		/// <returns type="Number">the space to leave between adjacent nodes on the same level.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this BorderedTreeLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setDirection: function(value) {
		/// <summary>Sets the orientation of the arranged graph.</summary>
		/// <param name="value" type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setKeepRootPosition: function(value) {
		/// <summary>Sets a value indicating whether to keep the root node at its original position.</summary>
		/// <param name="value" type="bool">true if the root node should be kept at its original position, otherwise false.</param>
	},
	setLevelDistance: function(value) {
		/// <summary>Sets the space to leave between adjacent levels of the tree.</summary>
		/// <param name="value" type="Number">The space to leave between adjacent levels of the tree.</param>
	},
	setLinkType: function(value) {
		/// <summary>Sets the type of the links in the arranged tree.</summary>
		/// <param name="value" type="MindFusion.Graphs.TreeLayoutLinkType">One of the LayoutDirection Enumeration values.</param>
	},
	setMultipleGraphsPlacement: function(value) {
		/// <summary>Sets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</param>
	},
	setNodeDistance: function(value) {
		/// <summary>Sets the space to leave between adjacent nodes on the same level.</summary>
		/// <param name="value" type="Number">The space to leave between adjacent nodes on the same level.</param>
	},
};
MindFusion.Graphs.BorderedTreeLayout.__class = true;

MindFusion.Graphs.BorderedTreeLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new BorderedTreeLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.compactAssistants.prototype = {
};
MindFusion.Graphs.compactAssistants.__class = true;

MindFusion.Graphs.containerPadding.prototype = {
};
MindFusion.Graphs.containerPadding.__class = true;

MindFusion.Graphs.destination.prototype = {
};
MindFusion.Graphs.destination.__class = true;

MindFusion.Graphs.direction.prototype = {
};
MindFusion.Graphs.direction.__class = true;

MindFusion.Graphs.Edge.prototype = {
	adjacentTo: function(edge) {
		/// <summary>Checks if the current edge is adjacent to the specified edge, that is, they have common vertex.</summary>
		/// <param name="edge" type="MindFusion.Graphs.Edge">The edge to check.</param>
		/// <returns type="Boolean">true if the current edge is adjacent to the specified edge; otherwise, false.</returns>
	},
	changeDestination: function(vertex) {
		/// <summary>Changes the destination of the current edge to the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">The new destination of the edge.</param>
	},
	changeOrigin: function(vertex) {
		/// <summary>Changes the origin of the current edge to the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">The new origin of the edge.</param>
	},
	createReverseEdge: function() {
		/// <summary>Creates a new edge similar to the current edge but with reversed direction.</summary>
		/// <returns type="MindFusion.Graphs.Edge"></returns>
	},
	getCommonVertex: function(edge) {
		/// <summary>Returns a common vertex for the current edge and the specified edge.</summary>
		/// <param name="edge" type="MindFusion.Graphs.Edge">The edge for which to find common vertex.</param>
		/// <returns type="MindFusion.Graphs.Vertex">The common vertex if it exists, otherwise null.</returns>
	},
	getEnds: function() {
		/// <summary>Returns an array containing the origin and destination vertices of this edge.</summary>
		/// <returns type="Array">An array containing the related vertices.</returns>
	},
	getOtherEnd: function(vertex) {
		/// <summary>Returns the vertex connected by this edge that is not the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">One of the vertices connected by this edge.</param>
		/// <returns type="MindFusion.Graphs.Vertex">The other vertex connected by this edge.</returns>
	},
	incidentWith: function(vertex) {
		/// <summary>Checks if the current edge is incident with the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">The vertex to check.</param>
		/// <returns type="Boolean">true if the edge is incident with the vertex; otherwise, false.</returns>
	},
	joins: function(v1, v2) {
		/// <summary>Checks if the current edge connects the specified vertices.</summary>
		/// <param name="v1" type="MindFusion.Graphs.Vertex">The first vertex.</param>
		/// <param name="v2" type="MindFusion.Graphs.Vertex">The second vertex.</param>
		/// <returns type="Boolean">true if the current edge connects the specified vertices; otherwise, false.</returns>
	},
	reverse: function() {
		/// <summary>Reverses this edge.</summary>
	}
};
MindFusion.Graphs.Edge.__class = true;

MindFusion.Graphs.edges.prototype = {
};
MindFusion.Graphs.edges.__class = true;

MindFusion.Graphs.enableAssistants.prototype = {
};
MindFusion.Graphs.enableAssistants.__class = true;

MindFusion.Graphs.FlowchartLayout.prototype = {
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getBranchPadding: function() {
		/// <summary>Gets how much space to leave between adjacent decision branches in the flowchart.</summary>
		/// <returns type="Number">A numeric value specifying the distance between adjacent branches.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="Boolean">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getLinkPadding: function() {
		/// <summary>Gets how much space to leave between adjacent back links designating nested loops.</summary>
		/// <returns type="Number">A numeric value specifying the distance between adjacent back links.</returns>
	},
	getMultipleGraphsPlacement: function() {
		/// <summary>Gets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <returns type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</returns>
	},
	getNodeDistance: function() {
		/// <summary>Gets the distance between consecutive nodes in the flowchart.</summary>
		/// <returns type="Number">A numeric value specifying the distance between neighbor nodes in the same sequence.</returns>
	},
	getOrientation: function() {
		/// <summary>Gets the orientation of the arranged graph.</summary>
		/// <returns type="MindFusion.Graphs.Orientation">One of the Orientation Enumeration values.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this FlowchartLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setBranchPadding: function(value) {
		/// <summary>Sets how much space to leave between adjacent decision branches in the flowchart.</summary>
		/// <param name="value" type="Number">A numeric value specifying the distance between adjacent branches.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="Boolean">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setLinkPadding: function(value) {
		/// <summary>Sets how much space to leave between adjacent back links designating nested loops.</summary>
		/// <param name="value" type="Number">A numeric value specifying the distance between adjacent back links.</param>
	},
	setMultipleGraphsPlacement: function(value) {
		/// <summary>Sets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</param>
	},
	setNodeDistance: function(value) {
		/// <summary>Sets the distance between consecutive nodes in the flowchart.</summary>
		/// <param name="value" type="Number">A numeric value specifying the distance between neighbor nodes in the same sequence.</param>
	},
	setOrientation: function(value) {
		/// <summary>Sets the orientation of the arranged graph.</summary>
		/// <param name="value" type="MindFusion.Graphs.Orientation">One of the Orientation Enumeration values.</param>
	},
};
MindFusion.Graphs.FlowchartLayout.__class = true;

MindFusion.Graphs.FlowchartLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new FlowchartLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.FractalLayout.prototype = {
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getMultipleGraphsPlacement: function() {
		/// <summary>Gets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <returns type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</returns>
	},
	getRoot: function() {
		/// <summary>Gets the node that should be placed at the center of the tree.</summary>
		/// <returns type="MindFusion.Diagramming.DiagramNode">The node that should be placed at the center of the tree.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this FractalLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setMultipleGraphsPlacement: function(value) {
		/// <summary>Sets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</param>
	},
	setRoot: function(value) {
		/// <summary>Sets the node that should be placed at the center of the tree.</summary>
		/// <param name="value" type="MindFusion.Diagramming.DiagramNode">The node that should be placed at the center of the tree.</param>
	},
};
MindFusion.Graphs.FractalLayout.__class = true;

MindFusion.Graphs.FractalLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new FractalLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.Graph.prototype = {
	addEdge: function(edge) {
		/// <summary>Adds an existing edge to the graph.</summary>
		/// <param name="edge" type="MindFusion.Graphs.Edge">The edge to add.</param>
	},
	clone: function(saveMapping) {
		/// <summary>Creates an exact copy of the current graph.</summary>
		/// <param name="saveMapping" type="Boolean" optional="true">Optional. Indicates whether to store vertex and edge mapping information in the copy.</param>
		/// <returns type="MindFusion.Graphs.Graph">The newly created copy.</returns>
	},
	createEdge: function(origin, destination, owner) {
		/// <summary>Creates a new edge connecting the specified vertices and adds it to the graph.</summary>
		/// <param name="origin" type="MindFusion.Graphs.Vertex">The origin vertex.</param>
		/// <param name="destination" type="MindFusion.Graphs.Vertex">The destination vertex.</param>
		/// <param name="owner" type="Object" optional="true">Optional. The owner of the new edge.</param>
		/// <returns type="MindFusion.Graphs.Edge">The newly created edge.</returns>
	},
	createVertex: function(layoutRect, owner) {
		/// <summary>Creates a new vertex with the specified position and size and adds it to the graph.</summary>
		/// <param name="layoutRect" type="MindFusion.Drawing.Rect">A rectangle specifying the position and size of the vertex.</param>
		/// <param name="owner" type="Object" optional="true">Optional. The owner of the new vertex.</param>
		/// <returns type="MindFusion.Graphs.Vertex">The newly created vertex.</returns>
	},
	getConnectedComponents: function() {
		/// <summary>Returns a list with the connected subgraphs in the current graph.</summary>
		/// <returns type="Array">An array with connected Graph objects.</returns>
	},
	makeAcyclic: function() {
		/// <summary>Makes the graph acyclic by reversing the direction of selected edges.</summary>
		/// <returns type="Array">A list with all edges that were reversed in order to make the graph acyclic.</returns>
	},
	removeEdge: function(edge) {
		/// <summary>Removes an edge from the graph.</summary>
		/// <param name="edge" type="MindFusion.Graphs.Edge">The edge to remove.</param>
	},
	tree: function(root, enableAssistants, compactAssistants) {
		/// <summary>Returns a new graph object containing a subset of the vertices and edges of the original graph, such that the new graph is a tree.</summary>
		/// <param name="root" type="MindFusion.Graphs.Vertex">The desired root vertex of the tree.</param>
		/// <param name="enableAssistants" type="Boolean"></param>
		/// <param name="compactAssistants" type="Boolean"></param>
		/// <returns type="MindFusion.Graphs.Graph">The newly created tree.</returns>
	}
};
MindFusion.Graphs.Graph.__class = true;

MindFusion.Graphs.inEdges.prototype = {
};
MindFusion.Graphs.inEdges.__class = true;

MindFusion.Graphs.iterations.prototype = {
};
MindFusion.Graphs.iterations.__class = true;

MindFusion.Graphs.keepGroupLayout.prototype = {
};
MindFusion.Graphs.keepGroupLayout.__class = true;

MindFusion.Graphs.keepRootPosition.prototype = {
};
MindFusion.Graphs.keepRootPosition.__class = true;

MindFusion.Graphs.layerDistance.prototype = {
};
MindFusion.Graphs.layerDistance.__class = true;

MindFusion.Graphs.LayeredLayout.prototype = {
	arrange: function(graph) {
		/// <summary>Applies the layout to the specified graph.</summary>
		/// <param name="graph" type="MindFusion.Graphs.Graph">The graph to arrange.</param>
	},
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getDirection: function() {
		/// <summary>Gets the orientation of the arranged graph.</summary>
		/// <returns type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getLayerDistance: function() {
		/// <summary>Gets the desired distance between layer axis lines.</summary>
		/// <returns type="Number">the desired distance between layer axis lines.</returns>
	},
	getMultipleGraphsPlacement: function() {
		/// <summary>Gets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <returns type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</returns>
	},
	getNodeDistance: function() {
		/// <summary>Gets the space to leave between adjacent nodes on the same level.</summary>
		/// <returns type="Number">the space to leave between adjacent nodes on the same level.</returns>
	},
	getSiftingRounds: function() {
		/// <summary>Gets the number of iterations to perform when untwining the layout.</summary>
		/// <returns type="Number">the number of iterations to perform when untwining the layout.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this LayeredLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setDirection: function(value) {
		/// <summary>Sets the orientation of the arranged graph.</summary>
		/// <param name="value" type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setLayerDistance: function(value) {
		/// <summary>Sets the desired distance between layer axis lines.</summary>
		/// <param name="value" type="Number">The desired distance between layer axis lines.</param>
	},
	setMultipleGraphsPlacement: function(value) {
		/// <summary>Sets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</param>
	},
	setNodeDistance: function(value) {
		/// <summary>Sets the space to leave between adjacent nodes on the same level.</summary>
		/// <param name="value" type="Number">The space to leave between adjacent nodes on the same level.</param>
	},
	setSiftingRounds: function(value) {
		/// <summary>Sets the number of iterations to perform when untwining the layout.</summary>
		/// <param name="value" type="Number">The number of iterations to perform when untwining the layout.</param>
	},
};
MindFusion.Graphs.LayeredLayout.__class = true;

MindFusion.Graphs.LayeredLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new LayeredLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.layoutArea.prototype = {
};
MindFusion.Graphs.layoutArea.__class = true;

MindFusion.Graphs.LayoutDirection = {
	/// <summary>Specifies in what direction to place nodes processed by a layout algorithm.</summary>
	/// <field name="BottomToTop">Value: 2. Indicates a bottom-to-top layout direction.</field>
	/// <field name="LeftToRight">Value: 1. Indicates a left-to-right layout direction.</field>
	/// <field name="RightToLeft">Value: 3. Indicates a right-to-left layout direction.</field>
	/// <field name="TopToBottom">Value: 0. Indicates a top-to-bottom layout direction.</field>
	BottomToTop: 0,
	LeftToRight: 1,
	RightToLeft: 2,
	TopToBottom: 3
}
MindFusion.Graphs.LayoutDirection.__enum = true;

MindFusion.Graphs.levelDistance.prototype = {
};
MindFusion.Graphs.levelDistance.__class = true;

MindFusion.Graphs.linkType.prototype = {
};
MindFusion.Graphs.linkType.__class = true;

MindFusion.Graphs.multipleGraphsPlacement.prototype = {
};
MindFusion.Graphs.multipleGraphsPlacement.__class = true;

MindFusion.Graphs.MultipleGraphsPlacement = {
	/// <summary>Specifies placement of graph connected components relatively to each other.</summary>
	/// <field name="Horizontal">Value: 1. Indicates that subgraphs should be placed in a row.</field>
	/// <field name="Vertical">Value: 0. Indicates that subgraphs should be placed in a column.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.Graphs.MultipleGraphsPlacement.__enum = true;

MindFusion.Graphs.nodeDistance.prototype = {
};
MindFusion.Graphs.nodeDistance.__class = true;

MindFusion.Graphs.orientation.prototype = {
};
MindFusion.Graphs.orientation.__class = true;

MindFusion.Graphs.Orientation = {
	/// <summary>Specifies general layout orientation.</summary>
	/// <field name="Horizontal">Value: 1. Specifies horizonal orientation.</field>
	/// <field name="Vertical">Value: 0. Specifies vertical orientation.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.Graphs.Orientation.__enum = true;

MindFusion.Graphs.origin.prototype = {
};
MindFusion.Graphs.origin.__class = true;

MindFusion.Graphs.outEdges.prototype = {
};
MindFusion.Graphs.outEdges.__class = true;

MindFusion.Graphs.padding.prototype = {
};
MindFusion.Graphs.padding.__class = true;

MindFusion.Graphs.root.prototype = {
};
MindFusion.Graphs.root.__class = true;

MindFusion.Graphs.siftingRounds.prototype = {
};
MindFusion.Graphs.siftingRounds.__class = true;

MindFusion.Graphs.SpringLayout.prototype = {
	arrange: function(graph) {
		/// <summary>Applies the layout to the specified graph.</summary>
		/// <param name="graph" type="MindFusion.Graphs.Graph">The graph to arrange.</param>
	},
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getIterations: function() {
		/// <summary>Gets the number of iterations to run the layout routine.</summary>
		/// <returns type="Number">the number of iterations to run the layout routine.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getMultipleGraphsPlacement: function() {
		/// <summary>Gets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <returns type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</returns>
	},
	getNodeDistance: function() {
		/// <summary>Gets the desired distance between nodes.</summary>
		/// <returns type="Number">the desired distance between nodes.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this SpringLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setIterations: function(value) {
		/// <summary>Sets the number of iterations to run the layout routine.</summary>
		/// <param name="value" type="Number">The number of iterations to run the layout routine.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setMultipleGraphsPlacement: function(value) {
		/// <summary>Sets a value indicating how multiple independent graphs in the diagram should be positioned relatively to each other.</summary>
		/// <param name="value" type="MindFusion.Graphs.MultipleGraphsPlacement">One of the MultipleGraphsPlacement Enumeration values.</param>
	},
	setNodeDistance: function(value) {
		/// <summary>Sets the desired distance between nodes.</summary>
		/// <param name="value" type="Number">The desired distance between nodes.</param>
	},
};
MindFusion.Graphs.SpringLayout.__class = true;

MindFusion.Graphs.SpringLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new SpringLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.squarify.prototype = {
};
MindFusion.Graphs.squarify.__class = true;

MindFusion.Graphs.TreeLayout.prototype = {
	arrange: function(graph) {
		/// <summary>Applies the layout to the specified graph.</summary>
		/// <param name="graph" type="MindFusion.Graphs.Graph">The graph to arrange.</param>
	},
	getAnchoring: function() {
		/// <summary>Gets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <returns type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</returns>
	},
	getDirection: function() {
		/// <summary>Gets the orientation of the arranged graph.</summary>
		/// <returns type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</returns>
	},
	getKeepGroupLayout: function() {
		/// <summary>Gets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <returns type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</returns>
	},
	getKeepRootPosition: function() {
		/// <summary>Gets a value indicating whether to keep the root node at its original position.</summary>
		/// <returns type="bool">true if the root node should be kept at its original position., otherwise false.</returns>
	},
	getLevelDistance: function() {
		/// <summary>Gets the space to leave between adjacent levels of the tree.</summary>
		/// <returns type="Number">the space to leave between adjacent levels of the tree.</returns>
	},
	getLinkType: function() {
		/// <summary>Gets the type of the links in the arranged tree.</summary>
		/// <returns type="MindFusion.Graphs.TreeLayoutLinkType">One of the TreeLayoutLinkType Enumeration values.</returns>
	},
	getNodeDistance: function() {
		/// <summary>Gets the space to leave between adjacent nodes on the same level.</summary>
		/// <returns type="Number">the space to leave between adjacent nodes on the same level.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this TreeLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setAnchoring: function(value) {
		/// <summary>Sets a value indicating how to align links to the anchor points of nodes.</summary>
		/// <param name="value" type="MindFusion.Graphs.Anchoring">One of the Anchoring Enumeration values.</param>
	},
	setDirection: function(value) {
		/// <summary>Sets the orientation of the arranged graph.</summary>
		/// <param name="value" type="MindFusion.Graphs.LayoutDirection">One of the LayoutDirection Enumeration values.</param>
	},
	setKeepGroupLayout: function(value) {
		/// <summary>Sets a value indicating whether to treat each Group of nodes as a single vertex in the arranged graph.</summary>
		/// <param name="value" type="bool">true if each Group of nodes should be treated as a single vertex in the arranged graph, otherwise false.</param>
	},
	setKeepRootPosition: function(value) {
		/// <summary>Sets a value indicating whether to keep the root node at its original position.</summary>
		/// <param name="value" type="bool">true if the root node should be kept at its original position., otherwise false.</param>
	},
	setLevelDistance: function(value) {
		/// <summary>Sets the space to leave between adjacent levels of the tree.</summary>
		/// <param name="value" type="Number">The space to leave between adjacent levels of the tree.</param>
	},
	setLinkType: function(value) {
		/// <summary>Sets the type of the links in the arranged tree.</summary>
		/// <param name="value" type="MindFusion.Graphs.TreeLayoutLinkType">One of the LayoutDirection Enumeration values.</param>
	},
	setNodeDistance: function(value) {
		/// <summary>Sets the space to leave between adjacent nodes on the same level.</summary>
		/// <param name="value" type="Number">The space to leave between adjacent nodes on the same level.</param>
	},
};
MindFusion.Graphs.TreeLayout.__class = true;

MindFusion.Graphs.TreeLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new TreeLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.TreeLayoutLinkType = {
	/// <summary>Specifies the shape of the diagram links after they are laid out.</summary>
	/// <field name="Cascading">Value: 2. Indicates that links will be arranged as cascading and attached to the middles of the adjoining node sides.</field>
	/// <field name="Default">Value: 0. Indicates that links will be arranged to point to the centers of the related nodes.</field>
	/// <field name="Straight">Value: 1. Indicates that links will be attached to the middles of the adjoining node sides.</field>
	Cascading: 0,
	Default: 1,
	Straight: 2
}
MindFusion.Graphs.TreeLayoutLinkType.__enum = true;

MindFusion.Graphs.TreeMapLayout.prototype = {
	arrange: function(graph) {
		/// <summary>Applies the layout to the specified graph.</summary>
		/// <param name="graph" type="MindFusion.Graphs.Graph">The graph to arrange.</param>
	},
	getContainerPadding: function() {
		/// <summary>Gets the padding inside containers.</summary>
		/// <returns type="Number">the padding inside containers.</returns>
	},
	getLayoutArea: function() {
		/// <summary>Gets the rectangle in which the layout will try to arrange nodes.</summary>
		/// <returns type="MindFusion.Drawing.Rect">the rectangle in which the layout will try to arrange nodes.</returns>
	},
	getOrientation: function() {
		/// <summary>Gets the orientation of the arranged graph.</summary>
		/// <returns type="MindFusion.Graphs.Orientation">One of the Orientation Enumeration values.</returns>
	},
	getPadding: function() {
		/// <summary>Gets the distance between adjacent nodes.</summary>
		/// <returns type="Number">the distance between adjacent nodes.</returns>
	},
	getSquarify: function() {
		/// <summary>Gets a value indicating whether the layout should attempt to keep the dimension ratio of nodes closer to 1.</summary>
		/// <returns type="bool">true if the layout should attempt to keep the dimension ratio of nodes closer to 1, otherwise false.</returns>
	},
	init: function() {
		/// <summary>Returns a Builder object used to configure this TreeMapLayout instance.</summary>
		/// <returns type="Builder">A Builder instance.</returns>
	},
	setContainerPadding: function(value) {
		/// <summary>Sets the padding inside containers.</summary>
		/// <param name="value" type="Number">the padding inside containers.</param>
	},
	setLayoutArea: function(value) {
		/// <summary>Sets the rectangle in which the layout will try to arrange nodes.</summary>
		/// <param name="value" type="MindFusion.Drawing.Rect">The rectangle in which the layout will try to arrange nodes.</param>
	},
	setOrientation: function(value) {
		/// <summary>Sets the orientation of the arranged graph.</summary>
		/// <param name="value" type="MindFusion.Graphs.Orientation">One of the Orientation Enumeration values.</param>
	},
	setPadding: function(value) {
		/// <summary>Sets the distance between adjacent nodes.</summary>
		/// <param name="value" type="Number">The distance between adjacent nodes.</param>
	},
	setSquarify: function(value) {
		/// <summary>Sets a value indicating whether the layout should attempt to keep the dimension ratio of nodes closer to 1.</summary>
		/// <param name="value" type="bool">true if the layout should attempt to keep the dimension ratio of nodes closer to 1, otherwise false.</param>
	},
};
MindFusion.Graphs.TreeMapLayout.__class = true;

MindFusion.Graphs.TreeMapLayout.With = function() {
	/// <summary>Returns a Builder object used to configure and create new TreeMapLayout instances.</summary>
	/// <returns type="Builder">A Builder instance.</returns>
};

MindFusion.Graphs.Vertex.prototype = {
	adjacentTo: function(vertex) {
		/// <summary>Checks if there is an edge connecting this vertex with the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">The vertex to check.</param>
		/// <returns type="Boolean">true if the vertices are connected; otherwise, false.</returns>
	},
	degree: function() {
		/// <summary>Returns the number of incident edges.</summary>
		/// <returns type="Number">The number of incident edges.</returns>
	},
	getCommonEdge: function(vertex) {
		/// <summary>Finds the edge connecting the current vertex with the specified vertex.</summary>
		/// <param name="vertex" type="MindFusion.Graphs.Vertex">The vertex to find an edge for.</param>
		/// <returns type="MindFusion.Graphs.Edge">The edge connecting the vertices or null.</returns>
	},
	getNeighbors: function() {
		/// <summary>Returns an array containing all vertices adjacent to the current vertex.</summary>
		/// <returns type="Array">A list with all neighbors.</returns>
	},
	incidentWith: function(edge) {
		/// <summary>Checks if the current vertex is incident with the specified edge.</summary>
		/// <param name="edge" type="MindFusion.Graphs.Edge">The edge to check.</param>
		/// <returns type="Boolean">true if the vertex is incident with the edge; otherwise, false.</returns>
	}
};
MindFusion.Graphs.Vertex.__class = true;

MindFusion.Graphs.vertices.prototype = {
};
MindFusion.Graphs.vertices.__class = true;

MindFusion.Graphs.weight.prototype = {
};
MindFusion.Graphs.weight.__class = true;

MindFusion.Drawing.bold.prototype = {
};
MindFusion.Drawing.bold.__class = true;

MindFusion.Drawing.Border3D.prototype = {
};
MindFusion.Drawing.Border3D.__class = true;

MindFusion.Drawing.bottom.prototype = {
};
MindFusion.Drawing.bottom.__class = true;

MindFusion.Drawing.bounds.prototype = {
};
MindFusion.Drawing.bounds.__class = true;

MindFusion.Drawing.Canvas.prototype = {
	clientToDoc: function(point) {
		/// <summary>Transforms a point from client to document coordinates.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to transform.</param>
		/// <returns type="MindFusion.Drawing.Point">The transformed point.</returns>
	},
	dispose: function() {
		/// <summary>Overrides Component.Dispose</summary>
	},
	docToClient: function(point) {
		/// <summary>Transforms a point from document to client coordinates.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to transform.</param>
		/// <returns type="MindFusion.Drawing.Point">The transformed point.</returns>
	},
	getBounds: function() {
		/// <summary>Gets the underlying Canvas element's bounds.</summary>
		/// <returns type="MindFusion.Drawing.Rect">A Rect instance.</returns>
	},
	getLicenseLocation: function() {
		/// <summary>Gets the URL of the diagram's license file.</summary>
		/// <returns type="String">A valid URL string that specifies the location of the license key.</returns>
	},
	getMeasureUnit: function() {
		/// <summary>Gets the unit of measure used for logical coordinates.</summary>
		/// <returns type="MindFusion.Drawing.GraphicsUnit">The current measure unit.</returns>
	},
	getMinVisibleFontSize: function() {
		/// <summary>Gets a threshold value that hides text if scaled font sizes become smaller.</summary>
		/// <returns type="Number">A value specifying the smallest visible font size.</returns>
	},
	getZoomFactor: function() {
		/// <summary>Gets the zoom factor.</summary>
		/// <returns type="Number">The current zoom factor.</returns>
	},
	invalidate: function(rect) {
		/// <summary>Invalidates the canvas or a region of the canvas, causing it to be repainted.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect" optional="true">Optional. A Rect instance specifying the region that should be repainted. If not specified, the whole diagram will be repainted.</param>
	},
	setBounds: function(bounds) {
		/// <summary>Sets the underlying Canvas element's bounds.</summary>
		/// <param name="bounds" type="MindFusion.Drawing.Rect">A Rect instance.</param>
	},
	setLicenseLocation: function(value) {
		/// <summary>Sets the URL of the diagram's license file.</summary>
		/// <param name="value" type="String">A valid URL string that specifies the location of the license key.</param>
	},
	setMeasureUnit: function(value) {
		/// <summary>Sets the unit of measure used for logical coordinates.</summary>
		/// <param name="value" type="MindFusion.Drawing.GraphicsUnit">A GraphicsUnit instance.</param>
	},
	setMinVisibleFontSize: function(value) {
		/// <summary>Sets a threshold value that hides text if scaled font sizes become smaller.</summary>
		/// <param name="value" type="Number">A value specifying the smallest visible font size.</param>
	},
	setZoomFactor: function(value) {
		/// <summary>Sets the zoom factor.</summary>
		/// <param name="value" type="Number">The zoom factor.</param>
	}
};
MindFusion.Drawing.Canvas.__class = true;

MindFusion.Drawing.Canvas.create = function(element) {
	/// <summary>Creates and initializes a new Canvas from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the diagram should be attached to.</param>
	/// <returns type="MindFusion.Drawing.Canvas">A Canvas object that represents the newly created canvas.</returns>
};

MindFusion.Drawing.Component.prototype = {
};
MindFusion.Drawing.Component.__class = true;

MindFusion.Drawing.DashStyle = {
	/// <summary>Specifies the dash pattern of lines.</summary>
	/// <field name="Dash">Specifies a line consisting of dashes.</field>
	/// <field name="DashDot">Specifies a dash-dot pattern.</field>
	/// <field name="DashDotDot">Specifies a dash-dot-dot pattern.</field>
	/// <field name="Dot">Specifies a line consisting of dots.</field>
	/// <field name="Solid">Specifies a solid line.</field>
	Dash: 0,
	DashDot: 1,
	DashDotDot: 2,
	Dot: 3,
	Solid: 4
}
MindFusion.Drawing.DashStyle.__enum = true;

MindFusion.Drawing.Ellipse.prototype = {
	clone: function() {
		/// <summary>Creates a Ellipse object identical to the current object.</summary>
		/// <returns type="MindFusion.Drawing.Ellipse">The newly created Ellipse object.</returns>
	}
};
MindFusion.Drawing.Ellipse.__class = true;

MindFusion.Drawing.Font.prototype = {
};
MindFusion.Drawing.Font.__class = true;

MindFusion.Drawing.FontStyle = {
	/// <summary>Specifies font style attributes.</summary>
	/// <field name="Bold">Bold text.</field>
	/// <field name="Italic">Italic text.</field>
	/// <field name="Regular">Normal text.</field>
	/// <field name="Underline">Underlined text.</field>
	Bold: 0,
	Italic: 1,
	Regular: 2,
	Underline: 3
}
MindFusion.Drawing.FontStyle.__enum = true;

MindFusion.Drawing.height.prototype = {
};
MindFusion.Drawing.height.__class = true;

MindFusion.Drawing.image.prototype = {
};
MindFusion.Drawing.image.__class = true;

MindFusion.Drawing.ImageAlign = {
	/// <summary>Specifies the position and alignment of a picture in a node, or that of the background image.</summary>
	/// <field name="BottomCenter">The image is centered horizontally and aligned to the bottom side.</field>
	/// <field name="BottomLeft">The image is aligned to the bottom left corner of the node or the diagram.</field>
	/// <field name="BottomRight">The image is aligned to the bottom right corner of the node or the diagram.</field>
	/// <field name="Center">The image is centered in the node or diagram.</field>
	/// <field name="Fit">The image is resized to fit the size of the object or the component's client area.</field>
	/// <field name="MiddleLeft">The image is centered vertically and aligned to the left-hand side.</field>
	/// <field name="MiddleRight">The image is centered vertically and aligned to the right-hand side.</field>
	/// <field name="Stretch">The image is stretched to fill the object or the component's client area.</field>
	/// <field name="Tile">The image is tiled to cover the node or the diagram.</field>
	/// <field name="TopCenter">The image is centered horizontally and aligned to the top side.</field>
	/// <field name="TopLeft">The image is aligned to the top left corner of the node or the diagram.</field>
	/// <field name="TopRight">The image is aligned to the top right corner of the node or the diagram.</field>
	BottomCenter: 0,
	BottomLeft: 1,
	BottomRight: 2,
	Center: 3,
	Fit: 4,
	MiddleLeft: 5,
	MiddleRight: 6,
	Stretch: 7,
	Tile: 8,
	TopCenter: 9,
	TopLeft: 10,
	TopRight: 11
}
MindFusion.Drawing.ImageAlign.__enum = true;

MindFusion.Drawing.italic.prototype = {
};
MindFusion.Drawing.italic.__class = true;

MindFusion.Drawing.left.prototype = {
};
MindFusion.Drawing.left.__class = true;

MindFusion.Drawing.mdraw.Image.prototype = {
};
MindFusion.Drawing.mdraw.Image.__class = true;

MindFusion.Drawing.measureUnit.prototype = {
};
MindFusion.Drawing.measureUnit.__class = true;

MindFusion.Drawing.name.prototype = {
};
MindFusion.Drawing.name.__class = true;

MindFusion.Drawing.Path.prototype = {
	addEllipse: function(x, y, width, height) {
		/// <summary>Adds an ellipse figure to the path.</summary>
		/// <param name="x" type="Number">The x-coordinate of the center of the ellipse.</param>
		/// <param name="y" type="Number">The y-coordinate of the center of the ellipse.</param>
		/// <param name="width" type="Number">The width of the ellipse.</param>
		/// <param name="height" type="Number">The height of the ellipse.</param>
	},
	addRect: function(x, y, width, height) {
		/// <summary>Adds a rectangle figure to the path.</summary>
		/// <param name="x" type="Number">The x-coordinate of the rectangle.</param>
		/// <param name="y" type="Number">The y-coordinate of the rectangle.</param>
		/// <param name="width" type="Number">The width of the rectangle.</param>
		/// <param name="height" type="Number">The height of the rectangle.</param>
	},
	arcTo: function(x, y, radius, startAngle, endAngle, anticlockwise) {
		/// <summary>Draws an arc.</summary>
		/// <param name="x" type="Number">The x-coordinate of the center of the circle.</param>
		/// <param name="y" type="Number">The y-coordinate of the center of the circle.</param>
		/// <param name="radius" type="Number">The radius of the circle</param>
		/// <param name="startAngle" type="Number">The starting angle in radians.</param>
		/// <param name="endAngle" type="Number">The ending angle in radians.</param>
		/// <param name="anticlockwise" type="Boolean">Specifies whether the drawing should be counterclockwise or clockwise.</param>
	},
	bezierTo: function(x1, y1, x2, y2, x3, y3) {
		/// <summary>Draws a cubic bezier curve.</summary>
		/// <param name="x1" type="Number">The x-coordinate of the first bezier control point.</param>
		/// <param name="y1" type="Number">The y-coordinate of the first bezier control point.</param>
		/// <param name="x2" type="Number">The x-coordinate of the second bezier control point.</param>
		/// <param name="y2" type="Number">The y-coordinate of the second bezier control point.</param>
		/// <param name="x3" type="Number">The x-coordinate of the ending point.</param>
		/// <param name="y3" type="Number">The y-coordinate of the ending point.</param>
	},
	clone: function() {
		/// <summary>Creates a Path object identical to the current object.</summary>
		/// <returns type="MindFusion.Drawing.Path">The newly created Path object.</returns>
	},
	close: function() {
		/// <summary>Closes the path.</summary>
	},
	done: function() {
		/// <summary>Ends the path definition.</summary>
	},
	empty: function() {
		/// <summary>Gets a value indicating whether this Path is empty.</summary>
		/// <returns type="Boolean">true if the path does not contain any figures; otherwise, false.</returns>
	},
	getBounds: function() {
		/// <summary>Gets the bounding rect of the path.</summary>
		/// <returns type="MindFusion.Drawing.Rect">The bounding rect.</returns>
	},
	init: function() {
		/// <summary>Begins a path or resets the current path.</summary>
	},
	lineTo: function(x, y) {
		/// <summary>Draws a line from the current point to the specified location.</summary>
		/// <param name="x" type="Number">The x-coordinate of the point.</param>
		/// <param name="y" type="Number">The y-coordinate of the point.</param>
	},
	moveTo: function(x, y) {
		/// <summary>Moves the path to the specified location.</summary>
		/// <param name="x" type="Number">The x-coordinate of the point.</param>
		/// <param name="y" type="Number">The y-coordinate of the point.</param>
	},
	quadraticCurveTo: function(x1, y1, x, y) {
		/// <summary>Draws a quadratic bezier curve.</summary>
		/// <param name="x1" type="Number">The x-coordinate of the bezier control point.</param>
		/// <param name="y1" type="Number">The y-coordinate of the bezier control point.</param>
		/// <param name="x" type="Number">The x-coordinate of the ending point.</param>
		/// <param name="y" type="Number">The y-coordinate of the ending point.</param>
	},
	setBrush: function(brush) {
		/// <summary>Sets the brush used to fill a closed path.</summary>
		/// <param name="brush" type="Object">The brush.</param>
	},
	setPen: function(pen) {
		/// <summary>Sets the pen used to draw the path.</summary>
		/// <param name="pen" type="Object">The pen.</param>
	},
	setText: function(text) {
		/// <summary>Sets the text displayed inside this path.</summary>
		/// <param name="text" type="String">The text.</param>
	}
};
MindFusion.Drawing.Path.__class = true;

MindFusion.Drawing.pen.prototype = {
};
MindFusion.Drawing.pen.__class = true;

MindFusion.Drawing.Point.prototype = {
	empty: function() {
		/// <summary>Gets a value indicating whether this Point is empty.</summary>
		/// <returns type="Boolean">true if both x and y are 0; otherwise, false.</returns>
	},
	equals: function(point) {
		/// <summary>Specifies whether this Point contains the same coordinates as the specified point.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point" optional="true">Optional. The Point to test.</param>
		/// <returns type="Boolean">true if point is a Point and has the same coordinates as this Point.</returns>
	}
};
MindFusion.Drawing.Point.__class = true;

MindFusion.Drawing.Rect.prototype = {
	bottom: function() {
		/// <summary>Gets the y-coordinate that is the sum of the y and height property values of this Rect object.</summary>
		/// <returns type="Number">The y-coordinate that is the sum of y and height of this Rect.</returns>
	},
	bottomLeft: function() {
		/// <summary>Gets the bottom-left edge of this Rect object.</summary>
		/// <returns type="MindFusion.Drawing.Point">The bottom-left edge, which is a Point with x that is equal to x and with y that is the sum of y and height.</returns>
	},
	bottomRight: function() {
		/// <summary>Gets the bottom-right edge of this Rect object.</summary>
		/// <returns type="MindFusion.Drawing.Point">The bottom-right edge, which is a Point with x that is the sum of x and width and with y that is the sum of y and height.</returns>
	},
	center: function() {
		/// <summary>Gets the center of this Rect object.</summary>
		/// <returns type="MindFusion.Drawing.Point">The center, which is a Point with x that is the sum of x and half of width and with y that is the sum of y and half of height.</returns>
	},
	clone: function() {
		/// <summary>Creates a Rect object identical to the current object.</summary>
		/// <returns type="MindFusion.Drawing.Rect">The newly created Rect object.</returns>
	},
	contains: function(rect) {
		/// <summary>Determines if the rectangular region represented by rect is entirely contained within this Rect object.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The Rect to test.</param>
		/// <returns type="Boolean">true if the rectangular region represented by rect is entirely contained within this Rect; otherwise, false.</returns>
	},
	containsPoint: function(point) {
		/// <summary>Determines if the specified point is contained within this Rect object.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <returns type="Boolean">true if point is contained within the Rect; otherwise, false.</returns>
	},
	equals: function(rect) {
		/// <summary>Specifies whether this Rect contains the same coordinates as the specified rectangle.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The Rect to test.</param>
		/// <returns type="Boolean">true if rect has the same coordinates as this Rect.</returns>
	},
	intersect: function(rect) {
		/// <summary>Returns a Rect object representing the intersection of the current rectangle with the specified rectangle.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle to intersect.</param>
		/// <returns type="MindFusion.Drawing.Rect">A Rect object representing the intersection of the two rectangles.</returns>
	},
	intersectsWith: function(rect) {
		/// <summary>Checks if this Rect intersects with the specified rect.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The other Rect.</param>
		/// <returns type="Boolean">true if this Rect and the specified Rect intersect; otherwise, false.</returns>
	},
	isEmpty: function() {
		/// <summary>Gets a value indicating whether this Rect is empty.</summary>
		/// <returns type="Boolean">true if both width and height are 0; otherwise, false.</returns>
	},
	left: function() {
		/// <summary>Gets the x-coordinate of the left edge of this Rect object.</summary>
		/// <returns type="Number">The x-coordinate of the left edge of this Rect object.</returns>
	},
	right: function() {
		/// <summary>Gets the x-coordinate that is the sum of x and width values of this Rect.</summary>
		/// <returns type="Number">The x-coordinate that is the sum of x and width of this rectangle.</returns>
	},
	setCenter: function(point) {
		/// <summary>Sets the center of this Rect object.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The center of this Rect.</param>
	},
	setLocation: function(point) {
		/// <summary>Sets the top-left edge of this Rect object.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The top-left edge of the Rect.</param>
	},
	top: function() {
		/// <summary>Gets the y-coordinate of the top edge of this Rect object.</summary>
	},
	topLeft: function() {
		/// <summary>Gets the top-left edge of this Rect.</summary>
		/// <returns type="MindFusion.Drawing.Point">The top-left edge of this Rect.</returns>
	},
	topMiddle: function() {
		/// <summary>Gets the top-middle of this Rect object.</summary>
		/// <returns type="MindFusion.Drawing.Point">The top-middle coordinate, which is a Point with x that is the sum of x and half of width and with y equal to y.</returns>
	},
	topRight: function() {
		/// <summary>Gets the top-right edge of this Rect object.</summary>
		/// <returns type="MindFusion.Drawing.Point">The top-right edge, which is a Point with x that is the sum of x and width and with y equal to y.</returns>
	},
	union: function(rect) {
		/// <summary>Returns a Rect object representing the union of the current rectangle with the specified rectangle.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle to union.</param>
		/// <returns type="MindFusion.Drawing.Rect">A Rect object that bounds the union of the two rectangles.</returns>
	}
};
MindFusion.Drawing.Rect.__class = true;

MindFusion.Drawing.Rect.fromLTRB = function(l, t, r, b) {
	/// <summary>Creates a Rect object with the specified edge locations.</summary>
	/// <param name="l" type="Number">The x-coordinate of the upper-left corner of this Rect.</param>
	/// <param name="t" type="Number">The y-coordinate of the upper-left corner of this Rect.</param>
	/// <param name="r" type="Number">The x-coordinate of the lower-right corner of this Rect.</param>
	/// <param name="b" type="Number">The y-coordinate of the lower-right corner of this Rect.</param>
	/// <returns type="MindFusion.Drawing.Rect">A rectangle with the specified coordinates.</returns>
};

MindFusion.Drawing.right.prototype = {
};
MindFusion.Drawing.right.__class = true;

MindFusion.Drawing.size.prototype = {
};
MindFusion.Drawing.size.__class = true;

MindFusion.Drawing.Size.prototype = {
	empty: function() {
		/// <summary>Gets a value indicating whether this Size is empty.</summary>
		/// <returns type="Boolean">true if both width and height are 0; otherwise, false.</returns>
	}
};
MindFusion.Drawing.Size.__class = true;

MindFusion.Drawing.text.prototype = {
};
MindFusion.Drawing.text.__class = true;

MindFusion.Drawing.Text.prototype = {
	clone: function() {
		/// <summary>Creates a Text object identical to the current object.</summary>
		/// <returns type="MindFusion.Drawing.Text">The newly created Text object.</returns>
	},
	getBounds: function() {
		/// <summary>Gets a value indicating the bounding rectangle of the text container.</summary>
		/// <returns type="Rect">The bounding rectangle.</returns>
	},
	getFont: function() {
		/// <summary>Gets the font of the text.</summary>
		/// <returns type="Font">The font of the text.</returns>
	},
	getRotationAngle: function() {
		/// <summary>Gets a value indicating the rotation of the text container.</summary>
		/// <returns type="Number">The angle.</returns>
	},
	getText: function() {
		/// <summary>Gets the text to be displayed.</summary>
		/// <returns type="String">The text.</returns>
	},
	setBounds: function(bounds, angle) {
		/// <summary>Sets a value indicating the bounding rectangle of the text container.</summary>
		/// <param name="bounds" type="Rect">The bounding rectangle.</param>
		/// <param name="angle" type="Number" optional="true">Optional. The rotation angle to be applied to the bounding rectangle.</param>
	},
	setFont: function(value) {
		/// <summary>Sets the font of the text.</summary>
		/// <param name="value" type="void"></param>
	},
	setText: function(value) {
		/// <summary>Sets the text to be displayed.</summary>
		/// <param name="value" type="void"></param>
	}
};
MindFusion.Drawing.Text.__class = true;

MindFusion.Drawing.Thickness.prototype = {
};
MindFusion.Drawing.Thickness.__class = true;

MindFusion.Drawing.top.prototype = {
};
MindFusion.Drawing.top.__class = true;

MindFusion.Drawing.underline.prototype = {
};
MindFusion.Drawing.underline.__class = true;

MindFusion.Drawing.Vector.prototype = {
};
MindFusion.Drawing.Vector.__class = true;

MindFusion.Drawing.Visibility = {
	/// <summary>Specifies visibility for components.</summary>
	/// <field name="Collapsed">Specifies that the component is hidden, and the space it occupies in the layout is not preserved.</field>
	/// <field name="Hidden">Specifies that the component is hidden, but the space it occupies in the layout is preserved.</field>
	/// <field name="Visible">Specifies that the component is visible.</field>
	Collapsed: 0,
	Hidden: 1,
	Visible: 2
}
MindFusion.Drawing.Visibility.__enum = true;

MindFusion.Drawing.width.prototype = {
};
MindFusion.Drawing.width.__class = true;

MindFusion.Drawing.x.prototype = {
};
MindFusion.Drawing.x.__class = true;

MindFusion.Drawing.y.prototype = {
};
MindFusion.Drawing.y.__class = true;

MindFusion.Drawing.zoomFactor.prototype = {
};
MindFusion.Drawing.zoomFactor.__class = true;

MindFusion.Controls.Alignment = {
	/// <summary>Specifies the alignment of text relative to its layout rectangle.</summary>
	/// <field name="Center">The text is drawn in the center of the layout rectangle.</field>
	/// <field name="Far">The text is drawn in the far corner of the layout rectangle.</field>
	/// <field name="Near">The text is drawn in the near corner of the layout rectangle.</field>
	Center: 0,
	Far: 1,
	Near: 2
}
MindFusion.Controls.Alignment.__enum = true;

MindFusion.Controls.MouseCursors.prototype = {
};
MindFusion.Controls.MouseCursors.__class = true;

MindFusion.Controls.TickPosition = {
	/// <summary>Specifies the position of trackbar ticks.</summary>
	/// <field name="Both">Ticks are rendered on both sides of the trackbar.</field>
	/// <field name="Left">Ticks are rendered on the left side of the trackbar.</field>
	/// <field name="None">There are no ticks rendered.</field>
	/// <field name="Right">Ticks are rendered on the right side of the trackbar.</field>
	Both: 0,
	Left: 1,
	None: 2,
	Right: 3
}
MindFusion.Controls.TickPosition.__enum = true;

MindFusion.Controls.ZoomControl.prototype = {
	getActiveColor: function() {
		/// <summary>Gets the color used to render depressed buttons.</summary>
		/// <returns type="String">The color used to render depressed buttons.</returns>
	},
	getAutoPostBack: function() {
		/// <summary>Gets a value indicating whether the control will post back to the server when the control's value has changed.</summary>
		/// <returns type="Boolean">true if the control should post back, otherwise, false.</returns>
	},
	getBackColor: function() {
		/// <summary>Gets the background color of the control.</summary>
		/// <returns type="String">The color of the control background.</returns>
	},
	getBorderColor: function() {
		/// <summary>Gets the color of ZoomControl elements' borders.</summary>
		/// <returns type="String">The color of ZoomControl elements' borders.</returns>
	},
	getCornerRadius: function() {
		/// <summary>Gets the corner radius of rounded child elements.</summary>
		/// <returns type="Number">The corner radius of rounded child elements.</returns>
	},
	getEnabled: function() {
		/// <summary>Checks if mouse events are enabled.</summary>
		/// <returns type="Boolean">true if handling of mouse events is enabled; otherwise, false.</returns>
	},
	getFill: function() {
		/// <summary>Gets the color used to fill the ZoomControl elements.</summary>
		/// <returns type="String">The color used to fill the ZoomControl elements.</returns>
	},
	getInnerColor: function() {
		/// <summary>Gets the color of plus, minus and arrow icons.</summary>
		/// <returns type="String">The color of plus, minus and arrow icons.</returns>
	},
	getMaxZoomFactor: function() {
		/// <summary>Gets the maximum zoom level allowed to set through this control.</summary>
		/// <returns type="Number">The maximum zoom level.</returns>
	},
	getMinZoomFactor: function() {
		/// <summary>Gets the minimum zoom level allowed to set through this control.</summary>
		/// <returns type="Number">The minimum zoom level.</returns>
	},
	getPadding: function() {
		/// <summary>Gets the padding of the control's contents.</summary>
		/// <returns type="Number">The padding of the control's contents.</returns>
	},
	getScrollStep: function() {
		/// <summary>Gets the scroll offset added when users click the pan arrows.</summary>
		/// <returns type="Number">The scroll step.</returns>
	},
	getShadowColor: function() {
		/// <summary>Gets the color of the control elements' shadow.</summary>
		/// <returns type="String">The color of the control elements' shadow.</returns>
	},
	getShowLabel: function() {
		/// <summary>Gets a value indicating whether the label that shows the current zoom level should be visible.</summary>
		/// <returns type="Boolean">True if the label is visible, otherwise false.</returns>
	},
	getSnapToZoomStep: function() {
		/// <summary>Gets a value indicating whether the trackbar should snap to ZoomStep values when dragged.</summary>
		/// <returns type="Boolean">True if snapping is enabled, otherwise false.</returns>
	},
	getTextColor: function() {
		/// <summary>Gets the color of the the label that shows the current zoom level.</summary>
		/// <returns type="String">The color of the the label that shows the current zoom level.</returns>
	},
	getTickPosition: function() {
		/// <summary>Gets the current tick position of the trackbar.</summary>
		/// <returns type="MindFusion.Controls.TickPosition">One of the TickPosition enumeration values.</returns>
	},
	getZoomFactor: function() {
		/// <summary>Gets the zoom factor.</summary>
		/// <returns type="Number">The current zoom factor.</returns>
	},
	getZoomStep: function() {
		/// <summary>Gets the amount by which to change zoom level when + and - buttons are clicked.</summary>
		/// <returns type="Number">The zoom step.</returns>
	},
	registerForSubmit: function(id) {
		/// <summary>Registers an onsubmit handler for the ZoomControl's parent html form to flush postback data.</summary>
		/// <param name="id" type="String">The id of the hidden field to flush the data to.</param>
	},
	setActiveColor: function(value) {
		/// <summary>Sets the color used to render depressed buttons.</summary>
		/// <param name="value" type="String">The color used to render depressed buttons.</param>
	},
	setAutoPostBack: function(value) {
		/// <summary>Sets a value indicating whether the control should post back to the server when the control's value has changed.</summary>
		/// <param name="value" type="Boolean">true if the control should post back, otherwise, false.</param>
	},
	setBackColor: function(value) {
		/// <summary>Sets the background color of the control.</summary>
		/// <param name="value" type="String">The color of the control background.</param>
	},
	setBorderColor: function(value) {
		/// <summary>Sets the color of ZoomControl elements' borders.</summary>
		/// <param name="value" type="String">The color of ZoomControl elements' borders.</param>
	},
	setCornerRadius: function(value) {
		/// <summary>Sets the corner radius of rounded child elements.</summary>
		/// <param name="value" type="Number">The corner radius of rounded child elements.</param>
	},
	setEnabled: function(value) {
		/// <summary>Enables or disables handling of mouse events.</summary>
		/// <param name="value" type="Boolean">true if handling of mouse events is enabled; otherwise, false.</param>
	},
	setFill: function(value) {
		/// <summary>Sets the color used to fill the ZoomControl elements.</summary>
		/// <param name="value" type="String">The color used to fill the ZoomControl elements.</param>
	},
	setInnerColor: function(value) {
		/// <summary>Sets the color of plus, minus and arrow icons.</summary>
		/// <param name="value" type="String">The color of plus, minus and arrow icons.</param>
	},
	setMaxZoomFactor: function(value) {
		/// <summary>Sets the maximum zoom level allowed to set through this control.</summary>
		/// <param name="value" type="Number">The maximum zoom level.</param>
	},
	setMinZoomFactor: function(value) {
		/// <summary>Sets the minimum zoom level allowed to set through this control.</summary>
		/// <param name="value" type="Number">The minimum zoom level.</param>
	},
	setPadding: function(value) {
		/// <summary>Sets the padding of the control's contents.</summary>
		/// <param name="value" type="Number">The padding of the control's contents.</param>
	},
	setScrollStep: function(value) {
		/// <summary>Sets the scroll offset added when users click the pan arrows.</summary>
		/// <param name="value" type="Number">The scroll step.</param>
	},
	setShadowColor: function(value) {
		/// <summary>Sets the color of the control elements' shadow.</summary>
		/// <param name="value" type="String">The color of the control elements' shadow.</param>
	},
	setShowLabel: function(value) {
		/// <summary>Sets a value indicating whether the label that shows the current zoom level should be visible.</summary>
		/// <param name="value" type="Boolean">True if the label is visible, otherwise false.</param>
	},
	setSnapToZoomStep: function(value) {
		/// <summary>Sets a value indicating whether the trackbar should snap to ZoomStep values when dragged.</summary>
		/// <param name="value" type="Boolean">True if snapping is enabled, otherwise false.</param>
	},
	setTarget: function(target) {
		/// <summary>Sets the control modified by this ZoomControl.</summary>
		/// <param name="target" type="MindFusion.Dom.Control" optional="true">Optional. The control modified by this ZoomControl.</param>
	},
	setTextColor: function(value) {
		/// <summary>Sets the color of the the label that shows the current zoom level.</summary>
		/// <param name="value" type="String">The color of the the label that shows the current zoom level.</param>
	},
	setTickPosition: function(value) {
		/// <summary>Sets the current tick position of the trackbar.</summary>
		/// <param name="value" type="MindFusion.Controls.TickPosition">One of the TickPosition enumeration values.</param>
	},
	setZoomFactor: function(value) {
		/// <summary>Sets the zoom factor.</summary>
		/// <param name="value" type="Number">The zoom factor.</param>
	},
	setZoomStep: function(value) {
		/// <summary>Sets the amount by which to change zoom level when + and - buttons are clicked.</summary>
		/// <param name="value" type="Number">The zoom step.</param>
	}
};
MindFusion.Controls.ZoomControl.__class = true;

MindFusion.Controls.ZoomControl.create = function(element) {
	/// <summary>Creates and initializes a new ZoomControl from the specified element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the zoomControl should be attached to.</param>
	/// <returns type="MindFusion.Controls.ZoomControl">A ZoomControl object that represents the newly created zoomControl.</returns>
};
MindFusion.Controls.ZoomControl.find = function(id, parent) {
	/// <summary>Returns the specified ZoomControl object. This member is static and can be invoked without creating an instance of the class.</summary>
	/// <param name="id" type="String">A string that contains the ID of the zoomControl to find.</param>
	/// <param name="parent" type="Object" optional="true">Optional. The component or element that contains the zoomControl to find.</param>
	/// <returns type="MindFusion.Controls.ZoomControl">A ZoomControl object that contains the zoomControl requested by id, if found; otherwise, null.</returns>
};

MindFusion.Animations.Animation.prototype = {
	addEventListener: function(eventName, handler) {
		/// <summary>Registers a single event listener on the Animation.</summary>
		/// <param name="eventName" type="String">The name of the event.</param>
		/// <param name="handler" type="Method">Represents the method that will handle the event specified with eventName.</param>
	},
	dispose: function() {
		/// <summary>Sys.IDisposable implementation.</summary>
	},
	getAnimationType: function() {
		/// <summary>Gets the type of the animation.</summary>
		/// <returns type="MindFusion.Animations.AnimationType">The animation type.</returns>
	},
	getDuration: function() {
		/// <summary>Gets the duration of the animation function in milliseconds.</summary>
		/// <returns type="Number">The duration of the animation.</returns>
	},
	getEasingType: function() {
		/// <summary>Gets the easing type of the animation.</summary>
		/// <returns type="MindFusion.Animations.EasingType">The easing type.</returns>
	},
	getFromValue: function() {
		/// <summary>Gets the initial value of the property that will be animated.</summary>
		/// <returns type="Object">The initial value.</returns>
	},
	getParam: function() {
		/// <summary>Gets the optional parameter to use in the animation function.</summary>
		/// <returns type="Object">The optional parameter.</returns>
	},
	getProgress: function() {
		/// <summary>Gets the progress of the current animation iteration.</summary>
	},
	getRepeat: function() {
		/// <summary>Gets a value indicating whether to restart the animation after it completes.</summary>
		/// <returns type="Boolean">True to loop the animation, otherwise false.</returns>
	},
	getReverse: function() {
		/// <summary>Gets a value indicating whether to swap the from and to values after the animation completes.</summary>
		/// <returns type="Boolean">True to swap the values, otherwise false.</returns>
	},
	getToValue: function() {
		/// <summary>Gets the target value of the property that will be animated.</summary>
		/// <returns type="Object">The target value.</returns>
	},
	isRunning: function() {
		/// <summary>Indicates whether the animation is currently running.</summary>
	},
	raiseEvent: function(eventName, args) {
		/// <summary>Raises an event.</summary>
		/// <param name="eventName" type="String">The name of the event to raise.</param>
		/// <param name="args" type="EventArgs">An instance of type EventArgs that holds data for the event specified with eventName.</param>
	},
	removeEventListener: function(eventName, handler) {
		/// <summary>Removes a single event listener attached to the Animation.</summary>
		/// <param name="eventName" type="String">The name of the event.</param>
		/// <param name="handler" type="Method">Represents the method that handles the event specified with eventName.</param>
	},
	setAnimationType: function(value) {
		/// <summary>Sets the type of the animation.</summary>
		/// <param name="value" type="MindFusion.Animations.AnimationType">The animation type. The default value is AnimationType.Linear.</param>
	},
	setDuration: function(value) {
		/// <summary>Sets the duration of the animation function in milliseconds.</summary>
		/// <param name="value" type="Number">The duration of the animation. The default value is 1000.</param>
	},
	setEasingType: function(value) {
		/// <summary>Sets the easing type of the animation.</summary>
		/// <param name="value" type="MindFusion.Animations.EasingType">The easing type. The default value is EasingType.EaseIn.</param>
	},
	setFromValue: function(value) {
		/// <summary>Sets the initial value of the property that will be animated.</summary>
		/// <param name="value" type="Object">The initial value.</param>
	},
	setParam: function(value) {
		/// <summary>Sets the optional parameter to use in the animation function.</summary>
		/// <param name="value" type="Object">The optional parameter. The default value is null.</param>
	},
	setRepeat: function(value) {
		/// <summary>Sets a value indicating whether to restart the animation after it completes.</summary>
		/// <param name="value" type="Boolean">True to loop the animation, otherwise false. The default value is false.</param>
	},
	setReverse: function(value) {
		/// <summary>Sets a value indicating whether to swap the from and to values after the animation completes.</summary>
		/// <param name="value" type="Boolean">True to swap the values, otherwise false. The default value is false.</param>
	},
	setToValue: function(The) {
		/// <summary>Sets the target value of the property that will be animated.</summary>
		/// <param name="The" type="Object">target value.</param>
	},
	start: function() {
		/// <summary>Starts or resumes the animation.</summary>
	},
	stop: function() {
		/// <summary>Stops the animation.</summary>
	}
};
MindFusion.Animations.Animation.__class = true;

MindFusion.Animations.AnimationType = {
	/// <summary>Specifies the animation function used by an Animation object.</summary>
	/// <field name="BackBow">Represents an effect that simulates a retraction in the motion of the animation. The amplitude of the retraction can be controlled through the Animation's param property. The default param value is 1.5;</field>
	/// <field name="Bounce">Represents a bouncing effect animation.</field>
	/// <field name="Circular">Represents an animation that accelerates/deccelerates using a circular function.</field>
	/// <field name="Custom">Specifies a user-set function. When this value is used the actual animation function must be set through the Animation's custom function callback.</field>
	/// <field name="Elastic">Represents an oscillating effect animation. The oscillation frequency can be controlled through the Animation's param property. The default param value is 0.5;</field>
	/// <field name="Exponential">Represents an animation that accelerates/deccelerates using an exponential function. The exponent can be set through the Animation's param property. The default exponent equals 10.</field>
	/// <field name="Linear">Represents an animation that accelerates/deccelerates using a linear function.</field>
	/// <field name="Power">Represents an animation that accelerates/deccelerates through exponentiation formula - x^n where n can be set through the Animation's param property. The default exponent equals 2.</field>
	BackBow: 0,
	Bounce: 1,
	Circular: 2,
	Custom: 3,
	Elastic: 4,
	Exponential: 5,
	Linear: 6,
	Power: 7
}
MindFusion.Animations.AnimationType.__enum = true;

MindFusion.Animations.EasingType = {
	/// <summary>Specifies the easing applied to an animation.</summary>
	/// <field name="EaseIn">Follows the animation function associated with the Animation.</field>
	/// <field name="EaseInOut">Uses EaseIn for the first half the the Animation's duration and EaseOut for the second half.</field>
	/// <field name="EaseOut">Inverses the animation function associated with the Animation.</field>
	/// <field name="EaseOutIn">Uses EaseOut for the first half the the Animation's duration and EaseIn for the second half.</field>
	EaseIn: 0,
	EaseInOut: 1,
	EaseOut: 2,
	EaseOutIn: 3
}
MindFusion.Animations.EasingType.__enum = true;

MindFusion.Animations.Events.prototype = {
};
MindFusion.Animations.Events.__class = true;


MindFusion.Animations.Events.animationComplete = function() {
	/// <summary>Raised when an Animation is complete.</summary>
};

MindFusion.Animations.item.prototype = {
};
MindFusion.Animations.item.__class = true;

MindFusion.Collections.ArrayList.prototype = {
};
MindFusion.Collections.ArrayList.__class = true;

MindFusion.Collections.Dictionary.prototype = {
	contains: function(key) {
		/// <summary>Determines whether the dictionary contains a specific key.</summary>
		/// <param name="key" type="Object">The key to locate in the dictionary.</param>
		/// <returns type="Boolean">true if the dictionary contains an element with the specified key; otherwise, false.</returns>
	},
	forEach: function(func, thisRef) {
		/// <summary>Calls a defined callback function for each entry in the dictionary.</summary>
		/// <param name="func" type="Function">A function that accepts three arguments. forEach calls this function one time for each element in the dictionary.</param>
		/// <param name="thisRef" type="Object" optional="true">Optional. A value passed as the first parameter of func.</param>
	},
	forEachKey: function(func, thisRef) {
		/// <summary>Calls a defined callback function for each key in the dictionary.</summary>
		/// <param name="func" type="Function">A function that accepts two arguments. forEachKey calls this function one time for each key in the dictionary.</param>
		/// <param name="thisRef" type="Object" optional="true">Optional. A value passed as the first parameter of func.</param>
	},
	forEachValue: function(func, thisRef) {
		/// <summary>Calls a defined callback function for each value in the dictionary.</summary>
		/// <param name="func" type="Function">A function that accepts two arguments. forEachValue calls this function one time for each value in the dictionary.</param>
		/// <param name="thisRef" type="Object" optional="true">Optional. A value passed as the first parameter of func.</param>
	},
	get: function(key) {
		/// <summary>Gets the value associated with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">The key whose value to get.</param>
		/// <returns type="Object">The value associated with the specified key.</returns>
	},
	keys: function() {
		/// <summary>Gets an array with all keys in the dictionary.</summary>
		/// <returns type="Array">An array containing all keys in the dictionary.</returns>
	},
	remove: function(key) {
		/// <summary>Removes the element with the specified key from the dictionary.</summary>
		/// <param name="key" type="Object">The key of the element to remove.</param>
		/// <returns type="Object">The value corresponding to the specified key or null, if the key is not found.</returns>
	},
	set: function(key, value) {
		/// <summary>Associates the specified value with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">The key to associate the value with.</param>
		/// <param name="value" type="Object">The value to associate.</param>
	}
};
MindFusion.Collections.Dictionary.__class = true;

MindFusion.Collections.Grid.prototype = {
};
MindFusion.Collections.Grid.__class = true;

MindFusion.Collections.ItemEventArgs.prototype = {
	get_item: function() {
		/// <summary>Gets the item related to the event.</summary>
		/// <returns type="Object"></returns>
	}
};
MindFusion.Collections.ItemEventArgs.__class = true;

MindFusion.Collections.ObservableCollection.prototype = {
	add: function(item) {
		/// <summary>Adds the specified element to the collection.</summary>
		/// <param name="item" type="Object">The element to add.</param>
	},
	add_itemAdded: function(handler) {
		/// <summary>Registers the specified function as a handler for the itemAdded event.</summary>
		/// <param name="handler" type="Function">The function to be invoked when items are added to the collection.</param>
	},
	remove_itemAdded: function(handler) {
		/// <summary>Unregisters the specified function as a handler for the itemAdded event.</summary>
		/// <param name="handler" type="Function">The function to unregister.</param>
	}
};
MindFusion.Collections.ObservableCollection.__class = true;

MindFusion.Collections.Queue.prototype = {
	dequeue: function() {
		/// <summary>Removes and returns the object at the beginning of the queue.</summary>
		/// <returns type="Object">The object that is removed from the beginning of the queue.</returns>
	},
	enqueue: function(value) {
		/// <summary>Adds an object to the end of the queue.</summary>
		/// <param name="value" type="Object">The object to add.</param>
	},
	getSize: function() {
		/// <summary>Gets the number of elements in the queue.</summary>
		/// <returns type="Number"></returns>
	}
};
MindFusion.Collections.Queue.__class = true;

MindFusion.Collections.Set.prototype = {
	add: function(key) {
		/// <summary>Adds the specified value to the set.</summary>
		/// <param name="key" type="Object">The element to add to the set.</param>
	},
	contains: function(key) {
		/// <summary>Determines whether the set contains a specific value.</summary>
		/// <param name="key" type="Object">The element to locate in the set.</param>
		/// <returns type="Boolean">true if the set contains the specified element; otherwise, false.</returns>
	},
	forEach: function(func, thisRef) {
		/// <summary>Calls a defined callback function for each entry in the set.</summary>
		/// <param name="func" type="Function">A function that accepts two arguments. forEach calls this function one time for each element in the set.</param>
		/// <param name="thisRef" type="Object" optional="true">Optional. A value passed as the first parameter of func.</param>
	},
	remove: function(key) {
		/// <summary>Removes the specified element from the set.</summary>
		/// <param name="key" type="Object">The element to remove.</param>
	}
};
MindFusion.Collections.Set.__class = true;

MindFusion.Mapping.Bubble.prototype = {
};
MindFusion.Mapping.Bubble.__class = true;

MindFusion.Mapping.CancelEventArgs.prototype = {
};
MindFusion.Mapping.CancelEventArgs.__class = true;

MindFusion.Mapping.Control.prototype = {
	attach: function() {
		/// <summary>Attach control event handlers.</summary>
	},
	detach: function() {
		/// <summary>Detach control event handlers.</summary>
	},
	dispose: function() {
		/// <summary>Dispose the control.</summary>
	},
	draw: function() {
		/// <summary>Draws the control.</summary>
		/// <returns type="HTMLElement">HTMLElement. The control DOM element.</returns>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction.</summary>
	}
};
MindFusion.Mapping.Control.__class = true;

MindFusion.Mapping.ControlState = {
	/// <summary>Specifies a control state.</summary>
	/// <field name="Loaded">The control is loaded and ready for interaction.</field>
	/// <field name="Unloaded">The control is unloaded.</field>
	Loaded: 0,
	Unloaded: 1
}
MindFusion.Mapping.ControlState.__enum = true;

MindFusion.Mapping.Decoration.prototype = {
};
MindFusion.Mapping.Decoration.__class = true;

MindFusion.Mapping.DecorationEventArgs.prototype = {
};
MindFusion.Mapping.DecorationEventArgs.__class = true;

MindFusion.Mapping.DecorationLayer.prototype = {
};
MindFusion.Mapping.DecorationLayer.__class = true;

MindFusion.Mapping.Dictionary.prototype = {
	contains: function(key) {
		/// <summary>Determines whether the dictionary contains a specific key.</summary>
		/// <param name="key" type="Object">Object. The key to locate in the dictionary.</param>
		/// <returns type="Boolean">Boolean. true if the element exists in the collection, otherwise false.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object" optional="true">Optional. Object. The invokation context.</param>
	},
	get: function(key) {
		/// <summary>Gets the value associated with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key whose value to get.</param>
	},
	remove: function(key) {
		/// <summary>Removes the element with the specified key from the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key of the element to remove.</param>
	},
	set: function(key, value) {
		/// <summary>Associates the specified value with the specified key within the dictionary.</summary>
		/// <param name="key" type="Object">Object. The key to associate the value with.</param>
		/// <param name="value" type="Object">Object. The value to associate.</param>
	}
};
MindFusion.Mapping.Dictionary.__class = true;

MindFusion.Mapping.EmptyEventArgs.prototype = {
};
MindFusion.Mapping.EmptyEventArgs.__class = true;

MindFusion.Mapping.EventArgs.prototype = {
};
MindFusion.Mapping.EventArgs.__class = true;

MindFusion.Mapping.EventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event.</summary>
		/// <param name="handler" type="function">function. The handler function.</param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event.</summary>
		/// <param name="sender" type="Object">Object. The source of the event.</param>
		/// <param name="args" type="Object">Object. An object, containing event data.</param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event.</summary>
		/// <param name="handler" type="function">function. The handler function.</param>
	}
};
MindFusion.Mapping.EventDispatcher.__class = true;

MindFusion.Mapping.Hint.prototype = {
};
MindFusion.Mapping.Hint.__class = true;

MindFusion.Mapping.IEnumerable.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection.</summary>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection.</summary>
		/// <returns type="IEnumerable">IEnumerable. A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection.</summary>
		/// <param name="item" type="Object">Object. The object to check for.</param>
		/// <returns type="Boolean">Boolean. True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection.</summary>
		/// <param name="destination" type="IEnumerable">IEnumerable. The destination collection.</param>
		/// <param name="length" type="Number">Number. The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. Number. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. Number. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements.</summary>
		/// <returns type="Number">Number. The number of elements.</returns>
	},
	first: function() {
		/// <summary>Returns the first element in the collection.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection.</summary>
		/// <param name="obj" type="Object">Object. The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. Number. The starting index to search from.</param>
		/// <returns type="Number">Number. The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <returns type="Object">Object. The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection.</returns>
	},
	last: function() {
		/// <summary>Returns the last element in the collection.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns the maximum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection.</summary>
		/// <param name="item" type="Object">Object. The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index.</summary>
		/// <param name="index" type="Number">Number. The starting index of the range.</param>
		/// <param name="count" type="Number">Number. The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order.</summary>
		/// <returns type="Array">Array. The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array.</summary>
		/// <param name="compareFn" type="function" optional="true">Optional. function. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that are obtained by invoking a transform function on each element.</summary>
		/// <param name="selector" type="function">function. A transform function to invoke on each element.</param>
		/// <returns type="Number">Number. The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection.</summary>
		/// <returns type="Array">Array. The array.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Mapping.IEnumerable.__class = true;

MindFusion.Mapping.LatLong.prototype = {
};
MindFusion.Mapping.LatLong.__class = true;

MindFusion.Mapping.LayerController.prototype = {
};
MindFusion.Mapping.LayerController.__class = true;

MindFusion.Mapping.List.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection. Inherited from IEnumerable.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <param name="item" type="T">The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The starting index of the range.</param>
		/// <param name="count" type="Number">The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Mapping.List.__class = true;

MindFusion.Mapping.MapEventArgs.prototype = {
};
MindFusion.Mapping.MapEventArgs.__class = true;

MindFusion.Mapping.MapLayer.prototype = {
};
MindFusion.Mapping.MapLayer.__class = true;

MindFusion.Mapping.MapView.prototype = {
	attach: function() {
		/// <summary>Control.attach override.</summary>
	},
	clientToLatLong: function(point) {
		/// <summary>Converts the specified client point to geographic coordinates.</summary>
		/// <param name="point" type="Point">Point. The client point to convert.</param>
		/// <returns type="LatLong">LatLong. A LatLong instance representing the geographic location.</returns>
	},
	detach: function() {
		/// <summary>Control.detach override.</summary>
	},
	draw: function() {
		/// <summary>Control.draw override.</summary>
	},
	getDecorationsAt: function(point) {
		/// <summary>Gets the list of decoration at a specified client position.</summary>
		/// <param name="point" type="Point">Point. The point to test.</param>
		/// <returns type="Array">Array. An array of Decoration instances.</returns>
	},
	latLongToClient: function(location) {
		/// <summary>Converts the specified geographic coordinates to a client position.</summary>
		/// <param name="location" type="LatLong">LatLong. The location to convert.</param>
		/// <returns type="Point">Point. A Point instance representing The client point.</returns>
	},
	load: function(center, zoomLevel) {
		/// <summary>Loads all layers.</summary>
		/// <param name="center" type="LatLong">LatLong. A LatLong instance representing the georgaphical center of the map.</param>
		/// <param name="zoomLevel" type="Number" optional="true">Optional. Number. The zoom level of the map.</param>
	},
	loadOverlays: function() {
		/// <summary>Loads decoration layers.</summary>
	},
	panTo: function(center) {
		/// <summary>Pans the map to a new center location.</summary>
		/// <param name="center" type="LatLong">LatLong. A LatLong instance representing the geographic location of the new map center.</param>
	},
	scrollBy: function(x, y) {
		/// <summary>Scrolls the map by the specified amount.</summary>
		/// <param name="x" type="Number">Number. The number of pixels to scroll horizontally.</param>
		/// <param name="y" type="Number" optional="true">Optional. Number. The number of pixels to scroll vertically.</param>
	},
	scrollTo: function(center) {
		/// <summary>Scrolls the map to a new center point.</summary>
		/// <param name="center" type="Point">Point. A Point instance representing the client position of the new map center.</param>
	},
	dispose: function() {
		/// <summary>Dispose the control. Inherited from Control.</summary>
	},
	render: function() {
		/// <summary>Draws the control and prepares it for user interaction. Inherited from Control.</summary>
	}
};
MindFusion.Mapping.MapView.__class = true;

MindFusion.Mapping.Marker.prototype = {
};
MindFusion.Mapping.Marker.__class = true;

MindFusion.Mapping.NotifyCollectionChangedAction.prototype = {
};
MindFusion.Mapping.NotifyCollectionChangedAction.__class = true;

MindFusion.Mapping.NotifyCollectionChangedEventArgs.prototype = {
};
MindFusion.Mapping.NotifyCollectionChangedEventArgs.__class = true;

MindFusion.Mapping.NotifyCollectionChangingEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled. Inherited from CancelEventArgs.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.Mapping.NotifyCollectionChangingEventArgs.__class = true;

MindFusion.Mapping.ObservableCollection.prototype = {
	add: function(item) {
		/// <summary>Adds an item to the collection.</summary>
		/// <param name="item" type="Object">Object. The item to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	insert: function(index, item) {
		/// <summary>Adds an item to the collection at the specified index.</summary>
		/// <param name="index" type="Number">Number. The index.</param>
		/// <param name="item" type="Object">Object. The object to add.</param>
	},
	remove: function(item) {
		/// <summary>Deletes an item from the collection.</summary>
		/// <param name="item" type="Object">Object. The item to remove.</param>
	},
	removeAt: function(itemIndex) {
		/// <summary>Delete the item at the specified index.</summary>
		/// <param name="itemIndex" type="Number">Number. The index to remove at.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Deletes a range of items from the collection.</summary>
		/// <param name="index" type="Number">Number. The starting index of the range to remove.</param>
		/// <param name="count" type="Number">Number. The length of the range to remove.</param>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection. Inherited from IEnumerable.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection. Inherited from IEnumerable.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements. Inherited from IEnumerable.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection. Inherited from IEnumerable.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index. Inherited from IEnumerable.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array. Inherited from IEnumerable.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Array<T>">The array.</returns>
	},
	addRange: function(range) {
		/// <summary>Adds a range of elements to the end of the collection. Inherited from IEnumerable.</summary>
		/// <param name="range" type="Array">Array. The range to add.</param>
	},
	first: function() {
		/// <summary>Returns the first element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The first element in the collection.</returns>
	},
	forEach: function(callback, context) {
		/// <summary>Executes a provided function once for each element. Inherited from IEnumerable.</summary>
		/// <param name="callback" type="function">function. A function to execute for each element.</param>
		/// <param name="context" type="Object">Object. The invokation context.</param>
	},
	last: function() {
		/// <summary>Returns the last element in the collection. Inherited from IEnumerable.</summary>
		/// <returns type="Object">Object. The last element in the collection.</returns>
	},
	where: function(selector) {
		/// <summary>Filters a sequence of values based on a predicate. Inherited from IEnumerable.</summary>
		/// <param name="selector" type="function">function. A function to test each element for a condition.</param>
		/// <returns type="IEnumerable">IEnumerable. An collection that contains elements from the input sequence that satisfy the condition.</returns>
	}
};
MindFusion.Mapping.ObservableCollection.__class = true;

MindFusion.Mapping.PropertyEventArgs.prototype = {
};
MindFusion.Mapping.PropertyEventArgs.__class = true;

MindFusion.Mapping.Unit.prototype = {
	toString: function() {
		/// <summary>Returns a string representation of this Unit.</summary>
		/// <returns type="String">String. The string representation.</returns>
	}
};
MindFusion.Mapping.Unit.__class = true;

MindFusion.Mapping.Unit.empty = function() {
	/// <summary>Creates an empty Unit instance.</summary>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};
MindFusion.Mapping.Unit.percentage = function(value) {
	/// <summary>Creates a Unit instance with the specified value and UnitType.Percent.</summary>
	/// <param name="value" type="Number">Number. The value of the unit.</param>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};
MindFusion.Mapping.Unit.pixel = function(value) {
	/// <summary>Creates a Unit instance with the specified value and UnitType.Pixel.</summary>
	/// <param name="value" type="Number">Number. The value of the unit.</param>
	/// <returns type="Unit">Unit. The new Unit.</returns>
};

MindFusion.Mapping.UnitType = {
	/// <summary>Specifies a unit of measurement.</summary>
	/// <field name="Percent">The measurement is a percentage relative to the parent element.</field>
	/// <field name="Pixel">The measurement is in pixels.</field>
	Percent: 2,
	Pixel: 1
}
MindFusion.Mapping.UnitType.__enum = true;

MindFusion.Mapping.ZoomController.prototype = {
};
MindFusion.Mapping.ZoomController.__class = true;

MindFusion.Charting.Controls.AreaChart.prototype = {
};
MindFusion.Charting.Controls.AreaChart.__class = true;

MindFusion.Charting.Controls.BarChart.prototype = {
	createPlot: function() {
		/// <summary>Chart.CreatePlot override. Creates the Plot type corresponding to this chart.</summary>
		/// <returns type="Plot">An instance of the Plot2D class.</returns>
	}
};
MindFusion.Charting.Controls.BarChart.__class = true;

MindFusion.Charting.Controls.BarChart3D.prototype = {
	createPlot: function() {
		/// <summary>Chart.CreatePlot override. Creates the Plot type corresponding to this chart.</summary>
		/// <returns type="Plot">An instance of the Plot3D class.</returns>
	}
};
MindFusion.Charting.Controls.BarChart3D.__class = true;

MindFusion.Charting.Controls.BiaxialChart.prototype = {
	createRenderContext: function(graphics, clipRect) {
		/// <summary>Dashboard.CreateRenderContext override. Creates a RenderContext instance.</summary>
		/// <param name="graphics" type="MindFusion.Drawing.Graphics">An Graphics surface where dashboard elements should be rendered.</param>
		/// <param name="clipRect" type="MindFusion.Drawing.Rect">The current clip rectangle.</param>
		/// <returns type="MindFusion.Charting.RenderContext">A RenderContext instance.</returns>
	},
	resetZoom: function() {
		/// <summary>Chart.resetZoom override. Resets zoom level to original data range.</summary>
	},
	zoomOut: function() {
		/// <summary>Chart.zoomOut override. Zooms out of current data range.</summary>
	}
};
MindFusion.Charting.Controls.BiaxialChart.__class = true;

MindFusion.Charting.Controls.BubbleChart.prototype = {
};
MindFusion.Charting.Controls.BubbleChart.__class = true;

MindFusion.Charting.Controls.CandlestickChart.prototype = {
};
MindFusion.Charting.Controls.CandlestickChart.__class = true;

MindFusion.Charting.Controls.Chart.prototype = {
	createPlot: function() {
		/// <summary>Creates the Plot type corresponding to this chart.</summary>
		/// <returns type="Plot">An instance of Plot -derived class.</returns>
	},
	onPaddingChanged: function(e) {
		/// <summary>Control.OnPaddingChanged override.</summary>
		/// <param name="e" type="EventArgs">An EventArgs instance.</param>
	},
	onSizeChanged: function(e) {
		/// <summary>Control.OnSizeChanged override.</summary>
		/// <param name="e" type="EventArgs">An EventArgs instance.</param>
	},
	resetZoom: function() {
		/// <summary>Resets zoom level to original data range.</summary>
	},
	zoomOut: function() {
		/// <summary>Zooms out of current data range.</summary>
	}
};
MindFusion.Charting.Controls.Chart.__class = true;

MindFusion.Charting.Controls.Dashboard.prototype = {
	createRenderContext: function(graphics, clipRect) {
		/// <summary>Creates a RenderContext instance.</summary>
		/// <param name="graphics" type="MindFusion.Drawing.Graphics">A Graphics surface where dashboard elements should be rendered.</param>
		/// <param name="clipRect" type="MindFusion.Drawing.Rect">The current clip rectangle.</param>
		/// <returns type="MindFusion.Charting.RenderContext">A RenderContext instance.</returns>
	},
	dataBind: function() {
		/// <summary>Binds the chart to current DataSource.</summary>
	},
	draw: function(g, layoutRect, clipRect) {
		/// <summary>Draws the dashboard on specified Graphics surface.</summary>
		/// <param name="g" type="MindFusion.Drawing.Graphics">A Graphics instance.</param>
		/// <param name="layoutRect" type="MindFusion.Drawing.Rect">Current layout rectangle.</param>
		/// <param name="clipRect" type="MindFusion.Drawing.Rect">Current clip rectangle.</param>
	},
	fromJson: function(json) {
		/// <summary>Deserializes the control's data from JSON string.</summary>
		/// <param name="json" type="void"></param>
	},
	invalidate: function(rect, panel) {
		/// <summary>Implements RootControl.InvalidateLayout. Invalidates the specified region of a component.</summary>
		/// <param name="rect" type="RectD" optional="true">Optional. The area to invalidate and redraw.</param>
		/// <param name="panel" type="Components.Component" optional="true">Optional. The reference Component.</param>
	},
	invalidateLayout: function(panel) {
		/// <summary>Implements RootControl.InvalidateLayout. Invalidates layout of specified component.</summary>
		/// <param name="panel" type="Components.Component">The component to invalidate.</param>
	},
	onClick: function(e) {
		/// <summary>Raises the DataItemClicked eventif the user has clicked on data element in a plot.</summary>
		/// <param name="e" type="MouseEvent">A MouseEvent instance.</param>
	},
	onMouseDown: function(e) {
		/// <summary>Handles the HTMLCanvasElement mousedown event.</summary>
		/// <param name="e" type="MouseEvent">A MouseEvent instance.</param>
	},
	onMouseMove: function(e) {
		/// <summary>Handles the HTMLCanvasElement mousemove event.</summary>
		/// <param name="e" type="MouseEvent">A MouseEvent instance.</param>
	},
	onMouseUp: function(e) {
		/// <summary>Handles the HTMLCanvasElement mouseup event.</summary>
		/// <param name="e" type="MouseEvent">A MouseEvent instance.</param>
	},
	onResize: function(e) {
		/// <summary>Control.OnResize override. Invalidates the layout of child components and runs a new layout pass.</summary>
		/// <param name="e" type="EventArgs">An EventArgs instance.</param>
	},
	toJson: function() {
		/// <summary>Serializes the control's data to JSON string.</summary>
	}
};
MindFusion.Charting.Controls.Dashboard.__class = true;

MindFusion.Charting.Controls.FunnelChart.prototype = {
};
MindFusion.Charting.Controls.FunnelChart.__class = true;

MindFusion.Charting.Controls.LayoutBuilder.prototype = {
	create1By2ColumnLayout: function(col1, col2row1, col2row2) {
		/// <summary>Creates a two-column stack panel whose first column is a vertical stack of two components.</summary>
		/// <param name="col1" type="Component">The component in first column.</param>
		/// <param name="col2row1" type="Component">The first component in second column.</param>
		/// <param name="col2row2" type="Component">The second component in second column.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	create1By2RowLayout: function(row1, row2col1, row2col2) {
		/// <summary>Creates a two-row stack panel whose second row is a horizontal stack of two components.</summary>
		/// <param name="row1" type="Component">The component on first row.</param>
		/// <param name="row2col1" type="Component">The first component on second row.</param>
		/// <param name="row2col2" type="Component">The second component on second row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	create2By1ColumnLayout: function(col1row1, col1row2, col2) {
		/// <summary>Creates a two-column stack panel whose first column is a vertical stack of two components.</summary>
		/// <param name="col1row1" type="Component">The first component in first column.</param>
		/// <param name="col1row2" type="Component">The second component in first column.</param>
		/// <param name="col2" type="Component">The component in second column.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	create2By1RowLayout: function(row1col1, row1col2, row2) {
		/// <summary>Creates a two-row stack panel whose first row is a horizontal stack of two components.</summary>
		/// <param name="row1col1" type="Component">The first component on first row.</param>
		/// <param name="row1col2" type="Component">The second component on first row.</param>
		/// <param name="row2" type="Component">The component on first row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	create2By2Layout: function(row1col1, row1col2, row2col1, row2col2) {
		/// <summary>Creates horizontal stack panels for components on same rowand adds them to a vertical stack panel.</summary>
		/// <param name="row1col1" type="Component">The first component on first row.</param>
		/// <param name="row1col2" type="Component">The second component on first row.</param>
		/// <param name="row2col1" type="Component">The first component on second row.</param>
		/// <param name="row2col2" type="Component">The second component on second row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAdd1By2ColumnLayout: function(col1, col2row1, col2row2) {
		/// <summary>Creates a two-column stack panel whose first column is a vertical stack of two components.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="col1" type="Component">The component in first column.</param>
		/// <param name="col2row1" type="Component">The first component in second column.</param>
		/// <param name="col2row2" type="Component">The second component in second column.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAdd1By2RowLayout: function(row1, row2col1, row2col2) {
		/// <summary>Creates a two-row stack panel whose second row is a horizontal stack of two components.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="row1" type="Component">The component on first row.</param>
		/// <param name="row2col1" type="Component">The first component on second row.</param>
		/// <param name="row2col2" type="Component">The second component on second row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAdd2By1ColumnLayout: function(col1row1, col1row2, col2) {
		/// <summary>Creates a two-column stack panel whose first column is a vertical stack of two components.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="col1row1" type="Component">The first component in first column.</param>
		/// <param name="col1row2" type="Component">The second component in first column.</param>
		/// <param name="col2" type="Component">The component in second column.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAdd2By1RowLayout: function(row1col1, row1col2, row2) {
		/// <summary>Creates a two-row stack panel whose first row is a horizontal stack of two components.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="row1col1" type="Component">The first component on first row.</param>
		/// <param name="row1col2" type="Component">The second component on first row.</param>
		/// <param name="row2" type="Component">The component on first row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAdd2By2Layout: function(row1col1, row1col2, row2col1, row2col2) {
		/// <summary>Creates horizontal stack panels for components on same rowand adds them to a vertical stack panel.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="row1col1" type="Component">The first component on first row.</param>
		/// <param name="row1col2" type="Component">The second component on first row.</param>
		/// <param name="row2col1" type="Component">The first component on second row.</param>
		/// <param name="row2col2" type="Component">The second component on second row.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createAndAddPlotAndAxes: function(plot, top, left, bottom, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An array of XAxisRenderer components that should be placed at top side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">An array of YAxisRenderer components that should be placed at left side of the plot.</param>
		/// <param name="bottom" type="XAxisRenderer">An array of XAxisRenderer components that should be placed at bottom side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">An array of YAxisRenderer components that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createAndAddPlotWithBottomAndLeftAxes: function(plot, bottom, left) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="bottom" type="XAxisRenderer">An XAxisRenderer that should be placed at bottom side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">A YAxisRenderer that should be placed at left side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createAndAddPlotWithBottomAndRightAxes: function(plot, bottom, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="bottom" type="XAxisRenderer">An XAxisRenderer that should be placed at bottom side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">A YAxisRenderer that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createAndAddPlotWithTopAndLeftAxes: function(plot, top, left) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An XAxisRenderer that should be placed at top side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">A YAxisRenderer that should be placed at left side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createAndAddPlotWithTopAndRightAxes: function(plot, top, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.The panel is automatically added to the dashboard's LayoutPanel.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An XAxisRenderer that should be placed at top side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">A YAxisRenderer that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createLayout: function(horizontal, c1, c2, c3) {
		/// <summary>Creates a StackPanel for each array of components andadds it to a parent StackPanel with opposite orientation.</summary>
		/// <param name="horizontal" type="Boolean">The orientation of the parent panel.</param>
		/// <param name="c1" type="Component">The first stack of components.</param>
		/// <param name="c2" type="Component">The second stack of components.</param>
		/// <param name="c3" type="Component">The third stack of components.</param>
		/// <returns type="StackPanel">A StackPanel instance.</returns>
	},
	createPlotAndAxes: function(plot, top, left, bottom, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An array of XAxisRenderer components that should be placed at top side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">An array of YAxisRenderer components that should be placed at left side of the plot.</param>
		/// <param name="bottom" type="XAxisRenderer">An array of XAxisRenderer components that should be placed at bottom side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">An array of YAxisRenderer components that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createPlotWithBottomAndLeftAxes: function(plot, bottom, left) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="bottom" type="XAxisRenderer">An XAxisRenderer that should be placed at bottom side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">A YAxisRenderer that should be placed at left side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createPlotWithBottomAndRightAxes: function(plot, bottom, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="bottom" type="XAxisRenderer">An XAxisRenderer that should be placed at bottom side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">A YAxisRenderer that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createPlotWithTopAndLeftAxes: function(plot, top, left) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An XAxisRenderer that should be placed at top side of the plot.</param>
		/// <param name="left" type="YAxisRenderer">A YAxisRenderer that should be placed at left side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	},
	createPlotWithTopAndRightAxes: function(plot, top, right) {
		/// <summary>Creates a GridPanel containing the specified plot and axis renderers.</summary>
		/// <param name="plot" type="Plot2D">A Plot2D instance.</param>
		/// <param name="top" type="XAxisRenderer">An XAxisRenderer that should be placed at top side of the plot.</param>
		/// <param name="right" type="YAxisRenderer">A YAxisRenderer that should be placed at right side of the plot.</param>
		/// <returns type="GridPanel">A GridPanel instance.</returns>
	}
};
MindFusion.Charting.Controls.LayoutBuilder.__class = true;

MindFusion.Charting.Controls.LineChart.prototype = {
};
MindFusion.Charting.Controls.LineChart.__class = true;

MindFusion.Charting.Controls.PieChart.prototype = {
	createPlot: function() {
		/// <summary>Chart.CreatePlot override. Creates the Plot type corresponding to this chart.</summary>
		/// <returns type="Plot">An instance of the PolarPlot class.</returns>
	}
};
MindFusion.Charting.Controls.PieChart.__class = true;

MindFusion.Charting.Controls.RadarChart.prototype = {
	createPlot: function() {
		/// <summary>Chart.CreatePlot override. Creates the Plot type corresponding to this chart.</summary>
		/// <returns type="Plot">An instance of the RadarPlot class.</returns>
	}
};
MindFusion.Charting.Controls.RadarChart.__class = true;

MindFusion.Charting.Controls.ScatterChart.prototype = {
};
MindFusion.Charting.Controls.ScatterChart.__class = true;

MindFusion.Charting.ThreeD.Label3D.prototype = {
};
MindFusion.Charting.ThreeD.Label3D.__class = true;

MindFusion.Charting.ThreeD.LabelProjection.prototype = {
	drawAsProjection: function(context) {
		/// <summary>Draws this projection in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.ThreeD.LabelProjection.__class = true;

MindFusion.Charting.ThreeD.Matrix3D.prototype = {
	fill: function(array) {
		/// <summary>Fills the matrix with an array, starting from the top left, filling horisontally.</summary>
		/// <param name="array" type="number">The array to be filled in the matrix.</param>
	},
	multiply: function(mat) {
		/// <summary>Multiplys the current matrix times a second matrix.</summary>
		/// <param name="mat" type="Matrix3D">The right matrix.</param>
	},
	nullify: function() {
		/// <summary>Fills the matrix with zeros.</summary>
	},
};
MindFusion.Charting.ThreeD.Matrix3D.__class = true;

MindFusion.Charting.ThreeD.Matrix3D.Identety = function() {
	/// <summary>A 4x4 Identety Matrix</summary>
};
MindFusion.Charting.ThreeD.Matrix3D.multiply = function(m, n) {
	/// <summary>Multiplys 2 matrices.</summary>
	/// <param name="m" type="Matrix3D">The left matrix.</param>
	/// <param name="n" type="Matrix3D">The right matrix.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.Perspective = function(filedOfView, aspectRatio, near, far) {
	/// <summary>A 4x4 matrix, allowing perspective and vercitile coordinates.</summary>
	/// <param name="filedOfView" type="number">The angle of the camera.</param>
	/// <param name="aspectRatio" type="number">The width devided by height of the viewing window.</param>
	/// <param name="near" type="number">The nearest coordinate, where the object will still be drawn.</param>
	/// <param name="far" type="number">The furthest coordinate, where the object will still be drawn.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.RotateX = function(angle) {
	/// <summary>A 4x4 matrix, allowing rotation around the X axis.</summary>
	/// <param name="angle" type="number">The amount of rotation around the X axis in radians.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.RotateY = function(angle) {
	/// <summary>A 4x4 matrix, allowing rotation around the Y axis.</summary>
	/// <param name="angle" type="number">The amount of rotation around the Y axis in radians.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.RotateZ = function(angle) {
	/// <summary>A 4x4 matrix, allowing rotation around the Z axis.</summary>
	/// <param name="angle" type="number">The amount of rotation around the Z axis in radians.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.Scale = function(width, height, depth) {
	/// <summary>A 4x4 matrix, allowing scaling.</summary>
	/// <param name="width" type="number">The amount of scaling on the X axis in percent/100.</param>
	/// <param name="height" type="number">The amount of scaling on the Y axis in percent/100.</param>
	/// <param name="depth" type="number">The amount of scaling on the Z axis in percent/100.</param>
};
MindFusion.Charting.ThreeD.Matrix3D.Translate = function(x, y, z) {
	/// <summary>A 4x4 matrix, allowing translation.</summary>
	/// <param name="x" type="number">The amount of translation on the X axis.</param>
	/// <param name="y" type="number">The amount of translation on the Y axis.</param>
	/// <param name="z" type="number">The amount of translation on the Z axis.</param>
};

MindFusion.Charting.ThreeD.Mesh3D.prototype = {
};
MindFusion.Charting.ThreeD.Mesh3D.__class = true;

MindFusion.Charting.ThreeD.Model3D.prototype = {
};
MindFusion.Charting.ThreeD.Model3D.__class = true;

MindFusion.Charting.ThreeD.Polygon3D.prototype = {
	drawAsProjection: function(context) {
		/// <summary>Draws this projection in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	midPoint: function() {
		/// <summary>Returns the polygon's middle point.</summary>
		/// <returns type="Point3D">A Point3D instance representing the middle point.</returns>
	},
	normal: function() {
		/// <summary>Gets the polygon's normal vector.</summary>
		/// <returns type="Vector3D">A Vector3D representing the polygon's normal vector.</returns>
	},
	pointToPlaneDist: function(p) {
		/// <summary>Gets the distance from specified point to polygon's plane.</summary>
		/// <param name="p" type="Point3D">A Point3D instance.</param>
		/// <returns type="Number">A number value representing the distance.</returns>
	},
};
MindFusion.Charting.ThreeD.Polygon3D.__class = true;

MindFusion.Charting.ThreeD.Polygon3D.pointToPlaneDist = function(p, planePoint, planeNormal) {
	/// <summary>Gets the distance from specified point to specified plane.</summary>
	/// <param name="p" type="Point3D">A Point3D instance.</param>
	/// <param name="planePoint" type="Point3D">A point from the plane.</param>
	/// <param name="planeNormal" type="Vector3D">The plane's normal vector.</param>
	/// <returns type="Number">A number value representing the distance.</returns>
};

MindFusion.Charting.ThreeD.Scene3D.prototype = {
	buildCuboid: function(x1, y1, z1, x2, y2, z2, brush) {
		/// <summary>Creates a cuboid model.</summary>
		/// <param name="x1" type="Number">X coordinate of a corner point of the cuboid.</param>
		/// <param name="y1" type="Number">Y coordinate of a corner point of the cuboid.</param>
		/// <param name="z1" type="Number">Z coordinate of a corner point of the cuboid.</param>
		/// <param name="x2" type="Number">X coordinate of diametrically opposite corner.</param>
		/// <param name="y2" type="Number">Y coordinate of diametrically opposite corner.</param>
		/// <param name="z2" type="Number">Z coordinate of diametrically opposite corner.</param>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The Brush used to paint the cuboid model.</param>
		/// <returns type="Mesh3D">A Mesh3D containing the cuboid faces.</returns>
	},
	draw: function(context) {
		/// <summary>Draws a projection of this scene in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.ThreeD.Scene3D.__class = true;

MindFusion.Charting.ThreeD.Vector3D.prototype = {
	div: function(s) {
		/// <summary>Divides the vector by specified measure.</summary>
		/// <param name="s" type="Number">A double value representing the divisor.</param>
		/// <returns type="Vector3D">A Vector3D representing the result.</returns>
	},
	length: function() {
		/// <summary>Calculates the length of this vector.</summary>
		/// <returns type="Number">A double value representing the vector length.</returns>
	}
};
MindFusion.Charting.ThreeD.Vector3D.__class = true;

MindFusion.Charting.ThreeD.Vector3D.crossProduct = function(a, b) {
	/// <summary>Calculates the cross-product of two vectors.</summary>
	/// <param name="a" type="Vector3D">A Vector3D instance.</param>
	/// <param name="b" type="Vector3D">A Vector3D instance.</param>
	/// <returns type="Vector3D">A Vector3D representing the cross-product of specified vectors.</returns>
};

MindFusion.Charting.Components.BorderComponent.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and size of this border and arranges its Content.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	draw: function(context) {
		/// <summary>Component.Draw override. Draws this border in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this border and its Content.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.BorderComponent.__class = true;

MindFusion.Charting.Components.ButtonComponent.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and size of this button relatively to its parent.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	createController: function(context) {
		/// <summary>Component.CreateController override. Returns a controller used to interact with this button.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">Instance of a ComponentController -derived class.</returns>
	},
	draw: function(context) {
		/// <summary>Component.Draw override. Draws this button in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this button.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	onClicked: function(e) {
		/// <summary>Raises the Clicked event.</summary>
		/// <param name="e" type="EventArgs">An instance of the EventArgs class.</param>
	},
	onCustomDraw: function(e) {
		/// <summary>Raises the CustomDraw event.</summary>
		/// <param name="e" type="ButtonDrawEventArgs">An instance of the ButtonDrawEventArgs class.</param>
	}
};
MindFusion.Charting.Components.ButtonComponent.__class = true;

MindFusion.Charting.Components.ButtonDrawEventArgs.prototype = {
};
MindFusion.Charting.Components.ButtonDrawEventArgs.__class = true;

MindFusion.Charting.Components.ButtonDrawEventDispatcher.prototype = {
};
MindFusion.Charting.Components.ButtonDrawEventDispatcher.__class = true;

MindFusion.Charting.Components.Component.prototype = {
	add: function(value1, value2) {
		/// <summary>Sums specified nullable number values.</summary>
		/// <param name="value1" type="Number">The first term to sum.</param>
		/// <param name="value2" type="Number">The second term to sum.</param>
		/// <returns type="Number">A nullable number value representing the sum.</returns>
	},
	arrange: function(x, y, w, h, context) {
		/// <summary>Sets the location and size of this component relatively to its parent.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	arrangeInRect: function(child, context, x, y, w, h) {
		/// <summary>Arranges a child component in specified layout rectangle.</summary>
		/// <param name="child" type="Component">A Component instance specifying the child to arrange.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="x" type="Number">Layout rectangle's horizontal position.</param>
		/// <param name="y" type="Number">Layout rectangle's vertical position.</param>
		/// <param name="w" type="Number">Layout rectangle's width.</param>
		/// <param name="h" type="Number">Layout rectangle's height.</param>
	},
	createController: function(context) {
		/// <summary>Returns a ComponentController used to interact with this component.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">Instance of a ComponentController -derived class.</returns>
	},
	draw: function(context) {
		/// <summary>Draws this component in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	getCursorHint: function(x, y) {
		/// <summary>Invoked while the mouse is moved to let your application set the mouse cursor.</summary>
		/// <param name="x" type="Number">A double value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A double value specifying the vertical position of mouse pointer.</param>
		/// <returns type="CursorHint">A member of the CursorHint enumeration.</returns>
	},
	hitTest: function(x, y) {
		/// <summary>Returns the component containing specified point.</summary>
		/// <param name="x" type="Number">X coordinate of the point to test.</param>
		/// <param name="y" type="Number">Y coordinate of the point to test.</param>
		/// <returns type="Component">A Component instance if one contains the point, or null otherwise.</returns>
	},
	invalidate: function(rect) {
		/// <summary>Invalidates the appearance of this component and calls its Draw method at next draw operation.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect" optional="true">Optional. A RectD instance specifying the invalid rectangle.</param>
	},
	invalidateLayout: function() {
		/// <summary>Invalidates the current layout and runs a new layout pass before next draw operation.</summary>
	},
	localToRoot: function(point) {
		/// <summary>Transforms the specified point to the coordinate system of the root panel.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance containing coordinates local to this component.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point instance containing coordinates relative to the root panel.</returns>
	},
	max: function(value1, value2) {
		/// <summary>Returns the larger of specified values.</summary>
		/// <param name="value1" type="Number">The first value to compare.</param>
		/// <param name="value2" type="Number">The second value to compare.</param>
		/// <returns type="Number">A nullable number value representing the larger value.</returns>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	rootToLocal: function(point) {
		/// <summary>Transforms the specified point to the coordinate system of this component.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point instance containing coordinates relative to the root panel.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point instance containing coordinates local to this component.</returns>
	},
	visit: function(visitor) {
		/// <summary>Implements the visitor design pattern.</summary>
		/// <param name="visitor" type="ComponentVisitor">An instance of a ComponentVisitor -derived class.</param>
	}
};
MindFusion.Charting.Components.Component.__class = true;

MindFusion.Charting.Components.ComponentVisitor.prototype = {
	visitPanel: function(panel) {
		/// <summary>Visits a Panel component.</summary>
		/// <param name="panel" type="void">A Panel instance.</param>
	},
	visitPlot: function(plot) {
		/// <summary>Visits a Plot component.</summary>
		/// <param name="plot" type="Plot">A Plot instance.</param>
	}
};
MindFusion.Charting.Components.ComponentVisitor.__class = true;

MindFusion.Charting.Components.CursorHint = {
	/// <summary>Specifies what mouse cursor to display while a user interacts with the control.</summary>
	/// <field name="CounterDiagonalResize">Indicates the cursor specified by the CounterDiagonalResize property.</field>
	/// <field name="DiagonalResize">Indicates the cursor specified by the DiagonalResize property.</field>
	/// <field name="Disallow">Indicates the cursor specified by the DisallowCursor property.</field>
	/// <field name="DontChange">Indicates the cursor specified by the Cursor property.</field>
	/// <field name="HorizontalResize">Indicates the cursor specified by the HorizontalResizeCursor property.</field>
	/// <field name="Move">Indicates the cursor specified by the MoveCursor property.</field>
	/// <field name="Pointer">Indicates the cursor specified by the PointerCursor property.</field>
	/// <field name="Rotate">Indicates the cursor specified by the RotateCursor property.</field>
	/// <field name="VerticalResize">Indicates the cursor specified by the VerticalResize property.</field>
	CounterDiagonalResize: 0,
	DiagonalResize: 1,
	Disallow: 2,
	DontChange: 3,
	HorizontalResize: 4,
	Move: 5,
	Pointer: 6,
	Rotate: 7,
	VerticalResize: 8
}
MindFusion.Charting.Components.CursorHint.__enum = true;

MindFusion.Charting.Components.GridColumn.prototype = {
	measuredSize: function() {
		/// <summary>Returns the column's measured width.</summary>
		/// <returns type="Number">A number value representing the column's width.</returns>
	},
	relativeSize: function() {
		/// <summary>Gets whether the column should be sized relatively to other columns in the grid panel.</summary>
		/// <returns type="Boolean">true to apply relative size to this column, or false otherwise.</returns>
	},
	setPos: function(value) {
		/// <summary>Sets the column's position.</summary>
		/// <param name="value" type="Number">X coordinate of the column.</param>
	}
};
MindFusion.Charting.Components.GridColumn.__class = true;

MindFusion.Charting.Components.GridPanel.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and sizeof this panel and arranges its child components.</summary>
		/// <param name="x" type="void">A number value specifying horizontal position.</param>
		/// <param name="y" type="void">A number value specifying vertical position.</param>
		/// <param name="w" type="void">A number value specifying the component's width.</param>
		/// <param name="h" type="void">A number value specifying the component's height.</param>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Panel.Measure override. Measures the desired size of this panel and its child components.</summary>
		/// <param name="maxWidth" type="void">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="void">The maximum height provided by parent component.</param>
		/// <param name="context" type="void">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.GridPanel.__class = true;

MindFusion.Charting.Components.GridRow.prototype = {
	measuredSize: function() {
		/// <summary>Returns the row's measured height.</summary>
	},
	relativeSize: function() {
		/// <summary>Gets whether the row should be sized relatively to other rows in the grid panel.</summary>
	},
	setPos: function(value) {
		/// <summary>Sets the row's position.</summary>
		/// <param name="value" type="void">Y coordinate of the row.</param>
	}
};
MindFusion.Charting.Components.GridRow.__class = true;

MindFusion.Charting.Components.HitTestVisibility = {
	/// <summary>Identifies hit-test visibility of a component.</summary>
	/// <field name="Children">Only hit-test child components.</field>
	/// <field name="HitTestVisibility">Do not participate in hit-testing.</field>
	/// <field name="SelfAndChildren">Hit-test this component and its children.</field>
	Children: 0,
	HitTestVisibility: 1,
	SelfAndChildren: 2
}
MindFusion.Charting.Components.HitTestVisibility.__enum = true;

MindFusion.Charting.Components.ImageComponent.prototype = {
	draw: function(context) {
		/// <summary>Component.Draw override. Draws associated Image in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.ImageComponent.__class = true;

MindFusion.Charting.Components.LayoutAlignment = {
	/// <summary>Indicates how child components are aligned within the layout rectangleallocated to them by their parent component.</summary>
	/// <field name="Center">Center the child component.</field>
	/// <field name="Far">Align the child component to the right or bottom side.</field>
	/// <field name="Near">Align the child component to the left or top side.</field>
	/// <field name="Stretch">Stretch the child component.</field>
	Center: 0,
	Far: 1,
	Near: 2,
	Stretch: 3
}
MindFusion.Charting.Components.LayoutAlignment.__enum = true;

MindFusion.Charting.Components.LengthType = {
	/// <summary>Indicates how GridPanel determines dimensions of its rows and columns.</summary>
	/// <field name="Auto">The row or column is auto-sized to fit its child components.</field>
	/// <field name="Relative">The size of relative elements is calculated from available space in the GridPanel proportionally to the number of other relative elements.</field>
	Auto: 0,
	Relative: 1
}
MindFusion.Charting.Components.LengthType.__enum = true;

MindFusion.Charting.Components.Orientation = {
	/// <summary>Identifies layout orientation.</summary>
	/// <field name="Horizontal">Horizontal orientation.</field>
	/// <field name="Vertical">Vertical orientation.</field>
	Horizontal: 0,
	Vertical: 1
}
MindFusion.Charting.Components.Orientation.__enum = true;

MindFusion.Charting.Components.Panel.prototype = {
	draw: function(context) {
		/// <summary>Component.Draw override. Draws child components in specified RenderContext.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	hitTest: function(x, y) {
		/// <summary>Component.HitTest override. Returns the component containing specified point.</summary>
		/// <param name="x" type="Number">X coordinate of the point to test.</param>
		/// <param name="y" type="Number">Y coordinate of the point to test.</param>
		/// <returns type="Component">A Component instance if one contains the point, or null otherwise.</returns>
	},
	invalidate: function(rect) {
		/// <summary>Component.Invalidate override. Invalidates the appearanceof this panel and calls its Draw method at next draw operation.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect" optional="true">Optional. A Rect instance specifying the invalid rectangle.</param>
	},
	invalidateLayout: function() {
		/// <summary>Component.InvalidateLayout override. Invalidates the current layoutand runs a new layout pass before next draw operation.</summary>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this panel and its child components.</summary>
		/// <param name="maxWidth" type="void">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="void">The maximum height provided by parent component.</param>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	visit: function(visitor) {
		/// <summary>Component.Visit override. Implements the visitor design pattern.</summary>
		/// <param name="visitor" type="void">An instance of a ComponentVisitor -derived class.</param>
	}
};
MindFusion.Charting.Components.Panel.__class = true;

MindFusion.Charting.Components.RangeSelector.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and size of this component relatively to its parent.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	createController: function(context) {
		/// <summary>Component.CreateController override. Returns a controller used to interact with this component.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">Instance of a ComponentController -derived class.</returns>
	},
	draw: function(context) {
		/// <summary>Component.Draw override. Draws this component in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.RangeSelector.__class = true;

MindFusion.Charting.Components.SimplePanel.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and sizeof this panel and arranges its child components.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Panel.Measure override. Measures the desired size of this panel and its child components.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.SimplePanel.__class = true;

MindFusion.Charting.Components.StackPanel.prototype = {
	arrange: function(x, y, w, h, context) {
		/// <summary>Component.Arrange override. Sets the location and sizeof this panel and arranges its child components.</summary>
		/// <param name="x" type="Number">A number value specifying horizontal position.</param>
		/// <param name="y" type="Number">A number value specifying vertical position.</param>
		/// <param name="w" type="Number">A number value specifying the component's width.</param>
		/// <param name="h" type="Number">A number value specifying the component's height.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Panel.Measure override. Measures the desired size of this panel and its child components.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.StackPanel.__class = true;

MindFusion.Charting.Components.TextComponent.prototype = {
	draw: function(context) {
		/// <summary>Component.Draw override. Draws associated Text in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Components.TextComponent.__class = true;

MindFusion.Charting.Components.Visibility = {
	/// <summary>Identifies visibility of components.</summary>
	/// <field name="Collapsed">The component is hidden and does not participate in layout measurements.</field>
	/// <field name="Hidden">The component is hidden but participates in layout measurements.c</field>
	/// <field name="Visible">The component is visible.</field>
	Collapsed: 0,
	Hidden: 1,
	Visible: 2
}
MindFusion.Charting.Components.Visibility.__enum = true;

MindFusion.Charting.Collections.Dictionary.prototype = {
	contains: function(key) {
		/// <summary>Determines whether the dictionary contains a specific key.</summary>
		/// <param name="key" type="TKey">The key to locate in the dictionary.</param>
		/// <returns type="Boolean">true if the element exists in the collection, otherwise false.</returns>
	},
	get: function(key) {
		/// <summary>Gets the value associated with the specified key within the dictionary.</summary>
		/// <param name="key" type="TKey">The key whose value to get.</param>
	},
	remove: function(key) {
		/// <summary>Removes the element with the specified key from the dictionary.</summary>
		/// <param name="key" type="TKey">The key of the element to remove.</param>
	},
	set: function(key, value) {
		/// <summary>Associates the specified value with the specified key within the dictionary.</summary>
		/// <param name="key" type="TKey">The key to associate the value with.</param>
		/// <param name="value" type="TValue">The value to associate.</param>
	}
};
MindFusion.Charting.Collections.Dictionary.__class = true;

MindFusion.Charting.Collections.IEnumerable.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the end of the collection.</summary>
		/// <param name="item" type="T">The object to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection.</summary>
	},
	clone: function() {
		/// <summary>Creates a copy of the collection.</summary>
		/// <returns type="IEnumerable<T>">A copy of this collection.</returns>
	},
	contains: function(item) {
		/// <summary>Checks if the given element is present in the collection.</summary>
		/// <param name="item" type="T">The object to check for.</param>
		/// <returns type="Boolean">True if the element is found, otherwise false.</returns>
	},
	copyTo: function(destination, length, sourceIndex, destinationIndex) {
		/// <summary>Copies a range of elements from this collection to a destination collection.</summary>
		/// <param name="destination" type="IEnumerable<T>">The destination collection.</param>
		/// <param name="length" type="Number">The length of the range to copy.</param>
		/// <param name="sourceIndex" type="Number" optional="true">Optional. The starting index of the range to copy.</param>
		/// <param name="destinationIndex" type="Number" optional="true">Optional. The index at which the range should be copied.</param>
	},
	count: function() {
		/// <summary>Gets the number of elements.</summary>
		/// <returns type="Number">The number of elements.</returns>
	},
	indexOfItem: function(obj, fromIndex) {
		/// <summary>Gets the index of a given object in a collection.</summary>
		/// <param name="obj" type="T">The object to look for.</param>
		/// <param name="fromIndex" type="Number" optional="true">Optional. The starting index to search from.</param>
		/// <returns type="Number">The index of the object, or -1 if the object is not present in the collection.</returns>
	},
	insert: function(index, item) {
		/// <summary>Adds an element to the collection at the specified index.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <param name="item" type="T">The object to add.</param>
	},
	item: function(index) {
		/// <summary>Gets the element at the given index.</summary>
		/// <param name="index" type="Number">The index.</param>
		/// <returns type="T">The element at the given index.</returns>
	},
	items: function() {
		/// <summary>Gets the collection as an array.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection.</returns>
	},
	max: function(selector) {
		/// <summary>Invokes a transform function on each item and returns themaximum value in a sequence of numbers.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The maximum number in the sequence.</returns>
	},
	min: function(selector) {
		/// <summary>Invokes a transform function on each item and returns theminimum value in a sequence of numbers.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The minimum number in the sequence.</returns>
	},
	remove: function(item) {
		/// <summary>Removes an element from the collection.</summary>
		/// <param name="item" type="T">The object to remove.</param>
	},
	removeAt: function(index) {
		/// <summary>Removes the element at the given index.</summary>
		/// <param name="index" type="Number">The index.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Removes a range of elements starting from the given index.</summary>
		/// <param name="index" type="Number">The starting index of the range.</param>
		/// <param name="count" type="Number">The length of the range.</param>
	},
	reverse: function() {
		/// <summary>Gets the collection as an array in reverse order.</summary>
		/// <returns type="Array<T>">The underlying array data structure of the collection in reverse order.</returns>
	},
	select: function(selector) {
		/// <summary>Projects each element of a sequence into a new form.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="IEnumerable<T>">An collection whose elements are the resultof invoking the transform function on each element.</returns>
	},
	sort: function(compareFn) {
		/// <summary>Sorts the underlying array.</summary>
		/// <param name="compareFn" type="Function" optional="true">Optional. The comparing function.</param>
	},
	sum: function(selector) {
		/// <summary>Computes the sum of the sequence of number values that areobtained by invoking a transform function on each element.</summary>
		/// <param name="selector" type="Function">A transform function to invoke on each element.</param>
		/// <returns type="Number">The sum of the number values in the sequence.</returns>
	},
	toArray: function() {
		/// <summary>Returns a new Object array, containing the contents of the collection.</summary>
		/// <returns type="Array<T>">The array.</returns>
	}
};
MindFusion.Charting.Collections.IEnumerable.__class = true;

MindFusion.Charting.Collections.List.prototype = {
};
MindFusion.Charting.Collections.List.__class = true;

MindFusion.Charting.Collections.ObservableCollection.prototype = {
	add: function(item) {
		/// <summary>Adds an object to the collection.</summary>
		/// <param name="item" type="T">The item to add.</param>
	},
	clear: function() {
		/// <summary>Clears the collection</summary>
	},
	onCollectionChanged: function(args) {
		/// <summary>Raises the collectionChanged event.</summary>
		/// <param name="args" type="NotifyCollectionChangedEventArgs">An instance of the NotifyCollectionChangedEventArgs class.</param>
	},
	onCollectionChanging: function(args) {
		/// <summary>Raises the collectionChanging validation event.</summary>
		/// <param name="args" type="NotifyCollectionChangingEventArgs">An instance of the NotifyCollectionChangingEventArgs class.</param>
	},
	onPropertyChanged: function(args) {
		/// <summary>Raises the propertyChanged event.</summary>
		/// <param name="args" type="PropertyChangedEventArgs">An instance of the PropertyChangedEventArgs class.</param>
	},
	remove: function(item) {
		/// <summary>Deletes an object from the collection</summary>
		/// <param name="item" type="T">The item to remove.</param>
	},
	removeAt: function(itemIndex) {
		/// <summary>Delete the element at the specified index.</summary>
		/// <param name="itemIndex" type="Number">The index to remove at.</param>
	},
	removeRange: function(index, count) {
		/// <summary>Deletes a range of elements from the collection</summary>
		/// <param name="index" type="Number">The starting index of the range to remove.</param>
		/// <param name="count" type="Number">The length of the range to remove.</param>
	}
};
MindFusion.Charting.Collections.ObservableCollection.__class = true;

MindFusion.Charting.Drawing.Brush.prototype = {
	apply: function(context) {
		/// <summary>Applies the brush properties to a CanvasRenderingContext2D drawing object.</summary>
		/// <param name="context" type="CanvasRenderingContext2D">The CanvasRenderingContext2D drawing object.</param>
	},
	clone: function() {
		/// <summary>Creates a copy of this brush.</summary>
		/// <returns type="MindFusion.Charting.Drawing.Brush">The copy of this brush.</returns>
	},
	equals: function(The) {
		/// <summary>Determines whether the specified object is equal to this Brush.</summary>
		/// <param name="The" type="Object">object to compare with.</param>
		/// <returns type="Boolean">true if the specified object is equal to this Brush; otherwise, false.</returns>
	},
	toObject: function() {
		/// <summary>Returns a JSON object describing this brush.</summary>
		/// <returns type="Object">The object describing this brush.</returns>
	}
};
MindFusion.Charting.Drawing.Brush.__class = true;

MindFusion.Charting.Drawing.Brush.fromObject = function(obj) {
	/// <summary>Returns a Brush from a JSON object or string describing this brush.</summary>
	/// <param name="obj" type="void"></param>
	/// <returns type="Brush">The brush object.</returns>
};

MindFusion.Charting.Drawing.Color.prototype = {
};
MindFusion.Charting.Drawing.Color.__class = true;


MindFusion.Charting.Drawing.Color.knownColors = function() {
	/// <summary>The list of color names as defined by the CSS specification.</summary>
};

MindFusion.Charting.Drawing.DashStyle = {
	/// <summary>Specifies the dash pattern of lines.</summary>
	/// <field name="Dash">Specifies a line consisting of dashes.</field>
	/// <field name="DashDot">Specifies a dash-dot pattern.</field>
	/// <field name="DashDotDot">Specifies a dash-dot-dot pattern.</field>
	/// <field name="Dot">Specifies a line consisting of dots.</field>
	/// <field name="Solid">Specifies a solid line.</field>
	Dash: 0,
	DashDot: 1,
	DashDotDot: 2,
	Dot: 3,
	Solid: 4
}
MindFusion.Charting.Drawing.DashStyle.__enum = true;

MindFusion.Charting.Drawing.Font.prototype = {
	apply: function(context) {
		/// <summary>Applies the font properties to a CanvasRenderingContext2D drawing object.</summary>
		/// <param name="context" type="CanvasRenderingContext2D">The CanvasRenderingContext2D drawing object.</param>
	},
	toString: function() {
		/// <summary>Returns a string representation of this font.</summary>
		/// <returns type="String">The string representation of this font.</returns>
	}
};
MindFusion.Charting.Drawing.Font.__class = true;

MindFusion.Charting.Drawing.FontStyle = {
	/// <summary>Specifies font style attributes.</summary>
	/// <field name="Bold">Bold text.</field>
	/// <field name="Italic">Italic text.</field>
	/// <field name="Regular">Normal text.</field>
	/// <field name="Underline">Underlined text.</field>
	Bold: 0,
	Italic: 1,
	Regular: 2,
	Underline: 3
}
MindFusion.Charting.Drawing.FontStyle.__enum = true;

MindFusion.Charting.Drawing.Graphics.prototype = {
	beginFigure: function(pen, brush, bounds) {
		/// <summary>Starts a new figure.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen" optional="true">Optional. The pen to stroke the figure with.</param>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. The brush to fill the figure with.</param>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. The bounds to which the brush should be applied.</param>
	},
	clear: function() {
		/// <summary>Clears the canvas.</summary>
	},
	clip: function(rect) {
		/// <summary>Sets the clip rectangle.</summary>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The clip rectangle</param>
	},
	closeFigure: function(pen, brush, bounds) {
		/// <summary>Closes the current figure.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen" optional="true">Optional. The pen to stroke the figure with.</param>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush" optional="true">Optional. The brush to fill the figure with.</param>
		/// <param name="bounds" type="MindFusion.Drawing.Rect" optional="true">Optional. The bounds to which the brush should be applied.</param>
	},
	drawCurve: function(pen, points) {
		/// <summary>Draws a spline curve.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to stroke the curve with.</param>
		/// <param name="points" type="MindFusion.Drawing.Point">The points describing the curve.</param>
	},
	drawEllipse: function(pen, rect) {
		/// <summary>Draws an ellipse.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to stroke the ellipse with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle describing the ellipse.</param>
	},
	drawImage: function(image, rect, align) {
		/// <summary>Draws an image.</summary>
		/// <param name="image" type="HTMLImageElement">The image to draw.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The bounds of the image.</param>
		/// <param name="align" type="MindFusion.Charting.Drawing.ImageAlign">The align to use.</param>
	},
	drawLines: function(pen, points) {
		/// <summary>Draws a series of straight lines.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to draw the lines with.</param>
		/// <param name="points" type="MindFusion.Drawing.Point">The points of the lines to draw.</param>
	},
	drawPie: function(pen, rect, radius, startAngle, endAngle, doughnut) {
		/// <summary>Draws a pie.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to stroke the pie with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The bounds of the pie.</param>
		/// <param name="radius" type="Number">The radius of the pie.</param>
		/// <param name="startAngle" type="Number">The startAngle of the pie.</param>
		/// <param name="endAngle" type="Number">The endAngle of the pie.</param>
		/// <param name="doughnut" type="Boolean" optional="true">Optional. True if the pie should be a doughnut, otherwise false.</param>
	},
	drawPolygon: function(pen, points) {
		/// <summary>Draws a polygon.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to draw the polygon with.</param>
		/// <param name="points" type="MindFusion.Drawing.Point">The points describing the polygon.</param>
	},
	drawRectangle: function(pen, rect) {
		/// <summary>Draws a rectangle.</summary>
		/// <param name="pen" type="MindFusion.Charting.Drawing.Pen">The pen to stroke the rectangle with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle to draw.</param>
	},
	drawString: function(text, font, brush, location, format) {
		/// <summary>Draws a string.</summary>
		/// <param name="text" type="String">The string to draw.</param>
		/// <param name="font" type="MindFusion.Drawing.Font">The font to use.</param>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The brush to use.</param>
		/// <param name="location" type="Point|Rect">The position at which to draw.</param>
		/// <param name="format" type="MindFusion.Charting.Drawing.StringFormat" optional="true">Optional. The format to use.</param>
	},
	fillEllipse: function(brush, rect) {
		/// <summary>Fills an ellipse.</summary>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The brush to fill the ellipse with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle describing the ellipse.</param>
	},
	fillPie: function(brush, rect, radius, startAngle, endAngle, doughnut) {
		/// <summary>Fills a pie.</summary>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The brush to fill the pie with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The bounds of the pie.</param>
		/// <param name="radius" type="Number">The radius of the pie.</param>
		/// <param name="startAngle" type="Number">The startAngle of the pie.</param>
		/// <param name="endAngle" type="Number">The endAngle of the pie.</param>
		/// <param name="doughnut" type="Boolean" optional="true">Optional. True if the pie should be a doughnut, otherwise false.</param>
	},
	fillPolygon: function(brush, points) {
		/// <summary>Fills a polygon.</summary>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The brush to fill the polygon with.</param>
		/// <param name="points" type="MindFusion.Drawing.Point">The points describing the polygon.</param>
	},
	fillRectangle: function(brush, rect) {
		/// <summary>Fills a rectangle.</summary>
		/// <param name="brush" type="MindFusion.Charting.Drawing.Brush">The pen to fill the rectangle with.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The rectangle to fill.</param>
	},
	measureString: function(text, font, width) {
		/// <summary>Gets the size of the specified string.</summary>
		/// <param name="text" type="String">The string to measure.</param>
		/// <param name="font" type="MindFusion.Drawing.Font">The font to use.</param>
		/// <param name="width" type="Number" optional="true">Optional. The maximum width.</param>
		/// <returns type="MindFusion.Drawing.Size">The size of the given string when drawn with the given font.</returns>
	},
	pointInPie: function(point, rect, radius, startAngle, endAngle, doughnut) {
		/// <summary>Checks if the given point is within the bounds of the given pie.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <param name="rect" type="MindFusion.Drawing.Rect">The bounds of the pie.</param>
		/// <param name="radius" type="Number">The radius of the pie.</param>
		/// <param name="startAngle" type="Number">The startAngle of the pie.</param>
		/// <param name="endAngle" type="Number">The endAngle of the pie.</param>
		/// <param name="doughnut" type="Boolean" optional="true">Optional. True if the pie is a doughnut, otherwise false.</param>
		/// <returns type="Boolean">True if the point lies within pie bounds, otherwise false.</returns>
	},
	pointInPoly: function(point, poly) {
		/// <summary>Checks if the given point is within the bounds of the given polygon.</summary>
		/// <param name="point" type="MindFusion.Drawing.Point">The point to check.</param>
		/// <param name="poly" type="MindFusion.Drawing.Point">The points describing the polygon.</param>
	},
	restore: function() {
		/// <summary>Restores to a previously saved graphics state.</summary>
	},
	save: function() {
		/// <summary>Saves the current graphics state.</summary>
	},
	setTransform: function(transform) {
		/// <summary>Sets a transform.</summary>
		/// <param name="transform" type="MindFusion.Drawing.Matrix">The transform matrix.</param>
	},
	translate: function(x, y) {
		/// <summary>Sets a translate transform.</summary>
		/// <param name="x" type="Number">The distance to translate along the x-axis.</param>
		/// <param name="y" type="Number">The distance to translate along the y-axis.</param>
	}
};
MindFusion.Charting.Drawing.Graphics.__class = true;

MindFusion.Charting.Drawing.ImageAlign = {
	/// <summary>Specifies the position and alignment of a picture in a node, or that of the background image.</summary>
	/// <field name="BottomCenter">The image is centered horizontally and aligned to the bottom side.</field>
	/// <field name="BottomLeft">The image is aligned to the bottom left corner of the node or the diagram.</field>
	/// <field name="BottomRight">The image is aligned to the bottom right corner of the node or the diagram.</field>
	/// <field name="Center">The image is centered in the node or diagram.</field>
	/// <field name="Fit">The image is resized to fit the size of the object or the component's client area.</field>
	/// <field name="MiddleLeft">The image is centered vertically and aligned to the left-hand side.</field>
	/// <field name="MiddleRight">The image is centered vertically and aligned to the right-hand side.</field>
	/// <field name="Stretch">The image is stretched to fill the object or the component's client area.</field>
	/// <field name="Tile">The image is tiled to cover the node or the diagram.</field>
	/// <field name="TopCenter">The image is centered horizontally and aligned to the top side.</field>
	/// <field name="TopLeft">The image is aligned to the top left corner of the node or the diagram.</field>
	/// <field name="TopRight">The image is aligned to the top right corner of the node or the diagram.</field>
	BottomCenter: 0,
	BottomLeft: 1,
	BottomRight: 2,
	Center: 3,
	Fit: 4,
	MiddleLeft: 5,
	MiddleRight: 6,
	Stretch: 7,
	Tile: 8,
	TopCenter: 9,
	TopLeft: 10,
	TopRight: 11
}
MindFusion.Charting.Drawing.ImageAlign.__enum = true;

MindFusion.Charting.Drawing.LinearGradientBrush.prototype = {
	apply: function(context, bounds) {
		/// <summary>Applies the brush properties to a CanvasRenderingContext2D drawing object.</summary>
		/// <param name="context" type="CanvasRenderingContext2D">The CanvasRenderingContext2D drawing object.</param>
		/// <param name="bounds" type="MindFusion.Drawing.Rect">The bounds of the gradient.</param>
	},
	clone: function() {
		/// <summary>Creates a copy of this brush.</summary>
		/// <returns type="LinearGradientBrush">The copy of this brush.</returns>
	},
	equals: function(The) {
		/// <summary>Determines whether the specified object is equal to this LinearGradientBrush.</summary>
		/// <param name="The" type="Object">object to compare with.</param>
		/// <returns type="Boolean">true if the specified object is equal to this LinearGradientBrush; otherwise, false.</returns>
	},
	toObject: function() {
		/// <summary>Returns a JSON object describing this brush.</summary>
		/// <returns type="Object">The object describing this brush.</returns>
	}
};
MindFusion.Charting.Drawing.LinearGradientBrush.__class = true;

MindFusion.Charting.Drawing.LinearGradientBrush.fromObject = function(obj) {
	/// <summary>Returns a LinearGradientBrush from a JSON object or string describing this brush.</summary>
	/// <param name="obj" type="void"></param>
	/// <returns type="LinearGradientBrush">The brush object.</returns>
};

MindFusion.Charting.Drawing.LineJoin = {
	/// <summary>Specifies how to join consecutive line or curve segments in a figure.</summary>
	/// <field name="Bevel">Produces a diagonal corner.</field>
	/// <field name="Miter">Produces a sharp corner or a clipped corner, depending on whether the length of the miter exceeds the miter limit.</field>
	/// <field name="Round">Produces a smooth, circular arc between the lines.</field>
	Bevel: 0,
	Miter: 1,
	Round: 2
}
MindFusion.Charting.Drawing.LineJoin.__enum = true;

MindFusion.Charting.Drawing.Pen.prototype = {
	apply: function(context) {
		/// <summary>Applies the pen properties to a CanvasRenderingContext2D drawing object.</summary>
		/// <param name="context" type="CanvasRenderingContext2D">The CanvasRenderingContext2D drawing object.</param>
	},
	equals: function(The) {
		/// <summary>Determines whether the specified object is equal to this LinearGradientBrush.</summary>
		/// <param name="The" type="Object">object to compare with.</param>
		/// <returns type="Boolean">true if the specified object is equal to this LinearGradientBrush; otherwise, false.</returns>
	},
	toString: function() {
		/// <summary>Returns a string representation of this pen.</summary>
		/// <returns type="String">The string representation of this pen.</returns>
	}
};
MindFusion.Charting.Drawing.Pen.__class = true;

MindFusion.Charting.Drawing.Pen.fromObject = function(obj) {
	/// <summary>Returns a Pen from a string describing this pen.</summary>
	/// <param name="obj" type="void"></param>
	/// <returns type="Pen">The pen object.</returns>
};

MindFusion.Charting.Drawing.StringAlignment = {
	/// <summary>Specifies the alignment of a text string relative to its layout rectangle.</summary>
	/// <field name="Center">The text is drawn in the center of the layout rectangle.</field>
	/// <field name="Far">The text is drawn in the far corner of the layout rectangle.le.</field>
	/// <field name="Near">The text is drawn in the near corner of the layout rectangle.</field>
	Center: 0,
	Far: 1,
	Near: 2
}
MindFusion.Charting.Drawing.StringAlignment.__enum = true;

MindFusion.Charting.Drawing.StringFormat.prototype = {
};
MindFusion.Charting.Drawing.StringFormat.__class = true;

MindFusion.Charting.Commands.Command.prototype = {
	commit: function() {
		/// <summary>A shortcut method for executing the command through the undo engine.</summary>
	}
};
MindFusion.Charting.Commands.Command.__class = true;

MindFusion.Charting.Commands.CompositeCommand.prototype = {
	execute: function() {
		/// <summary>DisposableCommand.Execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.Redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.Undo override.</summary>
	}
};
MindFusion.Charting.Commands.CompositeCommand.__class = true;

MindFusion.Charting.Commands.DisposableCommand.prototype = {
	cancel: function() {
		/// <summary>Cancels the command.</summary>
	},
	clean: function() {
		/// <summary>Disposes of this command.</summary>
	},
	dispose: function() {
		/// <summary>IDisposable.Dispose implementation.</summary>
	},
	execute: function() {
		/// <summary>Command.Execute override.</summary>
	},
	redo: function() {
		/// <summary>Command.Redo override.</summary>
	},
	undo: function() {
		/// <summary>Command.Undo override.</summary>
	}
};
MindFusion.Charting.Commands.DisposableCommand.__class = true;

MindFusion.Charting.Commands.TrackChangesCommand.prototype = {
	beginChange: function() {
		/// <summary>Called before undoing or redoing the command.</summary>
	},
	endChange: function() {
		/// <summary>Called after undoing or redoing the command.</summary>
	},
	redo: function() {
		/// <summary>DisposableCommand.Redo override.</summary>
	},
	undo: function() {
		/// <summary>DisposableCommand.Undo override.</summary>
	}
};
MindFusion.Charting.Commands.TrackChangesCommand.__class = true;

MindFusion.Charting.Commands.UndoEventArgs.prototype = {
};
MindFusion.Charting.Commands.UndoEventArgs.__class = true;

MindFusion.Charting.Common.EventDispatcher.prototype = {
	addEventListener: function(handler) {
		/// <summary>Subcribes an event listener to this event.</summary>
		/// <param name="handler" type="void"></param>
	},
	raiseEvent: function(sender, args) {
		/// <summary>Raises this event.</summary>
		/// <param name="sender" type="void"></param>
		/// <param name="args" type="void"></param>
	},
	removeEventListener: function(handler) {
		/// <summary>Removes an event listener from this event.</summary>
		/// <param name="handler" type="void"></param>
	}
};
MindFusion.Charting.Common.EventDispatcher.__class = true;

MindFusion.Charting.Common.NotifyCollectionChangedAction = {
	/// <summary>Describes an action that triggered a INotifyCollectionChanged.collectionChanged event.</summary>
	/// <field name="Add">Item was added to the collection.</field>
	/// <field name="Remove">One or more items were removed from the collection.</field>
	/// <field name="Reset">he contents of the collection changed dramatically.</field>
	Add: 0,
	Remove: 1,
	Reset: 2
}
MindFusion.Charting.Common.NotifyCollectionChangedAction.__enum = true;

MindFusion.Charting.Common.NotifyCollectionChangedEventArgs.prototype = {
};
MindFusion.Charting.Common.NotifyCollectionChangedEventArgs.__class = true;

MindFusion.Charting.Common.NotifyCollectionChangedEventDispatcher.prototype = {
};
MindFusion.Charting.Common.NotifyCollectionChangedEventDispatcher.__class = true;

MindFusion.Charting.Common.NotifyCollectionChangingEventArgs.prototype = {
	getCancel: function() {
		/// <summary>Gets a value indicating whether to allow the current operation.</summary>
		/// <returns type="Boolean">true to cancel the operation; otherwise, false.</returns>
	},
	setCancel: function(value) {
		/// <summary>Sets a value indicating whether to allow the current operation.</summary>
		/// <param name="value" type="Boolean">true to cancel the operation; otherwise, false.</param>
	}
};
MindFusion.Charting.Common.NotifyCollectionChangingEventArgs.__class = true;

MindFusion.Charting.Common.NotifyCollectionChangingEventDispatcher.prototype = {
};
MindFusion.Charting.Common.NotifyCollectionChangingEventDispatcher.__class = true;

MindFusion.Charting.Common.PropertyChangedEventArgs.prototype = {
};
MindFusion.Charting.Common.PropertyChangedEventArgs.__class = true;

MindFusion.Charting.Common.PropertyChangedEventDispatcher.prototype = {
};
MindFusion.Charting.Common.PropertyChangedEventDispatcher.__class = true;

MindFusion.Charting.Common.PropertyEventArgs.prototype = {
};
MindFusion.Charting.Common.PropertyEventArgs.__class = true;

MindFusion.Charting.AnnotationRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.AnnotationRenderer.__class = true;

MindFusion.Charting.AreaRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.AreaRenderer.__class = true;

MindFusion.Charting.AreaStackRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.AreaStackRenderer.__class = true;

MindFusion.Charting.Axis.prototype = {
	inRange: function(value) {
		/// <summary>Determines whether specified value is within the axis range.</summary>
		/// <param name="value" type="Number">The number to check.</param>
		/// <returns type="Boolean">true if value is inside the current axis range, or false otherwise.</returns>
	},
	mapValueToPixelX: function(value, viewSize) {
		/// <summary>Maps a value from this axis' coordinate system to a pixel position in specified view.</summary>
		/// <param name="value" type="Number">A number value.</param>
		/// <param name="viewSize" type="Number">The view size.</param>
		/// <returns type="Number">X coordinate of pixel.</returns>
	},
	mapValueToPixelY: function(value, viewSize) {
		/// <summary>Maps a value from this axis' coordinate system to a pixel position in specified view.</summary>
		/// <param name="value" type="Number">A number value.</param>
		/// <param name="viewSize" type="Number">The view size.</param>
		/// <returns type="Number">Y coordinate of pixel.</returns>
	},
	onPropertyChanged: function(propertyName) {
		/// <summary>Raises the PropertyChanged event.</summary>
		/// <param name="propertyName" type="String">Specifies the name of changed property.</param>
	}
};
MindFusion.Charting.Axis.__class = true;

MindFusion.Charting.AxisInfo.prototype = {
};
MindFusion.Charting.AxisInfo.__class = true;

MindFusion.Charting.AxisRenderer.prototype = {
	effectiveAxisDashStyle: function(context) {
		/// <summary>Gets the dash style of axis line strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	effectiveAxisStroke: function(context) {
		/// <summary>Gets the Brush that should be used to stroke axis lines.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveAxisStrokeThickness: function(context) {
		/// <summary>Gets the thickness of axis line strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="Number">A number value.</returns>
	},
	effectiveLabelBrush: function(context) {
		/// <summary>Gets the Brush that should be used to draw axis labels.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="SysBrush">A System.Brush instance.</returns>
	},
	effectiveLabelFont: function(context) {
		/// <summary>Gets the Font that should be used to draw axis labels.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Drawing.Font">A System.Drawing.Font instance.</returns>
	},
	effectivePen: function(context) {
		/// <summary>Gets the Pen that should be used to draw axis lines.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Pen">A System.Pen instance.</returns>
	},
	effectiveTitleBrush: function(context) {
		/// <summary>Gets the Brush that should be used to draw the axis Title.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="SysBrush">A System.Brush instance.</returns>
	},
	effectiveTitleFont: function(context) {
		/// <summary>Gets the Font that should be used to draw the axis Title.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Drawing.Font">A System.Drawing.Font instance.</returns>
	}
};
MindFusion.Charting.AxisRenderer.__class = true;

MindFusion.Charting.BarLayout = {
	/// <summary>Identifies supported bar placements when rendering multiple series.</summary>
	/// <field name="Overlay">Render elements at same index from all series as overlaid bars.</field>
	/// <field name="SideBySide">Render elements at same index from all series as a group of side-by-side bars.</field>
	/// <field name="Stack">Render elements at same index from all series as stacked bars.</field>
	Overlay: 0,
	SideBySide: 1,
	Stack: 2
}
MindFusion.Charting.BarLayout.__enum = true;

MindFusion.Charting.BarModel3D = {
	/// <summary>Identifies supported bar shapes when rendering multiple series.</summary>
	/// <field name="Bar">Draw bars as rectangular cuboids.</field>
	/// <field name="Cylinder">Draw bars as cylinders.</field>
	Bar: 0,
	Cylinder: 1
}
MindFusion.Charting.BarModel3D.__enum = true;

MindFusion.Charting.BarOverlayRenderer.prototype = {
	adjustDataRange: function(context) {
		/// <summary>seriesRenderer.AdjustDataRange override. Adjusts the data range of associatedAxis objects after initial measure pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	backToFrontRatio: function() {
		/// <summary>Gets the ratio between widths of backmost and frontmost bars.</summary>
		/// <returns type="Number">3</returns>
	},
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted bar in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumVisibleOverlays: function(context, frontToBack, process) {
		/// <summary>Enumerates the bars visible in current data range.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="frontToBack" type="Boolean">true to enumerate from front bar to back bar, or false otherwise.</param>
		/// <param name="process" type="ProcessBars">A ProcessBars callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the bar representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a bar.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>Renderer2D.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarOverlayRenderer.__class = true;

MindFusion.Charting.BarOverlayRenderer3D.prototype = {
	backToFrontRatio: function() {
		/// <summary>BarOverlayRenderer.BackToFrontRatio override. Gets the ratiobetween widths of backmost and frontmost bars.</summary>
		/// <returns type="Number">1.</returns>
	},
	buildModels: function(scene, context) {
		/// <summary>Implements Renderer3D.BuildModels. Adds 3D bar models for the series data to specified scene.</summary>
		/// <param name="scene" type="Scene3D">A Scene3D instance.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarOverlayRenderer3D.__class = true;

MindFusion.Charting.BarRenderer.prototype = {
	adjustDataRange: function(context) {
		/// <summary>SeriesRenderer.AdjustDataRange override. Adjusts the data range of associatedAxis objects after initial measure pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted bar in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumVisibleBars: function(context, process) {
		/// <summary>Enumerates the bars visible in current data range.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessBars">A ProcessBars callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the bar representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a bar.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>Renderer2D.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarRenderer.__class = true;

MindFusion.Charting.BarRenderer3D.prototype = {
	buildModels: function(scene, context) {
		/// <summary>Implements Renderer3D.BuildModels. Adds 3D bar models for the series data to specified scene.</summary>
		/// <param name="scene" type="Scene3D">A Scene3D instance.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarRenderer3D.__class = true;

MindFusion.Charting.BarSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>SimpleSeries.GetLabel override. Returns an element of a labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	}
};
MindFusion.Charting.BarSeries.__class = true;

MindFusion.Charting.BarStackRenderer.prototype = {
	adjustDataRange: function(context) {
		/// <summary>seriesRenderer.AdjustDataRange override. Adjusts the data range of associatedAxis objects after initial measure pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted bar in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumVisibleStackBars: function(context, process) {
		/// <summary>Enumerates the bars visible in current data range.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessStackBars">A ProcessStackBars callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>StackRenderer.HitTest override. Hit-tests the bar representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a bar.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>StackRenderer.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarStackRenderer.__class = true;

MindFusion.Charting.BarStackRenderer3D.prototype = {
	buildModels: function(scene, context) {
		/// <summary>Implements Renderer3D.BuildModels. Adds 3D bar models for the series data to specified scene.</summary>
		/// <param name="scene" type="Scene3D">A Scene3D instance.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.BarStackRenderer3D.__class = true;

MindFusion.Charting.BubbleLabelAlignment = {
	/// <summary>Specifies the alignment of a label relative to its associated bubble.</summary>
	/// <field name="Above">Indicates that the label is positioned above the bubble.</field>
	/// <field name="Below">Indicates that the label is positioned below the bubble.</field>
	/// <field name="Center">Indicates that the label is centered inside the bubble.</field>
	/// <field name="Left">Indicates that the label is positioned to the left of the bubble.</field>
	/// <field name="Right">Indicates that the label is positioned to the right of the bubble.</field>
	Above: 0,
	Below: 1,
	Center: 2,
	Left: 3,
	Right: 4
}
MindFusion.Charting.BubbleLabelAlignment.__enum = true;

MindFusion.Charting.BubbleRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws bubbles representing data items in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted bubble in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the bubble representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a bubble.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	}
};
MindFusion.Charting.BubbleRenderer.__class = true;

MindFusion.Charting.CandlestickRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted candlestick in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	effectiveFill: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the brush that should be used to fill the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	enumVisibleCandlesticks: function(context, process) {
		/// <summary>Enumerates the candlesticks visible in current data range.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessCandlesticks">A ProcessBars callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the bar representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a candlestick.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>Renderer2D.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.CandlestickRenderer.__class = true;

MindFusion.Charting.CandlestickSeriesStyle.prototype = {
	fill: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Fill. Returns a Brush instance, depending on the series data.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	stroke: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	strokeDashStyle: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeDashStyle.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A nullable DashStyle value specifying stroke dash style.</returns>
	},
	strokeThickness: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeThickness.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="Number">A nullable number value specifying stroke thickness.</returns>
	}
};
MindFusion.Charting.CandlestickSeriesStyle.__class = true;

MindFusion.Charting.CurveAreaRenderer.prototype = {
	draw: function(context) {
		/// <summary>AreaRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.CurveAreaRenderer.__class = true;

MindFusion.Charting.CurveAreaStackRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.CurveAreaStackRenderer.__class = true;

MindFusion.Charting.CurveRenderer.prototype = {
	draw: function(context) {
		/// <summary>LineRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.CurveRenderer.__class = true;

MindFusion.Charting.DataBoundSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns a label for the specified data item in the data source.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a value for the specified data item in the data source.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the data source.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. DataBoundSeries always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. Gets a value indicating whetherthe series values increase monotonously in specified dimension.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.DataBoundSeries.__class = true;

MindFusion.Charting.DateTimeFormat = {
	/// <summary>Specifies formats for DateTime values.</summary>
	/// <field name="CustomDateTime">Indicates that the number should be formatted as a DateTime value according to a custom set string.</field>
	/// <field name="FullDateTime">Indicates that the number should be formatted as a DateTime value with a full date pattern.</field>
	/// <field name="LongDate">Indicates that the number should be formatted as a DateTime value with a long date pattern.</field>
	/// <field name="LongTime">Indicates that the number should be formatted as a DateTime value with a long time pattern.</field>
	/// <field name="MonthDateTime">Indicates that the number should be formatted as a DateTime value with a month day pattern.</field>
	/// <field name="None">The DateTime value is not formatted</field>
	/// <field name="ShortDate">Indicates that the number should be formatted as a DateTime value with a short date pattern.</field>
	/// <field name="ShortTime">Indicates that the number should be formatted as a DateTime value with a short time pattern.</field>
	/// <field name="YearDateTime">Indicates that the number should be formatted as a DateTime value with a year month date pattern.</field>
	CustomDateTime: 0,
	FullDateTime: 1,
	LongDate: 2,
	LongTime: 3,
	MonthDateTime: 4,
	None: 5,
	ShortDate: 6,
	ShortTime: 7,
	YearDateTime: 8
}
MindFusion.Charting.DateTimeFormat.__enum = true;

MindFusion.Charting.DateTimeSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns Date value at specified index as an XAxisLabel.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a value for the specified data item in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. DateTimeSeries always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. DateTimeSeries always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.DateTimeSeries.__class = true;

MindFusion.Charting.FunnelRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>SeriesRenderer.DrawHighlight override. Draws highlighted slice in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumSegments: function(context, process) {
		/// <summary>Enumerates the segments of the funnel.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessSegment">A ProcessSegment callback.</param>
	},
	enumSeries: function() {
		/// <summary>Implements the SeriesContainer interface.</summary>
		/// <returns type="IEnumerable<Series>">An instance of the IEnumerable&amp;lt;Series&amp;gt; class.</returns>
	},
	hitTest: function(context, location) {
		/// <summary>SeriesRenderer.HitTest override. Hit-tests the slices representing data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a pie slice.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	}
};
MindFusion.Charting.FunnelRenderer.__class = true;

MindFusion.Charting.GridType = {
	/// <summary>Indicates Plot2D grid type.</summary>
	/// <field name="Crossed">Draw crossed stripes.</field>
	/// <field name="Horizontal">Draw horizontal stripes.</field>
	/// <field name="None">Do not draw grid.</field>
	/// <field name="Vertical">Draw vertical stripes.</field>
	Crossed: 0,
	Horizontal: 1,
	None: 2,
	Vertical: 3
}
MindFusion.Charting.GridType.__enum = true;

MindFusion.Charting.HitResult.prototype = {
};
MindFusion.Charting.HitResult.__class = true;

MindFusion.Charting.LabelKinds = {
	/// <summary>Identifies the various kinds of labels that can be drawn for data items.</summary>
	/// <field name="All">Draw all labels supported by a series.</field>
	/// <field name="InnerLabel">Draw inner label in graphic representation of data item.</field>
	/// <field name="None">Do not draw labels.</field>
	/// <field name="OuterLabel">Draw outer label nearby graphic representation of data item.</field>
	/// <field name="ToolTip">Show label as a tooltip.</field>
	/// <field name="XAxisLabel">Draw data label at X axis.</field>
	/// <field name="YAxisLabel">Draw data label at Y axis.</field>
	/// <field name="ZAxisLabel">Draw data label at Z axis.</field>
	All: 0,
	InnerLabel: 1,
	None: 2,
	OuterLabel: 3,
	ToolTip: 4,
	XAxisLabel: 5,
	YAxisLabel: 6,
	ZAxisLabel: 7
}
MindFusion.Charting.LabelKinds.__enum = true;

MindFusion.Charting.LegendController.prototype = {
	onMouseDown: function(x, y) {
		/// <summary>Implements ComponentController.OnMouseDown. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseMove: function(x, y) {
		/// <summary>Implements ComponentController.OnMouseMove. Called when the user moves the mouse.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	}
};
MindFusion.Charting.LegendController.__class = true;

MindFusion.Charting.LegendRenderer.prototype = {
	createController: function(context) {
		/// <summary>Component.CreateController override. Returns a ComponentControllerused to interact with this component.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">Instance of the LegendController class.</returns>
	},
	draw: function(context) {
		/// <summary>Component.Draw override. Draws legend elements in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	effectiveBorderPen: function(context) {
		/// <summary>Gets the Pen that should be used to draw the legend borders.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Pen">A Pen instance.</returns>
	},
	effectiveBorderStroke: function(context) {
		/// <summary>Gets the Brush that should be used to stroke the legend borders.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveBorderStrokeThickness: function(context) {
		/// <summary>Gets the thickness of border strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="Number">A number value.</returns>
	},
	effectiveFill: function(context) {
		/// <summary>Gets the Brush that should be used to fill the legend background.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveStrokeDashStyle: function(context) {
		/// <summary>Gets the dash style of border strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	effectiveTitleBrush: function(context) {
		/// <summary>Gets the Brush that should be used to draw the legend's Title.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="SysBrush">A System.Brush instance.</returns>
	},
	effectiveTitleFont: function(context) {
		/// <summary>Gets the Font that should be used to draw the legend's Title.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Drawing.Font">A System.Drawing.Font instance.</returns>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.LegendRenderer.__class = true;

MindFusion.Charting.LineRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.LineRenderer.__class = true;

MindFusion.Charting.LineType = {
	/// <summary>Identifies how to connect adjacent data points in line and area charts.</summary>
	/// <field name="Curve">Connect points using a cardinal spline.</field>
	/// <field name="Polyline">Connect points using straight line segments.</field>
	/// <field name="Step">Connect points using steps.</field>
	Curve: 0,
	Polyline: 1,
	Step: 2
}
MindFusion.Charting.LineType.__enum = true;

MindFusion.Charting.Margins.prototype = {
};
MindFusion.Charting.Margins.__class = true;

MindFusion.Charting.MixedSeriesStyle.prototype = {
	fill: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke. Returns a Brush instance fromFills, CommonFills or UniformFill properties.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	stroke: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke. Returns a Brush instance fromStrokes, CommonStrokes or UniformStroke properties.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	strokeDashStyle: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeDashStyle. Returns a value fromStrokeDashStyles, CommonStrokeDashStyles or UniformStrokeDashStyle properties.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A nullable DashStyle value specifying stroke dash style.</returns>
	},
	strokeThickness: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeThickness. Returns a value fromStrokeThicknesses, CommonStrokeThicknesses or UniformStrokeThickness properties.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="Number">A nullable number value specifying stroke thickness.</returns>
	}
};
MindFusion.Charting.MixedSeriesStyle.__class = true;

MindFusion.Charting.Pair.prototype = {
	toString: function() {
		/// <summary>Object.ToString override.</summary>
	}
};
MindFusion.Charting.Pair.__class = true;

MindFusion.Charting.PanController.prototype = {
	getRunningAnimation: function() {
		/// <summary>For internal use.</summary>
		/// <returns type="ComponentAnimation">An instance of a ComponentAnimation -derived class.</returns>
	},
	onMouseDown: function(x, y) {
		/// <summary>Plot2DController.OnMouseDown override. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseMove: function(x, y) {
		/// <summary>PlotController.OnMouseMove override. Called when the user moves the mouse.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseUp: function(x, y) {
		/// <summary>PlotController.OnMouseUp override. Called when the user releases a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	}
};
MindFusion.Charting.PanController.__class = true;

MindFusion.Charting.PanControllerAnimation.prototype = {
};
MindFusion.Charting.PanControllerAnimation.__class = true;

MindFusion.Charting.PerElementSeriesStyle.prototype = {
	fill: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Fill. Returns a Brush from the Fills listthat matches specified series and data indices.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	stroke: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke. Returns a Brush from the Strokes listthat matches specified series and data indices.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	strokeDashStyle: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeDashStyle. Returns a value fromthe StrokeDashStyles list that matches specified series and data indices.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A nullable DashStyle value specifying stroke dash style.</returns>
	},
	strokeThickness: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeThickness. Returns a value fromthe StrokeThicknesses list that matches specified series and data indices.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="Number">A nullable number value specifying stroke thickness.</returns>
	}
};
MindFusion.Charting.PerElementSeriesStyle.__class = true;

MindFusion.Charting.PerSeriesStyle.prototype = {
	fill: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Fill. Returns a Brush fromthe Fills list that matches specified series index.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	stroke: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke. Returns a Brush fromthe Strokes list that matches specified series index.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	strokeDashStyle: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeDashStyle. Returns a value fromthe StrokeDashStyles list that matches specified series index.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A nullable DashStyle value specifying stroke dash style.</returns>
	},
	strokeThickness: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeThickness. Returns a value fromthe StrokeThicknesses list that matches specified series index.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="Number">A nullable number value specifying stroke thickness.</returns>
	}
};
MindFusion.Charting.PerSeriesStyle.__class = true;

MindFusion.Charting.PieRadarRenderer.prototype = {
	draw: function(context) {
		/// <summary>RadarRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>RadarRenderer.DrawHighlight override. Draws highlighted data item in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumSectors: function(context, process) {
		/// <summary>Enumerates the pie-radar sectors corresponding to each series.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessSectors">A ProcessSectors callback.</param>
	}
};
MindFusion.Charting.PieRadarRenderer.__class = true;

MindFusion.Charting.PieRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>SeriesRenderer.DrawHighlight override. Draws highlighted slice in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumSeries: function() {
		/// <summary>Implements the SeriesContainer interface.</summary>
		/// <returns type="IEnumerable<Series>">An instance of the IEnumerable&amp;lt;Series&amp;gt; class.</returns>
	},
	enumSlices: function(context, process) {
		/// <summary>Enumerates the slices of the pie.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessSlice">A ProcessBars callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>SeriesRenderer.HitTest override. Hit-tests the slices representing data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a pie slice.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	}
};
MindFusion.Charting.PieRenderer.__class = true;

MindFusion.Charting.PieSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>SimpleSeries.GetLabel override. Returns an element of the inner or outer label lists.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	}
};
MindFusion.Charting.PieSeries.__class = true;

MindFusion.Charting.Plot.prototype = {
	adjustDataRanges: function(context) {
		/// <summary>Called at the end of data measurement pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	domainDimension: function(series) {
		/// <summary>Implements the SeriesContainer interface. Gets the index of the dimensionwhose set of values should be treated as domain of plotted function.</summary>
		/// <param name="series" type="Series">A Series in this container.</param>
	},
	draw: function(context) {
		/// <summary>Component.Draw override. Draws a grid and all chart graphicsrepresented by contained SeriesRenderer objects.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawGrid: function(context) {
		/// <summary>Draws the plot's grid.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawPlot: function(context) {
		/// <summary>Draws the plot's background and borders.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	effectiveBorder: function(context) {
		/// <summary>Gets the Pen that should be used to draw the plot's borders.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Pen">A Pen instance.</returns>
	},
	effectiveBorderStroke: function(context) {
		/// <summary>Gets the Brush that should be used to stroke the plot's borders.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveBorderStrokeThickness: function(context) {
		/// <summary>Gets the thickness of border strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="Number">A number value.</returns>
	},
	effectiveFill: function(context) {
		/// <summary>Gets the Brush that should be used to fill the plot's background.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveStrokeDashStyle: function(context) {
		/// <summary>Gets the dash style of border strokes.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	enumSeries: function() {
		/// <summary>Implements SeriesContainer.</summary>
		/// <returns type="IEnumerable<Series>">An instance of the IEnumerable&amp;lt;Series&amp;gt; class.</returns>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.Measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	measureDataRanges: function(context) {
		/// <summary>Measures data of all SeriesRenderer objects drawn inside this plot.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	onRendererDataChanged: function(sender, e) {
		/// <summary>Called when a Series raises its DataChanged event.</summary>
		/// <param name="sender" type="Object">The event sender.</param>
		/// <param name="e" type="EventArgs">An EventArgs instance.</param>
	},
	startMeasureData: function(context) {
		/// <summary>Called in the beginning of data measurement pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	unsubscribe: function(seriesRenderers) {
		/// <summary>Unsubscribes from DataChanged and PropertyChanged eventsof all SeriesRenderer objects in specified list.</summary>
		/// <param name="seriesRenderers" type="MindFusion.Charting.Collections.ObservableCollection<SeriesRenderer>">A list of SeriesRenderer objects.</param>
	}
};
MindFusion.Charting.Plot.__class = true;

MindFusion.Charting.Plot2D.prototype = {
	createController: function(context) {
		/// <summary>Component.CreateController override. Returns a ComponentControllerused to interact with this component.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">An instance of the PanController class.</returns>
	},
	drawGrid: function(context) {
		/// <summary>Plot.DrawGrid override. Draws the grid specified by GridType property.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	resetZoom: function() {
		/// <summary>Resets the zoom level to original axis ranges.</summary>
	},
	visit: function(visitor) {
		/// <summary>Component.Visit override. Calls visitor's VisitPlot method.</summary>
		/// <param name="visitor" type="ComponentVisitor">An instance of a ComponentVisitor -derived class.</param>
	},
	zoomOut: function(axes) {
		/// <summary>Zooms out from current data range.</summary>
		/// <param name="axes" type="IEnumerable<Axis>">The axes whose ranges should be scaled.</param>
	}
};
MindFusion.Charting.Plot2D.__class = true;

MindFusion.Charting.Plot2DController.prototype = {
	onMouseDown: function(x, y) {
		/// <summary>PlotController.OnMouseDown override. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	plotToAxisValue: function(axis, value) {
		/// <summary>Converts a plot pixel position to a logical value from specified axis' coordinate system.</summary>
		/// <param name="axis" type="MindFusion.Charting.Axis">The target Axis.</param>
		/// <param name="value" type="Number">The value to convert.</param>
		/// <returns type="Number">The converted value.</returns>
	}
};
MindFusion.Charting.Plot2DController.__class = true;

MindFusion.Charting.Plot3D.prototype = {
	draw: function(context) {
		/// <summary>Plot.Draw override. Draws a projection of 3D modelsgenerated by contained Renderer3D objects.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.Plot3D.__class = true;

MindFusion.Charting.PlotController.prototype = {
	drawInteraction: function(graphics) {
		/// <summary>Implements ComponentController.DrawInteraction. Draws a representationof the current state of user interaction on specified IGraphics surface.</summary>
		/// <param name="graphics" type="IGraphics">An IGraphics instance.</param>
	},
	getCursorHint: function(x, y) {
		/// <summary>For internal use.</summary>
		/// <param name="x" type="void"></param>
		/// <param name="y" type="void"></param>
		/// <returns type="CursorHint">A member of the CursorHint enumeration.</returns>
	},
	getRunningAnimation: function() {
		/// <summary>For internal use.</summary>
		/// <returns type="ComponentAnimation">An instance of a ComponentAnimation -derived class.</returns>
	},
	onMouseDown: function(x, y) {
		/// <summary>Implements ComponentController.OnMouseDown. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseMove: function(x, y) {
		/// <summary>Implements ComponentController.OnMouseMove. Called when the user moves the mouse.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseUp: function(x, y) {
		/// <summary>Implements ComponentController.OnMouseUp. Called when the user releases a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseWheel: function(x, y, delta) {
		/// <summary>Implements ComponentController.onMouseWheel. Called when the user scrolls with the middle mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
		/// <param name="delta" type="Number">A number value specifying the amount and the direction for the mouse scroll.</param>
	}
};
MindFusion.Charting.PlotController.__class = true;

MindFusion.Charting.Point3D.prototype = {
	distance: function(p) {
		/// <summary>Gets the distance to specified point.</summary>
		/// <param name="p" type="Point3D">A Point3D instance.</param>
		/// <returns type="Number">A number value representing the distance.</returns>
	},
	scale: function(scale) {
		/// <summary>Scales the point's coordinates by specified scale factor.</summary>
		/// <param name="scale" type="Number">A number value by which to multiply point's coordinates.</param>
		/// <returns type="Point3D">A Point3D containing scaled coordinates.</returns>
	},
	toString: function() {
		/// <summary>Returns a string representation of this point.</summary>
		/// <returns type="String">A string representation of this point.</returns>
	}
};
MindFusion.Charting.Point3D.__class = true;

MindFusion.Charting.Point3D.add = function(p1, p2) {
	/// <summary>Sums two points' coordinates.</summary>
	/// <param name="p1" type="Point3D">The first point.</param>
	/// <param name="p2" type="Point3D">The second point.</param>
	/// <returns type="Point3D">A Point3D containing sum of coordinates.</returns>
};

MindFusion.Charting.PointSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns an element of the Labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a coordinate of specified point in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. PointSeries always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. PointSeries always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.PointSeries.__class = true;

MindFusion.Charting.PointSeries3D.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns an element of the Labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a coordinate of specified point in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. PointSeries3D always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. PointSeries3D always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.PointSeries3D.__class = true;

MindFusion.Charting.PolarPlot.prototype = {
	createController: function(context) {
		/// <summary>Component.CreateController override. Returns a ComponentControllerused to interact with this component.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="ComponentController">An instance of the RotationController class.</returns>
	},
	rotatePoint: function(pointToRotate, centerPoint, angleInDegrees) {
		/// <summary>Rotates point around specified rotation center at specified angle.</summary>
		/// <param name="pointToRotate" type="MindFusion.Drawing.Point">The point to rotate.</param>
		/// <param name="centerPoint" type="MindFusion.Drawing.Point">The rotation center.</param>
		/// <param name="angleInDegrees" type="Number">The rotation angle.</param>
		/// <returns type="MindFusion.Drawing.Point"></returns>
	},
	visit: function(visitor) {
		/// <summary>Component.Visit override. Calls visitor's VisitPlot method.</summary>
		/// <param name="visitor" type="ComponentVisitor">An instance of a ComponentVisitor -derived class.</param>
	}
};
MindFusion.Charting.PolarPlot.__class = true;

MindFusion.Charting.RadarAxisOptions.prototype = {
	draw: function(context) {
		/// <summary>AxisRenderer.Draw override.</summary>
		/// <param name="context" type="void"></param>
	},
	effectiveAxis: function(context) {
		/// <summary>AxisRenderer.EffectiveAxis override.</summary>
		/// <param name="context" type="void"></param>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>AxisRenderer.Measure override.</summary>
		/// <param name="maxWidth" type="void"></param>
		/// <param name="maxHeight" type="void"></param>
		/// <param name="context" type="void"></param>
	}
};
MindFusion.Charting.RadarAxisOptions.__class = true;

MindFusion.Charting.RadarGridType = {
	/// <summary>Identifies the grid types supported by RadarPlot.</summary>
	/// <field name="Radar">Identifies radar grid consisting as concentric circles.</field>
	/// <field name="Spiderweb">Identifies spider-web grid consisting as concentric regular polygons.</field>
	Radar: 0,
	Spiderweb: 1
}
MindFusion.Charting.RadarGridType.__enum = true;

MindFusion.Charting.RadarPlot.prototype = {
	drawGrid: function(context) {
		/// <summary>Plot.DrawGrid override. Draws spiderweb ot radial grid.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	getEffectiveAxis: function(index) {
		/// <summary>Gets the Axis representing the range for specified data variable index.</summary>
		/// <param name="index" type="Number">An integer index of data items in series.</param>
		/// <returns type="MindFusion.Charting.Axis">The associated Axis.</returns>
	},
	startMeasureData: function(context) {
		/// <summary>Plot.StartMeasureData override. Called in the beginning of data measurement pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.RadarPlot.__class = true;

MindFusion.Charting.RadarRenderer.prototype = {
	data: function(seriesIndex, dataIndex) {
		/// <summary>Returns the data value of specified series item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <returns type="Number">A number value.</returns>
	},
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>SeriesRenderer.DrawHighlight override. Draws highlighted data item in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumSeries: function() {
		/// <summary>Implement SeriesContainer.</summary>
		/// <returns type="IEnumerable<Series>">An instance of the IEnumerable&amp;lt;Series&amp;gt; class.</returns>
	},
	enumVisibleRanges: function(context, process) {
		/// <summary>Enumerates each series once providing a list of all visible points at each iteration.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessRange">A ProcessRange callback.</param>
	},
	getMaxValue: function(index) {
		/// <summary>Gets the maximum value from all series located at specified index.</summary>
		/// <param name="index" type="Number">An integer index of data element in the series.</param>
		/// <returns type="Number">A number value representing the largest data element.</returns>
	},
	getMinValue: function(index) {
		/// <summary>Gets the minimum value from all series located at specified index.</summary>
		/// <param name="index" type="Number">An integer index of data element in the series.</param>
		/// <returns type="Number">A number value representing the smallest data element.</returns>
	},
	hitTest: function(context, location) {
		/// <summary>SeriesRenderer.HitTest override. Hit-tests the visual representation of the series for a data item.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for data items.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>SeriesRenderer.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.RadarRenderer.__class = true;

MindFusion.Charting.RadarScatterRenderer.prototype = {
	enumPoints: function(context, process) {
		/// <summary>ScatterRenderer.EnumPoints override. Enumerates the data valuesof rendered series mapped to plot's 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessPoint">A ProcessPoint callback.</param>
	},
	measureDataRange: function(context) {
		/// <summary>Renderer2D.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.RadarScatterRenderer.__class = true;

MindFusion.Charting.RadarType = {
	/// <summary>Identifies the type of radar-chart.</summary>
	/// <field name="Pie">Draw data items as circular sectors.</field>
	/// <field name="Polygon">Draw each series as a polygon.</field>
	Pie: 0,
	Polygon: 1
}
MindFusion.Charting.RadarType.__enum = true;

MindFusion.Charting.RenderContext.prototype = {
	getClipRect: function(relativeTo) {
		/// <summary>Gets the clip rectangle relative to specified Component.</summary>
		/// <param name="relativeTo" type="Component">A Component instance.</param>
		/// <returns type="Rect">A Rect instance.</returns>
	},
	getXAxis: function(series) {
		/// <summary>Gets the X axis assigned to a Renderer2D or returns one from parent plot or chart.</summary>
		/// <param name="series" type="Renderer2D" optional="true">Optional. A Renderer2D instance.</param>
		/// <returns type="Axis">An Axis instance.</returns>
	},
	getYAxis: function(series) {
		/// <summary>Gets the Y axis assigned to a Renderer2D or returns one from parent plot or chart.</summary>
		/// <param name="series" type="Renderer2D" optional="true">Optional. A Renderer2D instance.</param>
		/// <returns type="Axis">An Axis instance.</returns>
	},
	textStyle: function(hint) {
		/// <summary>Gets a TextStyle from current Theme.</summary>
		/// <param name="hint" type="TextStyleHint">A member of the TextStyleHint enumeration.</param>
		/// <returns type="TextStyle">A TextStyle instance.</returns>
	}
};
MindFusion.Charting.RenderContext.__class = true;

MindFusion.Charting.RenderContext2D.prototype = {
};
MindFusion.Charting.RenderContext2D.__class = true;

MindFusion.Charting.Renderer2D.prototype = {
	domainData: function(seriesIndex, dataIndex) {
		/// <summary>Gets the domain axis coordinate (input value) of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <returns type="Number">A number value.</returns>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>SeriesRenderer.DrawHighlight override. Draws highlighted data item in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumSeries: function() {
		/// <summary>Implements the SeriesContainer interface.</summary>
		/// <returns type="IEnumerable<Series>">An instance of the IEnumerable&amp;lt;Series&amp;gt; class.</returns>
	},
	enumVisiblePointPairs: function(context, process) {
		/// <summary>Enumerates the data values of rendered series mapped to plot 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessPoints">A ProcessPoints callback.</param>
	},
	enumVisiblePoints: function(context, frontToBack, process) {
		/// <summary>Enumerates the data values of rendered series mapped to plot 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="frontToBack" type="Boolean">true if the series list should be enumerated from front to back, or false otherwise.</param>
		/// <param name="process" type="ProcessPoint">A ProcessPoint callback.</param>
	},
	enumVisiblePoints1: function(context, process) {
		/// <summary>Enumerates the data values of rendered series mapped to plot 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessPoint">A ProcessPoint callback.</param>
	},
	enumVisibleRanges: function(context, process) {
		/// <summary>Enumerates each series once providing a list of all visible points at each iteration.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessRange">A ProcessRange callback.</param>
	},
	getMaxXSum: function() {
		/// <summary>Gets the maximum sum of X data values locates at same index in all series.</summary>
		/// <returns type="Number">A number value containing the maximum sum.</returns>
	},
	getMaxYSum: function() {
		/// <summary>Gets the maximum sum of Y data values locates at same index in all series.</summary>
		/// <returns type="Number">A number value containing the maximum sum.</returns>
	},
	getPixel: function(seriesIndex, dataIndex, xAxis, yAxis, component) {
		/// <summary>Gets the coordinates of specified data item when mapped to a Plot2D pixel.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="xAxis" type="MindFusion.Charting.Axis">An Axis reference specifying the X axis.</param>
		/// <param name="yAxis" type="MindFusion.Charting.Axis">An Axis reference specifying the Y axis.</param>
		/// <param name="component" type="Components.Component">An instance of Plot2D or derived class.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point containing Plot2D coordinates corresponding to specified data item.</returns>
	},
	getPixel1: function(valueX, xAxis, valueY, yAxis, component) {
		/// <summary>Gets the coordinates of specified data item when mapped to a Plot2D pixel.</summary>
		/// <param name="valueX" type="Number">The X value of data item in logical coordinate system.</param>
		/// <param name="xAxis" type="MindFusion.Charting.Axis">The X Axis from which logical value is mapped to plot's actual width.</param>
		/// <param name="valueY" type="Number">The Y value of data item in logical coordinate system.</param>
		/// <param name="yAxis" type="MindFusion.Charting.Axis">The Y Axis from which logical value is mapped to plot's actual height.</param>
		/// <param name="component" type="Components.Component">An instance of Plot2D or derived class.</param>
		/// <returns type="MindFusion.Drawing.Point"></returns>
	},
	hitTest: function(context, location) {
		/// <summary>SeriesRenderer.HitTest override. Hit-tests the visual representation of the series for a data item.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for data items.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	imageData: function(seriesIndex, dataIndex) {
		/// <summary>Gets the image axis coordinate (output value) of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <returns type="Number">A number value.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>SeriesRenderer.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	startMeasureData: function(context) {
		/// <summary>SeriesRenderer.StartMeasureData override. Called to reset measureaccumulators at the beginning of a measure pass.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	xData: function(seriesIndex, dataIndex) {
		/// <summary>Gets the X value of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <returns type="Number">A number value.</returns>
	},
	xSorted: function(seriesIndex) {
		/// <summary>Gets a value indicating whether values of specified series increase monotonously in X dimension.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <returns type="Boolean">true if specified series is sorted, or false otherwise.</returns>
	},
	yData: function(seriesIndex, dataIndex) {
		/// <summary>Gets the Y value of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <returns type="Number">A number value.</returns>
	},
	ySorted: function(seriesIndex) {
		/// <summary>Gets a value indicating whether values of specified series increase monotonously in Y dimension.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <returns type="Boolean">true if specified series is sorted, or false otherwise.</returns>
	}
};
MindFusion.Charting.Renderer2D.__class = true;

MindFusion.Charting.RotationController.prototype = {
	getRunningAnimation: function() {
		/// <summary>For internal use.</summary>
		/// <returns type="ComponentAnimation">An instance of a ComponentAnimation -derived class.</returns>
	},
	onMouseDown: function(x, y) {
		/// <summary>PlotController.OnMouseDown override. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseMove: function(x, y) {
		/// <summary>PlotController.OnMouseMove override. Called when the user moves the mouse.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseUp: function(x, y) {
		/// <summary>PlotController.OnMouseUp override. Called when the user releases a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	}
};
MindFusion.Charting.RotationController.__class = true;

MindFusion.Charting.RotationControllerAnimation.prototype = {
};
MindFusion.Charting.RotationControllerAnimation.__class = true;

MindFusion.Charting.ScatterRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Renderer2D.DrawHighlight override. Draws highlighted shape in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="hitResult" type="MindFusion.Charting.HitResult">A HitResult instance identifying highlighted data item.</param>
	},
	enumPoints: function(context, process) {
		/// <summary>Enumerates the data values of rendered series mapped to plot 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessPoint">A ProcessPoint callback.</param>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the scatter representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for data items.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	}
};
MindFusion.Charting.ScatterRenderer.__class = true;

MindFusion.Charting.ScatterType = {
	/// <summary>Identifies the shapes rendered by a ScatterRenderer.</summary>
	/// <field name="Circle">Draw circles.</field>
	/// <field name="Diamond">Draw diamonds.</field>
	/// <field name="None">Do not draw scatter.</field>
	/// <field name="Square">Draw squares.</field>
	/// <field name="Triangle">Draw triangles.</field>
	Circle: 0,
	Diamond: 1,
	None: 2,
	Square: 3,
	Triangle: 4
}
MindFusion.Charting.ScatterType.__enum = true;

MindFusion.Charting.Series2D.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns an element of the Labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a value for the specified data item in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. Series2D always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. Series2D always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.Series2D.__class = true;

MindFusion.Charting.Series3D.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns an element of the Labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a value for the specified data item in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. Series3D always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. Series3D always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.Series3D.__class = true;

MindFusion.Charting.SeriesRenderer.prototype = {
	adjustDataRange: function(context) {
		/// <summary>Adjusts the data range of associated Axis objects after initial measure pass.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	domainDimension: function(series) {
		/// <summary>Implements the SeriesContainer interface. Gets the index of the dimensionwhose set of values should be treated as domain of plotted function.</summary>
		/// <param name="series" type="Series">A Series in this container.</param>
	},
	draw: function(context) {
		/// <summary>Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	drawHighlight: function(context, hitResult) {
		/// <summary>Draws highlighted data item in specified RenderContext.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
		/// <param name="hitResult" type="void">A HitResult instance identifying highlighted data item.</param>
	},
	effectiveFill: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the brush that should be used to fill the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveLabelBrush: function(context) {
		/// <summary>Gets the System.Drawing.Brush that should be used to draw labels of data items.</summary>
		/// <param name="context" type="void">A RenderContext instance used to find styles and theme from dashboard hierarchy.</param>
	},
	effectiveLabelFont: function(context) {
		/// <summary>Gets the Font that should be used to draw labels of data items.</summary>
		/// <param name="context" type="void">A RenderContext instance used to find styles and theme from dashboard hierarchy.</param>
	},
	effectiveStroke: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the brush that should be used to stroke the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	effectiveStrokeDashStyle: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the dash style of the pen that should be used to stroke the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A member of the DashStyle enumeration.</returns>
	},
	effectiveStrokePen: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the Pen that should be used to stroke the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Drawing.Pen">A Pen instance.</returns>
	},
	effectiveStrokeThickness: function(seriesIndex, dataIndex, context) {
		/// <summary>Gets the thickness of the pen that should be used to stroke the representation of specified data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this SeriesRenderer.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="Number">A number value.</returns>
	},
	hitTest: function(context, location) {
		/// <summary>Hit-tests the visual representation of the series for a data item.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for data items.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>Measures the data range of rendered series and assigns it to theassociated Axis objects if their MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	onPropertyChanged: function(propertyName) {
		/// <summary>Raises the PropertyChanged event.</summary>
		/// <param name="propertyName" type="void">Specifies the name of changed property.</param>
	},
	onSeriesDataChanged: function(sender, e) {
		/// <summary>Called when Series raise their DataChanged event.</summary>
		/// <param name="sender" type="Object">The Series raising the event.</param>
		/// <param name="e" type="EventArgs">An EventArgs instance.</param>
	},
	searchStyle: function(check, context) {
		/// <summary>Returns a SeriesStyle object that meets specified criteria.</summary>
		/// <param name="check" type="void">A StyleCheck delegate that tests SeriesStyle for some criteria.</param>
		/// <param name="context" type="void">A RenderContext instance used to access styles and theme from the dashboard hierarchy.</param>
	},
	setToolTip: function(text, location) {
		/// <summary>Sets tooltip text and lcoation.</summary>
		/// <param name="text" type="void">A string specifying tooltip text.</param>
		/// <param name="location" type="void">A Point specifying tooltip location.</param>
	},
	startMeasureData: function(context) {
		/// <summary>Called to reset measure accumulators at the beginning of a measure pass.</summary>
		/// <param name="context" type="void">A RenderContext instance.</param>
	},
	subscribe: function(series) {
		/// <summary>Subscribes to the DataChanged event of specified Series.</summary>
		/// <param name="series" type="Series">A Series instance.</param>
	},
	unsubscribe: function(series) {
		/// <summary>Unsubscribes from the DataChanged event of specified Series.</summary>
		/// <param name="series" type="Series">A Series instance.</param>
	}
};
MindFusion.Charting.SeriesRenderer.__class = true;

MindFusion.Charting.SimpleSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns an element of the labels list.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a value for the specified data item in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. Gets a value indicating whetherthe specified data item should be emphasized by the SeriesRenderer.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. SimpleSeries always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.SimpleSeries.__class = true;

MindFusion.Charting.StackRenderer.prototype = {
	enumVisibleStackPoints: function(context, process) {
		/// <summary>Enumerates the data values of rendered series mapped to plot 2D coordinates.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessStackPoint">A ProcessStackPoint callback.</param>
	},
	enumVisibleStackRanges: function(context, process) {
		/// <summary>Enumerates each series once providing a list of all visible points at each iteration.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="process" type="ProcessStackRange">A ProcessStackRange callback.</param>
	},
	getPixel: function(seriesIndex, dataIndex, xAxis, yAxis, component) {
		/// <summary>Gets the coordinates of specified data item when mapped to a Plot2D pixel.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series within the list of series rendered by this Renderer2D.</param>
		/// <param name="dataIndex" type="Number">An integer index of the data item in specified series.</param>
		/// <param name="xAxis" type="MindFusion.Charting.Axis">An Axis reference specifying the X axis.</param>
		/// <param name="yAxis" type="MindFusion.Charting.Axis">An Axis reference specifying the Y axis.</param>
		/// <param name="component" type="Components.Component">An instance of Plot2D or derived class.</param>
		/// <returns type="MindFusion.Drawing.Point">A Point containing Plot2D coordinates corresponding to specified data item.</returns>
	},
	hitTest: function(context, location) {
		/// <summary>Renderer2D.HitTest override. Hit-tests the stack representations of data items.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <param name="location" type="MindFusion.Drawing.Point">A Point specifying where to look for a data point.</param>
		/// <returns type="MindFusion.Charting.HitResult">A HitResult instance identifying the found data item.</returns>
	},
	measureDataRange: function(context) {
		/// <summary>Renderer2D.MeasureDataRange override. Measures the data range ofrendered series and assigns it to the associated Axis objects iftheir MinValue and MaxValue are not set.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.StackRenderer.__class = true;

MindFusion.Charting.StepAreaRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.StepAreaRenderer.__class = true;

MindFusion.Charting.StepRenderer.prototype = {
	draw: function(context) {
		/// <summary>SeriesRenderer.Draw override. Draws the series data in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.StepRenderer.__class = true;

MindFusion.Charting.StockPrice.prototype = {
};
MindFusion.Charting.StockPrice.__class = true;

MindFusion.Charting.StockPriceSeries.prototype = {
	getLabel: function(index, kind) {
		/// <summary>Implements Series.GetLabel. Returns DateTime value at specified index as an XAxisLabel.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="kind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <returns type="String">A string containing the item's label.</returns>
	},
	getValue: function(index, dimension) {
		/// <summary>Implements Series.GetValue. Returns a coordinate of specified point in this series.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <param name="dimension" type="Number">An integer value specifying the dimension whose coordinate to return.</param>
		/// <returns type="Number">A double-precision number representing the value of a data item in the series.</returns>
	},
	isEmphasized: function(index) {
		/// <summary>Implements Series.IsEmphasized. StockPriceSeries always returns false.</summary>
		/// <param name="index" type="Number">An integer value specifying the index of a data item.</param>
		/// <returns type="Boolean">true to emphasize the specified data item, or false otherwise.</returns>
	},
	isSorted: function(dimension) {
		/// <summary>Implements Series.IsSorted. StockPriceSeries always returns false.</summary>
		/// <param name="dimension" type="Number">An integer value identifying the dimension.</param>
		/// <returns type="Boolean">true if the values are sorted in specified dimension, or false otherwise.</returns>
	},
	onDataChanged: function() {
		/// <summary>Raises the DataChanged event.</summary>
	}
};
MindFusion.Charting.StockPriceSeries.__class = true;

MindFusion.Charting.TextRenderer.prototype = {
	drawLabelAtPoint: function(series, index, point, labelKind, format) {
		/// <summary>Draws the specified label centered at specified location.</summary>
		/// <param name="series" type="Series">A Series whose label to draw.</param>
		/// <param name="index" type="Number">An integer index of the label.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point specifying the label's location.</param>
		/// <param name="labelKind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <param name="format" type="MindFusion.Charting.Drawing.StringFormat" optional="true">Optional. A StringFormat instance.</param>
	},
	drawLabelInRect: function(series, index, bounds, labelKind, format) {
		/// <summary>Draws the specified label in specified layout rectangle.</summary>
		/// <param name="series" type="Series">A Series whose label to draw.</param>
		/// <param name="index" type="Number">An integer index of the label.</param>
		/// <param name="bounds" type="MindFusion.Drawing.Rect">A RectangleF specifying the layout rectangle.</param>
		/// <param name="labelKind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
		/// <param name="format" type="MindFusion.Charting.Drawing.StringFormat" optional="true">Optional. A StringFormat instance.</param>
	},
	drawRightFromPoint: function(series, index, point, labelKind) {
		/// <summary>Draws the specified label on the right side of specified point.</summary>
		/// <param name="series" type="Series">A Series whose label to draw.</param>
		/// <param name="index" type="Number">An integer index of the label.</param>
		/// <param name="point" type="MindFusion.Drawing.Point">A Point specifying the label's location.</param>
		/// <param name="labelKind" type="MindFusion.Charting.LabelKinds">A member of the LabelKinds enumeration.</param>
	}
};
MindFusion.Charting.TextRenderer.__class = true;

MindFusion.Charting.TextStyle.prototype = {
};
MindFusion.Charting.TextStyle.__class = true;

MindFusion.Charting.TextStyleHint = {
	/// <summary>Identifies text styles that can be accessed through RenderContent.</summary>
	/// <field name="AxisLabels">Identifies style used to draw axis labels.</field>
	/// <field name="AxisTitle">Identifies style used to draw axis title.</field>
	/// <field name="DataLabels">Identifies style used to draw data labels.</field>
	/// <field name="LegendTitle">Identifies style used to draw legend title.</field>
	/// <field name="Subtitle">Identifies style used to draw chart's sub-title.</field>
	/// <field name="Title">Identifies style used to draw chart's title.</field>
	/// <field name="Widget">Identifies style used to draw text in UI widgets.</field>
	AxisLabels: 0,
	AxisTitle: 1,
	DataLabels: 2,
	LegendTitle: 3,
	Subtitle: 4,
	Title: 5,
	Widget: 6
}
MindFusion.Charting.TextStyleHint.__enum = true;

MindFusion.Charting.Theme.prototype = {
	loadFrom: function(fileUrl) {
		/// <summary>Loads the theme values from an XML file.</summary>
		/// <param name="fileUrl" type="String">The URL of an XML file where the data should be read from.</param>
	},
	saveTo: function(fileUrl) {
		/// <summary>Saves the theme values to specified file.</summary>
		/// <param name="fileUrl" type="String">The URL where the theme's XML should be posted to.</param>
	}
};
MindFusion.Charting.Theme.__class = true;

MindFusion.Charting.ToolTip.prototype = {
};
MindFusion.Charting.ToolTip.__class = true;

MindFusion.Charting.UniformSeriesStyle.prototype = {
	fill: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Fill. Returns UniformFill for any data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	stroke: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.Stroke. Returns UniformStroke for any data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.Brush">A Brush instance.</returns>
	},
	strokeDashStyle: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeDashStyle. Returns UniformStrokeDashStyle for any data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="MindFusion.Charting.Drawing.DashStyle">A nullable DashStyle value specifying stroke dash style.</returns>
	},
	strokeThickness: function(seriesIndex, dataIndex) {
		/// <summary>Implements SeriesStyle.StrokeThickness. Returns UniformStrokeThickness for any data item.</summary>
		/// <param name="seriesIndex" type="Number">An integer index of a Series.</param>
		/// <param name="dataIndex" type="Number">An integer index of a data item in specified series.</param>
		/// <returns type="Number">A nullable double value specifying stroke thickness.</returns>
	}
};
MindFusion.Charting.UniformSeriesStyle.__class = true;

MindFusion.Charting.Vector.prototype = {
	negate: function() {
		/// <summary>Reverses the direction of this vector.</summary>
	},
	normalize: function() {
		/// <summary>Makes this vector a unit vector.</summary>
	},
};
MindFusion.Charting.Vector.__class = true;

MindFusion.Charting.Vector.add = function(vector1, vector2) {
	/// <summary>Adds two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="MindFusion.Charting.Vector">A vector representing the sum of specified vectors.</returns>
};
MindFusion.Charting.Vector.addPoint = function(vector, point) {
	/// <summary>Translates point by a vector.</summary>
	/// <param name="vector" type="MindFusion.Charting.Vector">The vector to add.</param>
	/// <param name="point" type="MindFusion.Drawing.Point">The reference point.</param>
	/// <returns type="MindFusion.Drawing.Point">The translated point.</returns>
};
MindFusion.Charting.Vector.angleBetween = function(vector1, vector2) {
	/// <summary>Determines the angle between two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="Number">The angle between specified vectors.</returns>
};
MindFusion.Charting.Vector.crossProduct = function(vector1, vector2) {
	/// <summary>Returns the size of cross-product of two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="Number">The size of cross-product.</returns>
};
MindFusion.Charting.Vector.determinant = function(vector1, vector2) {
	/// <summary>Finds the determinant of two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="Number">The determinant.</returns>
};
MindFusion.Charting.Vector.divide = function(vector, scalar) {
	/// <summary>Divides a vector by a scalar.</summary>
	/// <param name="vector" type="MindFusion.Charting.Vector">The vector to divide.</param>
	/// <param name="scalar" type="Number">The scalar value.</param>
	/// <returns type="MindFusion.Charting.Vector">A vector containing the division result.</returns>
};
MindFusion.Charting.Vector.multiply = function(vector1, vector2) {
	/// <summary>Returns the dot product of two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="Number">The dot product.</returns>
};
MindFusion.Charting.Vector.multiplyScalarAndVector = function(scalar, vector) {
	/// <summary>Multiplies vector by a scalar.</summary>
	/// <param name="scalar" type="Number">The scalar value.</param>
	/// <param name="vector" type="MindFusion.Charting.Vector">The vector to multiply.</param>
	/// <returns type="MindFusion.Charting.Vector">A vector containing the multiplication result.</returns>
};
MindFusion.Charting.Vector.multiplyVectorAndScalar = function(vector, scalar) {
	/// <summary>Multiplies vector by a scalar.</summary>
	/// <param name="vector" type="MindFusion.Charting.Vector">The vector to multiply.</param>
	/// <param name="scalar" type="Number">The scalar value.</param>
	/// <returns type="MindFusion.Charting.Vector">A vector containing the multiplication result.</returns>
};
MindFusion.Charting.Vector.subtract = function(vector1, vector2) {
	/// <summary>Subtracts two vectors.</summary>
	/// <param name="vector1" type="MindFusion.Charting.Vector">The first vector.</param>
	/// <param name="vector2" type="MindFusion.Charting.Vector">The second vector.</param>
	/// <returns type="MindFusion.Charting.Vector">A vector representing the difference between specified vectors.</returns>
};

MindFusion.Charting.XAxisRenderer.prototype = {
	draw: function(context) {
		/// <summary>Component.draw override. Draws this component in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	effectiveAxis: function(context) {
		/// <summary>AxisRenderer.effectiveAxis override. Gets the effective horizontal Axis in current context,getting one from Plot2D or chart control if there's no local Axis associated with this renderer.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Axis">An Axis instance.</returns>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.XAxisRenderer.__class = true;

MindFusion.Charting.XmlPersistContext.prototype = {
	addChildElement: function(elementName, parentElement, innerText) {
		/// <summary>Adds a new child node with the specified name andvalue to the specified parent node.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="innerText" type="void"></param>
	},
	readBool: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a boolean value with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readBrush: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a MindFusion.Drawing.Brush object with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readBrushes: function(parentElement) {
		/// <summary>Reads all brushes.</summary>
		/// <param name="parentElement" type="void"></param>
	},
	readBrushList: function(elementName, subElementName, parentElement) {
		/// <summary>Reads a list of brushes.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	readColor: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a color with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readDashStyleList: function(elementName, subElementName, parentElement) {
		/// <summary>Reads a list of dash styles.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	readEnum: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads an enum value with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readFloat: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a float value with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readFloatList: function(elementName, subElementName, parentElement) {
		/// <summary>Reads a list of floats.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	readInt: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads an integer value with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readObject: function(elementName, parentElement) {
		/// <summary>Reads an object with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	readString: function(elementName, parentElement, defaultValue) {
		/// <summary>Reads a string value with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defaultValue" type="void"></param>
	},
	readStringFormat: function(elementName, parentElement, defultFormat) {
		/// <summary>Reads a StringFormat object with the specified name.</summary>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
		/// <param name="defultFormat" type="void"></param>
	},
	writeBool: function(boolValue, elementName, parentElement) {
		/// <summary>Writes a boolean value with the specified name.</summary>
		/// <param name="boolValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeBrush: function(brush, elementName, parentElement) {
		/// <summary>Writes a reference to the specified brush. The brushis registered within the internal hashtable forsubsequent serialization.</summary>
		/// <param name="brush" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeBrushes: function(parentElement) {
		/// <summary>Writes all currently accumulated brushes.</summary>
		/// <param name="parentElement" type="void"></param>
	},
	writeBrushList: function(list, elementName, subElementName, parentElement) {
		/// <summary>Writes a list of brushes.</summary>
		/// <param name="list" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeColor: function(color, elementName, parentElement) {
		/// <summary>Writes the specified color.</summary>
		/// <param name="color" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeColorList: function(list, elementName, subElementName, parentElement) {
		/// <summary>Writes a list of colors.</summary>
		/// <param name="list" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeDashStyleList: function(list, elementName, subElementName, parentElement) {
		/// <summary>Writes a list of dash styles.</summary>
		/// <param name="list" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeEnum: function(enumValue, elementName, parentElement) {
		/// <summary>Writes the specified enum value.</summary>
		/// <param name="enumValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeFloat: function(floatValue, elementName, parentElement) {
		/// <summary>Writes a float value with the specified name.</summary>
		/// <param name="floatValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeFloatList: function(list, elementName, subElementName, parentElement) {
		/// <summary>Writes a list of floating-point numbers.</summary>
		/// <param name="list" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="subElementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeInt: function(intValue, elementName, parentElement) {
		/// <summary>Writes an integer value with the specified name.</summary>
		/// <param name="intValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeObject: function(objectValue, elementName, parentElement) {
		/// <summary>Writes the specified object under the specified name.</summary>
		/// <param name="objectValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	},
	writeString: function(stringValue, elementName, parentElement) {
		/// <summary>Writes a string value with the specified name.</summary>
		/// <param name="stringValue" type="void"></param>
		/// <param name="elementName" type="void"></param>
		/// <param name="parentElement" type="void"></param>
	}
};
MindFusion.Charting.XmlPersistContext.__class = true;

MindFusion.Charting.YAxisRenderer.prototype = {
	draw: function(context) {
		/// <summary>Component.draw override. Draws this component in specified RenderContext.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	},
	effectiveAxis: function(context) {
		/// <summary>AxisRenderer.effectiveAxis override. Gets the effective vertical Axis in current context,getting one from Plot2D or chart control if there's no local Axis associated with this renderer.</summary>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
		/// <returns type="MindFusion.Charting.Axis">An Axis instance.</returns>
	},
	measure: function(maxWidth, maxHeight, context) {
		/// <summary>Component.measure override. Measures the desired size of this component.</summary>
		/// <param name="maxWidth" type="Number">The maximum width provided by parent component.</param>
		/// <param name="maxHeight" type="Number">The maximum height provided by parent component.</param>
		/// <param name="context" type="MindFusion.Charting.RenderContext">A RenderContext instance.</param>
	}
};
MindFusion.Charting.YAxisRenderer.__class = true;

MindFusion.Charting.ZoomController.prototype = {
	drawInteraction: function(graphics) {
		/// <summary>PlotController.drawInteraction override. Draws the currently selected data rangethat that controller will zoom into when the user releases the mouse button.</summary>
		/// <param name="graphics" type="MindFusion.Charting.Drawing.Graphics">A Graphics instance.</param>
	},
	onMouseDown: function(x, y) {
		/// <summary>Plot2DController.OnMouseDown override. Called when the user presses a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseMove: function(x, y) {
		/// <summary>PlotController.OnMouseMove override. Called when the user moves the mouse.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseUp: function(x, y) {
		/// <summary>PlotController.OnMouseUp override. Called when the user releases a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
	},
	onMouseWheel: function(x, y, delta) {
		/// <summary>PlotController.OnMouseWheel override. Called when the user releases a mouse button.</summary>
		/// <param name="x" type="Number">A number value specifying the horizontal position of mouse pointer.</param>
		/// <param name="y" type="Number">A number value specifying the vertical position of mouse pointer.</param>
		/// <param name="delta" type="Number">A number value specifying the direction and the amount of scrolling needed.</param>
	}
};
MindFusion.Charting.ZoomController.__class = true;

MindFusion.CancelEventArgs.prototype = {
	get_cancel: function() {
		/// <summary>Gets a value indicating whether the event should be canceled.</summary>
		/// <returns type="Boolean">true if the event should be canceled, otherwise false.</returns>
	},
	set_cancel: function(value) {
		/// <summary>Sets a value indicating whether the event should be canceled.</summary>
		/// <param name="value" type="Boolean">true if the event should be canceled, otherwise false.</param>
	}
};
MindFusion.CancelEventArgs.__class = true;

MindFusion.EventArgs.prototype = {
};
MindFusion.EventArgs.__class = true;

MindFusion.Key.prototype = {
	send: function() {
		/// <summary>Sends this key as input to focused element.</summary>
	}
};
MindFusion.Key.__class = true;

MindFusion.KeyboardLayout.prototype = {
	addKey: function(content, left, top, width, height) {
		/// <summary>Adds a new key with specified content and position to the layout.</summary>
		/// <param name="content" type="String">A string containing the key's character.</param>
		/// <param name="left" type="Number">A number specifying key's horizontal position.</param>
		/// <param name="top" type="Number">A number specifying key's vertical position.</param>
		/// <param name="width" type="Number">A number specifying key's width.</param>
		/// <param name="height" type="Number">A number specifying key's height.</param>
	},
};
MindFusion.KeyboardLayout.__class = true;

MindFusion.KeyboardLayout.create = function(layoutDef) {
	/// <summary>Creates and initializes a new KeyboardLayout from the specified definition object.</summary>
	/// <param name="layoutDef" type="Object">A JavaScipt layout definition generated by Keyboard Creator tool.</param>
	/// <returns type="MindFusion.KeyboardLayout">A KeyboardLayout object.</returns>
};

MindFusion.KeyboardMode = {
	/// <summary>Identifies keyboard layout modes.</summary>
	/// <field name="Compact">A layout containing only the alpha-numeric block of keys.</field>
	/// <field name="Default">Laptop-like layout containing alpha-numeric and functional keys.</field>
	/// <field name="Extended">Desktop-like layout which also adds a num-pad block.</field>
	Compact: 0,
	Default: 1,
	Extended: 2
}
MindFusion.KeyboardMode.__enum = true;

MindFusion.KeyboardState.prototype = {
};
MindFusion.KeyboardState.__class = true;


MindFusion.mf.KeyboardState.Alt = function() {
	/// <summary>A boolean value specifying state of Alt modifier.</summary>
};


MindFusion.mf.KeyboardState.CapsLock = function() {
	/// <summary>A boolean value specifying state of Caps Lock.</summary>
};


MindFusion.mf.KeyboardState.Ctrl = function() {
	/// <summary>A boolean value specifying state of Ctrl modifier.</summary>
};


MindFusion.mf.KeyboardState.Insert = function() {
	/// <summary>A boolean value specifying state of the Insert key.</summary>
};


MindFusion.mf.KeyboardState.NumLock = function() {
	/// <summary>A boolean value specifying state of Num Lock.</summary>
};


MindFusion.mf.KeyboardState.Shift = function() {
	/// <summary>A boolean value specifying state of Shift modifier.</summary>
};

MindFusion.VirtualKeyboard.prototype = {
	addEventListener: function(eventName, handler) {
		/// <summary>Registers an event handler.</summary>
		/// <param name="eventName" type="String">The name of the event to handle.</param>
		/// <param name="handler" type="Function">A function that handles the event.</param>
	},
	getAutoReleaseModifierKeys: function() {
		/// <summary>Gets a value indicating whether pressing a regular key should automatically release modifier keys such as shift, alt, control etc. (except CapsLock).</summary>
		/// <returns type="Boolean">true to release modifier keys automatically, or false otherwise.</returns>
	},
	getAutoRepeat: function() {
		/// <summary>Gets a value indicating whether the component should synthesize keyboard events repeatedly when a virtual key is pressed down, until the key is released.</summary>
		/// <returns type="Boolean">true to enable automatic repeat, or false otherwise.</returns>
	},
	getInputLocale: function() {
		/// <summary>Gets the current input language.</summary>
		/// <returns type="String">A string specifying keyboard's locale.</returns>
	},
	getLicenseLocation: function() {
		/// <summary>Gets the URL of the keyboard's license file.</summary>
		/// <returns type="String">A valid URL string that specifies the location of the license key.</returns>
	},
	getMode: function() {
		/// <summary>Gets the current keyboard layout mode.</summary>
		/// <returns type="MindFusion.KeyboardMode">A member of the KeyboardMode enumeration specifying current layout mode.</returns>
	},
	getScaleToFitParent: function() {
		/// <summary>Gets a value indicating whether the keyboard scales to fit inside its parent element.</summary>
		/// <returns type="Boolean">true to scale the keyboard, or false otherwise.</returns>
	},
	getTheme: function() {
		/// <summary>Gets the current theme.</summary>
		/// <returns type="String">A string specifying keyboard's theme.</returns>
	},
	sendKey: function(key) {
		/// <summary>Sends the specified key as input to focused element.</summary>
		/// <param name="key" type="MindFusion.Key">The virtual key that should be sent.</param>
	},
	setAutoReleaseModifierKeys: function(value) {
		/// <summary>Sets a value indicating whether pressing a regular key should automatically release modifier keys such as shift, alt, control etc. (except CapsLock).</summary>
		/// <param name="value" type="Boolean">true to release modifier keys automatically, or false otherwise.</param>
	},
	setAutoRepeat: function(value) {
		/// <summary>Sets a value indicating whether the component should synthesize keyboard events repeatedly when a virtual key is pressed down, until the key is released.</summary>
		/// <param name="value" type="Boolean">true to enable automatic repeat, or false otherwise.</param>
	},
	setInputLocale: function(value) {
		/// <summary>Sets the current input language.</summary>
		/// <param name="value" type="String">A string specifying keyboard's locale.</param>
	},
	setLicenseLocation: function(value) {
		/// <summary>Sets the URL of the keyboard's license file.</summary>
		/// <param name="value" type="String">A valid URL string that specifies the location of the license key.</param>
	},
	setMode: function(value) {
		/// <summary>Sets the current keyboard layout mode.</summary>
		/// <param name="value" type="MindFusion.KeyboardMode">A member of the KeyboardMode enumeration specifying current layout mode.</param>
	},
	setScaleToFitParent: function(value) {
		/// <summary>Sets a value indicating whether the keyboard scales to fit inside its parent element.</summary>
		/// <param name="value" type="Boolean">true to scale the keyboard, or false otherwise.</param>
	},
	setTheme: function(value) {
		/// <summary>Sets the current theme.</summary>
		/// <param name="value" type="String">A string specifying keyboard's theme.</param>
	}
};
MindFusion.VirtualKeyboard.__class = true;

MindFusion.VirtualKeyboard.create = function(element) {
	/// <summary>Creates and initializes a new VirtualKeyboard on the specified DOM element. This method is static and can be called without creating an instance of the class.</summary>
	/// <param name="element" type="Object">The DOM element that the keyboard should be attached to.</param>
	/// <returns type="MindFusion.VirtualKeyboard">A VirtualKeyboard object that represents the newly created keyboard.</returns>
};
